#!/bin/bash

fast=false
brig=false
glass=false
outdir=false
verbose=false
diff=false
newctxjson=false
link=false
clean=false
TIME=false
# parallel make arguments
PARALLEL=1
TOKEN_READ=0
TOKEN_WRITE=0
TFAS_OPTS="-Mvvvvl"

shopt -s nullglob
set -o pipefail

TESTDIR=$(cd $(dirname $0); pwd -P)

prev_mflag=""
for mflag in $MAKEFLAGS; do
    case $mflag in
    n)  exit 0
        ;;
    -j[1-9]|-j[1-9][0-9])
        PARALLEL=${mflag#-j}
        ;;
    [1-9]|[1-9][0-9])
        if [ "$prev_mflag" = "-j" ]; then
            PARALLEL=${mflag}
        fi
        ;;
    --jobserver-*=*)
        fds=${mflag/*=/}
        vec=(${fds/,/ })
        if eval "command >&${vec[1]}" 2>/dev/null; then : ; else
            echo >&2 "invalid --jobserver -- must use '+' in Makefile rule"
            exit 1
        fi
        TOKEN_READ=${vec[0]}
        TOKEN_WRITE=${vec[1]}
        ;;
    esac
    prev_mflag=$mflag
done

while expr "$1" : - >/dev/null; do
    case $1 in
    -f) fast=true
        ;;
    -c) clean=true
        ;;
    -b) brig=true
        ;;
    -g) glass=true
        ;;
    -l) link=true
        ;;
    -t)
        TIME=true
        ;;
    -d)
        diff=true
        ;;
    -N)
        newctxjson=true
        ;;
    -j)
        shift
        if [[ $1 =~ ^[0-9]+$ ]]; then
            PARALLEL=$1
        else
            echo >&2 "invalid number -j $1"
        fi
        ;;
    -j[1-9]|-j[1-9][0-9])
        PARALLEL=${1#-j}
        ;;
    -o)
        shift
        outdir=true
        odir=$1
        ;;
    -v)
        verbose=true
        ;;
    -*)
        echo >&2 "unknown argument $1"
        ;;
    esac
    shift
done

# If neither '-b' or '-g' specified run for both brig and glass as default case
if ! $brig && ! $glass; then
    brig=true;
    glass=true;
fi

#glsc_args="--placement-order ingress_before_egress --libpd --placement secret"
#glsc_args="--verbose 2 -vl 2 -S -G --placement-order ingress_before_egress --no-bin --new_ctx_json"
glsc_args="--verbose 2 -vl 2 -S -G --placement-order ingress_before_egress --new_ctx_json"

trap 'release_all_tokens; exit' 2

if [ $# -eq 0 ]; then
    set *.p4
fi

count=$#

rm -rf faillog.txt
FAILLOG=$(pwd -P)/faillog.txt

echo -n "Test run started at " >$FAILLOG
date >> $FAILLOG

TRY_BINDIRS="
    $PWD
    $PWD/..
    $PWD/../..
    $PWD/../../..
    $PWD/../../../..
    $TESTDIR/..
    $TESTDIR/../..
"

function searchdir () {
    found=""
    if [ -x "$BUILDDIR/$1" ]; then
        echo $BUILDDIR/$1
        return
    fi
    for d in $TRY_BINDIRS; do
        if [[ $2 ]]; then
            if [ -d "$d/$2" ]; then
                #found=`find $d/$2 -executable -type f -name $1 -print -quit`
                found=`find $d/$2 -type f -name $1 -print -quit`
                if [ -n "$found" ]; then
                    break;
                fi
            fi
        else
            #found=`find $d -executable -type f -name $1 -print -quit`
            found=`find $d -name $1 -print -quit`
            if [ -n "$found" ]; then
                break;
            fi
        fi
    done
    if [ -z "$found" ]; then
        echo >&2 "Can't find $1 executable"
        echo false
    else
        echo $found
    fi
}

function findexec () {
    evarref=\$"$1"
    evalue=`eval "expr \"$evarref\" "`
    if [ ! -x "$evalue" ]; then
        e=$(searchdir $2 $4) 
        eval "${1}=${e}"
        evalue=`eval "expr \"$evarref\" "`
        if [ -x "$evalue" ]; then
            echo "Using $evalue"
        else
            #echo >&2 "Can't find $3 executable"
            eval "${1}=false"
        fi
    fi
}

#FINDFUNC  PARAM        EXECUTABLE              NAME                    OPTIONAL SEARCH DIR PREFIX
findexec GLSC           "shell.py"              "glass"                 ""
findexec BRIG           "p4c-tofino"            "brig"                  ""
findexec STF            "simple_test_harness"   "simple_test_harness"   "model"
findexec TFAS           "tfas"                  "tfas"                  ""
findexec TFLINK         "tflink"                "tflink"                ""
findexec REFLOW         "reflow"                "reflow"                ""
findexec JSON_DIFF      "json_diff"             "json_diff"             ""
findexec SCHEMA         "gen_schema.py"         "gen_schema.py"         ""     
findexec SCHEMA_VAL     "validate.py"           "validate.py"           ""     

function not() { if "$@"; then return 1; else return 0; fi }

ctxt_json_ignore=$TESTDIR/ctxt_json_ignore
if $newctxjson; then
    ctxt_json_ignore=$TESTDIR/ctxt_json_ignore_new
fi
echo "Using context json ignore file - $ctxt_json_ignore"

if [ -r $ctxt_json_ignore ]; then
    CTXT_DIFFARGS="-l handle -l start_offset -l entry_number -i @$ctxt_json_ignore"
else
    CTXT_DIFFARGS="-al handle -i table_type"
fi

TIMEOUT_COMMAND=$(which gtimeout || which timeout)
run() {
    if $verbose; then
        echo "$@" >/dev/tty
    fi
    if [ -z "$TIMEOUT" ]; then
        $TIME_COMMAND "$@"
    else
        $TIME_COMMAND $TIMEOUT_COMMAND --foreground $TIMEOUT "$@"
    fi
    status=$?
    if [ $status -eq 124 ]; then
        echo >&2 $1 TIMEOUT
    elif [ $status -gt 128 ]; then
        echo >&2 $1 CRASH with signal $(expr $status - 128)
    elif [ $status -gt 0 ]; then
        echo >&2 $1 FAILED
    fi
    return $status
}

function link_json() {
    p4file=$1
    pushd $(dirname $p4file) >/dev/null
    name=$(basename $p4file .p4)
    ok=true
    if [ -d $name.out ];then
        cd $name.out
        bindir=$PWD/glass
        jsondir=$PWD/glass/cfg
        if $brig;then
            if [ -d brig ];then
                bindir=$PWD/brig
                jsondir=$PWD/brig
            else
                msg="$msg no $jsondir/brig found"
                ok=false
                rv=1
            fi
        fi
        if $ok && run $TFLINK -o $bindir/tofino.bin $jsondir/*.cfg.json* >/dev/null 2>&1; then
            msg="$msg link pass"
        else
            msg="$msg link failed"
            flock $FAILLOG -c "echo '$1:' >>$FAILLOG; sed -e 's/^/  /'$name.out/link.txt >>$FAILLOG"
            rv=1
        fi
    fi
    return $rv
}

function test_p4() {
    p4file="$1"
    pushd $(dirname $p4file) >/dev/null
    name=$(basename $p4file .p4)
    if $clean; then
        if [ -d $name.out ]; then
            rm -rf $name.out
        fi
    fi
    mkdir -p $name.out
    expect_fail=$(sed -n "/^$name.p4/s/[^ ]* *//p" expected_failures.txt 2>/dev/null | head -1)
    cd $name.out
    ok=true
    rv=0
    fail_type=""
    #echo "about to run $name.p4, expecting ${expect_fail:-no} failure"
    msg="$p4file"
    start=`date +%s`
    tfafile=""
    if $brig; then
        tfafile=brig/$name.tfa
    else
        tfafile=glass/$name.tfa 
    fi
    if $fast && [ -r $tfafile ]; then
        true
    else
        mkdir -p brig
        mkdir -p glass
        # Remove old assembly files
        if [ -d glass ]; then
            rm -f glass/$name.tfa
            rm -f glass/out.tfa
        fi
        if [ -d brig ]; then
            rm -f brig/$name.tfa
            rm -f brig/out.tfa
        fi
        # Run both glass and brig if '-b' and '-g' not specified 
        if $brig; then
            clog='brig.log'
            if $ok && not run $BRIG -D__TARGET_TOFINO__ ../$name.p4 -o brig/out.tfa </dev/null >brig.log 2>&1; then
                ok=false
            fi
            if not $ok; then
                msg="$msg p4 brig compile failed"
            fi
        fi
        if $glass; then 
            clog='glsc.log'
            if not run $GLSC -o glass $glsc_args ../$name.p4 </dev/null >glsc.log 2>&1; then
                ok=false
            fi
            if not $ok; then
                msg="$msg p4 glass compile failed"
            fi
        fi
        if not $ok; then
            fail_type="compile"
            rv=1
        fi
        if [ -d glass ]; then
            cd glass
            if [ out.tfa -nt $name.tfa ]; then
                rm -f $name.tfa
                ln -s out.tfa $name.tfa
            fi
            cd ..
        fi
        if [ -d brig ]; then
            cd brig 
            if [ out.tfa -nt $name.tfa ]; then
                rm -f $name.tfa
                ln -s out.tfa $name.tfa
            fi
            cd ..
        fi
        if $glass && [ ! -r glass/$name.tfa ] && $ok; then
            msg="$msg p4 glass compile failed to produce asm"
            fail_type="compile"
            rv=1
            ok=false
        fi
        if $brig && [ ! -r brig/$name.tfa ] && $ok; then
            msg="$msg p4 brig compile failed to produce asm"
            fail_type="compile"
            rv=1
            ok=false
        fi
        if not $ok && ( [ $count -eq 1 ] || [ "$expect_fail" != "compile" ] ); then
            flock $FAILLOG -c "echo '$p4file:' >>$FAILLOG; sed 's/^/ /' $clog >>$FAILLOG"
        fi
    fi
    glsc_cfg=.
    if $ok; then
        rm -f $brig/*.json
        if [ -d glass/cfg ]; then
            glsc_cfg=glass/cfg
        fi
    fi
    for f in $glsc_cfg/*.json; do
        if $REFLOW $f | gzip -9 > $f.gz; then
            rm $f
        fi
    done
    if $brig; then
        TFAS_OPTS="-vvvvl"
    fi
    if $newctxjson; then
        TFAS_OPTS="-N $TFAS_OPTS"
    fi
    if $ok && run $TFAS -o brig $TFAS_OPTS brig/tfas.config.log $tfafile >brig/tfas.log 2>&1; then
        # Validate context json output from assembler
        $SCHEMA > schema.json 
        python $SCHEMA_VAL brig/tbl-cfg schema.json > context_json_schema_validate.log
        for f in $name.out/*.cfg.json; do
            if $REFLOW $f | gzip -9 > $f.gz; then
                rm $f
            fi
        done
        if $diff; then
            for f in brig/*.cfg.json.gz; do
                if zcmp -s $f $glsc_cfg/$(basename $f); then
                    continue
                elif [ "$f" = "$name.out/regs.pipe.cfg.json.gz" ]; then
                    $JSON_DIFF -i mau $f $glsc_cfg/$(basename $f)
                    if [ $? -gt 128 ]; then
                        echo "***json_diff crashed"
                    fi
                    continue
                fi
                $JSON_DIFF $f $glsc_cfg/$(basename $f)
            done > json_diff.txt
            glsc_ctxt=glass/${name}_context_llir.json
            if [ -d glass/context ]; then
                glsc_ctxt=glass/context/mau.context.json
                if $newctxjson; then
                    glsc_ctxt=glass/context/context.json
                fi
            fi
            brig_ctxt=brig/tbl-cfg
            if [ -r $brig_ctxt ]; then
                { $JSON_DIFF $CTXT_DIFFARGS $brig_ctxt $glsc_ctxt;
                  if [ $? -gt 128 ]; then echo "***json_diff crashed"; fi; } >> json_diff.txt
                #echo $JSON_DIFF $CTXT_DIFFARGS $brig_ctxt $glsc_ctxt;
            fi
            cnt=$(grep -Ev '^\+\+\+|^---|"int_inj"' json_diff.txt | grep -Ec '^\+|^-')
            if [ $cnt -gt 0 ]; then
                msg="$msg mismatch"
                fail_type="mismatch"
                rv=1
                if [ $count -eq 1 ] || [ "$expect_fail" != "mismatch" ]; then
                    flock $FAILLOG -c "echo '$p4file:' >>$FAILLOG; cat json_diff.txt >>$FAILLOG"
                fi
                ok=false
            else
                msg="$msg pass"
                let pass++
            fi
        fi
    elif $ok; then
        msg="$msg tfas failed"
        fail_type="tfas"
        rv=1
        if [ $count -eq 1 ] || [ "$expect_fail" != "tfas" ]; then
            flock $FAILLOG -c "echo '$p4file:' >>$FAILLOG; sed -e 's/^/ /' -e'/\n/!a\' brig/tfas.log >>$FAILLOG"
        fi
        ok=false
    fi
    if [ "$expect_fail" != "" ]; then
        if $ok; then
            msg="$msg (UNEXPECTED PASS -- expected $expect_fail failure)"
            rv=3
        elif [ "$expect_fail" != "$fail_type" ]; then
            msg="$msg (expected $expect_fail failure)"
            if [ "$fail_type" = "mismatch" -o "$expect_fail" = "compile" ]; then
                rv=2
            fi
        else
            msg="$msg (expected)"
            rv=2
        fi
    fi
    if $TIME; then
        let elapsed=`date +%s`-start
        let min=elapsed/60
        let sec=elapsed%60
        if [ $sec -lt 10 ]; then
            sec=0$sec
        fi
        msg="$msg ($min:$sec)"
    fi
    echo "$msg"
    popd >/dev/null
    return $rv
}

function test_tfa() {
    tfafile="$1"
    msg="$tfafile"
    pushd $(dirname $1) >/dev/null
    name=$(basename $1 .tfa)
    mkdir -p $name.out
    expect_fail=$(sed -n "/^$name.tfa/s/[^ ]* *//p" expected_failures.txt 2>/dev/null | head -1)
    #cd $name.out
    ok=true
    rv=0
    if not run $TFAS -Mvvvvl $name.out/tfas.config.log $name.tfa >$name.out/tfas.log 2>&1; then
        msg="$msg tfas failed"
        fail_type="tfas"
        if [ $count -eq 1 ] || [ "$expect_fail" != "tfas" ]; then
            flock $FAILLOG -c "echo '$1:' >>$FAILLOG; sed -e 's/^/ /' -e '/\n/!a\' $name.out/tfas.log >>$FAILLOG"
        fi
        rv=1
        ok=false
    else
        msg="$msg pass"
    fi
    if [ "$expect_fail" != "" ]; then
        if $ok; then
            msg="$msg (UNEXPECTED PASS -- expected $expect_fail failure)"
            rv=3
        elif [ "$expect_fail" != "$fail_type" ]; then
            msg="$msg (expected $expect_fail failure)"
            if [ "$fail_type" = "mismatch" -o "$expect_fail" = "compile" ]; then
                rv=2
            fi
        else
            msg="$msg (expected)"
            rv=2
        fi
    fi
    echo "$msg"
    popd >/dev/null
    return $rv
}

function test_stf() {
    if [ ! -x $STF ]; then
        echo "$msg simple_test_framework not available"
        return 4
    fi
    msg="$1"
    pushd $(dirname $1) >/dev/null
    name=$(basename $1 .stf)
    rv=0
    #if [[ ( ! -f `pwd`/$name.out/$name.tfa || $fast = false ) && ! -d $outdir ]]; then
    if ! $outdir; then
        TFAS_OPTS="-vvvvl"
        test_p4 $name.p4
    fi
    #if [[ -r `pwd`/$name.out/$name.tfa && ( ! -r `pwd`/$name.out/$name.out/tofino-bin || $fast = false ) ]]; then
    #    mkdir -p $name.out
    #    if not run $TFAS -Mvvvvl $name.out/tfas.config.log $name.out/$name.tfa >$name.out/tfas.log 2>&1; then
    #        msg="$msg tfas failed"
    #        flock $FAILLOG -c "echo '$1:' >>$FAILLOG; sed -e 's/^/ /' -e '/\n/!a\' $name.out/tfas.log >>$FAILLOG"
    #        rv=1
    #    fi
    #fi
    if [[ $rv == 0 && -d $name.out ]]; then
        bindir=$name.out
        jsondir=$name.out/cfg
        if [ -d "$bindir/$name.out" ]; then
            bindir="$bindir/$name.out"
            jsondir=$bindir
        fi
        if [ -d outdir ]; then
            bindir=$outdir
            jsondir=$bindir
        fi
        start=`date +%s`
        linked=false
        if [ -r $bindir/tofino.bin ]; then
            linked=true
            for f in $bindir/*.cfg.json*; do
                if [ $f -nt $bindir/tofino.bin ]; then
                    linked=false
                    break
                fi
            done
        fi
        if $linked || run $TFLINK -o $bindir/tofino.bin $jsondir/*.cfg.json* >/dev/null 2>&1; then
            export TOFINO_BIN=$bindir/tofino.bin
            export TABLE_CONFIG=$bindir/tbl-cfg
            if run "$STF" -l $bindir $name.stf >$name.out/stf.txt 2>&1; then
                msg="$msg pass"
            else
                msg="$msg fail"
                rv=1
                flock $FAILLOG -c "echo '$1:' >>$FAILLOG; sed -e 's/^/  /' $name.out/stf.txt >>$FAILLOG"
            fi
        else
            msg="$msg failed"
            rv=1
        fi
        if $TIME; then
            let elapsed=`date +%s`-start
            let min=elapsed/60
            let sec=elapsed%60
            if [ $sec -lt 10 ]; then
                sec=0$sec
            fi
            msg="$msg ($min:$sec)"
        fi
        echo "$msg"
    else
        echo "$msg not built"
        rv=4
    fi
    popd >/dev/null
    return $rv
}

pass=0
fail=0
skip=0
expected_fail=0
unexpected_pass=0
running=0
tokens=0
token_request=0

function get_token() {
    eval "dd bs=1 count=1 of=/dev/null <&$TOKEN_READ" 2>/dev/null
    exit 99
}

function release_one_token() {
    eval "dd if=/dev/zero bs=1 count=1 >&$TOKEN_WRITE" 2>/dev/null
    let tokens--
    let token_request--
}

function release_all_tokens() {
    if (( token_request > 0 )); then
        eval "dd if=/dev/zero bs=1 count=$token_request >&$TOKEN_WRITE" 2>/dev/null
        token_request=0
    fi
}

function wait_1() {
    wait -n
    case $? in
    0)  let pass++
        ;;
    1)  let fail++
        ;;
    2)  let fail++
        let expected_fail++
        ;;
    3)  let pass++
        let unexpected_pass++
        ;;
    4)  let skip++
        ;;
    99) let tokens++
        return
        ;;
    esac
    let running--
}

if $verbose; then echo "running $PARALLEL threads"; fi

for file in "$@"; do
    if (( running >= PARALLEL + tokens )); then
        if (( TOKEN_READ && tokens == token_request )); then
            let token_request++
            get_token &
        fi
        wait_1
    fi
    if $outdir; then
        if [ "${file##*.}" == "stf" ]; then
            let running++
            test_stf $file &
        else
            echo "-o option can only be passed for stf file"
            echo "Input file : $file"
            exit 1
        fi
    elif [ "${file##*.}" == "p4" ]; then
        let running++
        test_p4 $file &
    elif [ "${file##*.}" == "tfa" ]; then
        let running++
        test_tfa $file &
    elif [ "${file##*.}" == "stf" ]; then
        let running++
        test_stf $file &
    else
        echo "unrecognized file type $file"
    fi
    wait
    if $link; then
        link_json $file
    fi
done

while (( running > 0 )); do
    while (( running < PARALLEL + tokens  && tokens > 0)); do
        release_one_token
    done
    wait_1
done

release_all_tokens

if [ $pass -ne 1 ]; then
    pmsg="$pass tests passed"
else
    pmsg="1 test passed"
fi
if [ $fail -ne 1 ]; then
    fmsg="$fail tests failed"
else
    fmsg="1 test failed"
fi

if [ $unexpected_pass -gt 1 ]; then
    uxp=" ($unexpected_pass tests unexpectedly pass)"
elif [ $unexpected_pass -gt 0 ]; then
    uxp=" ($unexpected_pass test unexpectedly passes)"
else
    uxp=""
fi

echo "$pmsg, $fmsg ($expected_fail expected)$uxp"
echo "$pmsg, $fmsg ($expected_fail expected)$uxp" >>$FAILLOG

if [ $fail -ne $expected_fail ]; then
    exit 1
fi
