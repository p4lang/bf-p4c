#!/usr/bin/env python

"""
gen_schema.py: Generates a JSON Schema model for resource allocation information
on the p4 compiler for Tofino.
"""

import jsl
import json
import inspect

#### ENTRY FORMATS ####

class ActionDataEntryFormat(jsl.Document):
    title = "ActionDataEntryFormat"
    description = "Context information for the entries on an ActionDataTable."

    entry_number = jsl.IntField(required=True, description="Entry number uniquely identifying this entry.")
    fields = jsl.ArrayField(items=jsl.DictField(
        properties={
            "field_name": jsl.StringField(required=True, description="Name of this field."),
            "field_width": jsl.IntField(required=True, description="Width of this field, in bits."),
            "lsb_mem_word_idx": jsl.IntField(required=True, description="Index of the wide word containing the least significant bit of this field."),
            "lsb_mem_word_offset": jsl.IntField(required=True, description="Offset of the least significant bit of the field within this memory word."),
            "const_tuples": jsl.ArrayField(items=jsl.DictField(properties={
                "dest_start": jsl.IntField(required=True, description="Index of the least significant bit of this segment of the constant."),
                "value": jsl.IntField(required=True, description="Value of this segment of the constant."),
                "dest_width": jsl.IntField(required=True, description="Width of this segment of the constant.")
            }), description="A constant may be split over multiple entries. This list contains information about each segment of a constant."),
            "source": jsl.StringField(required=True, description="Type of source that originates this entry.", enum=[
                'zero',
                'constant',
                'spec'
            ]),
            "start_bit": jsl.IntField(required=True, description="A field could be split in multiple slices. Corresponds to the offset, from the least significant bit, where this slice starts."),
            "mask_bit_offset": jsl.IntField(description="Offset of the mask. The value will be 0 if this data is not used for conditionals.")
        }, description="Description of a field in an action data stage table."),
        required=True,
        description="List of fields in this table.")

class TernEntryFormat(jsl.Document):
    title = "TernEntryFormat"
    description = "Context information for the entries on a Ternary MatchStageTable."

    entry_number = jsl.IntField(required=True, description="Entry number uniquely identifying this entry.")
    fields = jsl.ArrayField(items=jsl.DictField(
        properties={
            "field_name": jsl.StringField(required=True, description="Name of this field."),
            "field_width": jsl.IntField(required=True, description="Width of this field, in bits."),
            "lsb_mem_word_idx": jsl.IntField(required=True, description="Index of the wide word containing the least significant bit of this field."),
            "msb_mem_word_idx": jsl.IntField(required=True, description="Index of the wide word containing the most significant bit of this field."),
            "lsb_mem_word_offset": jsl.IntField(required=True, description="Offset, within a table word, corresponding to the start of this field, starting from the least significant bit."),
            "start_bit": jsl.IntField(required=True, description="A field could be split in multiple slices. Corresponds to the offset, from the least significant bit, where this slice starts."),
            "source": jsl.StringField(required=True, description="Type of source that originated this entry.", enum=[
                'version',
                'zero',
                'parity',
                'payload',
                'range',
                'spec'
            ]),
            "range": jsl.DictField(properties={
                "type": jsl.IntField(required=True, enum=[2, 4], description="Range match type, indicating 2-bit DirtCAM or 4-bit DirtCAM."),
                "is_duplicate": jsl.BooleanField(required=True, description="Whether this range field is a duplicate generated by the compiler or not.")
            }, description="Range field information. This value is optional, and will only appear if the field uses ranges.")
        },
        description="Description of a field in a ternary stage table."),
    required=True,
    description="List of fields in this table.")

class TindEntryFormat(jsl.Document):
    title = "TindEntryFormat"
    description = "Context information for the entries on a Ternary Indirection MatchStageTable."

    entry_number = jsl.IntField(required=True, description="Entry number uniquely identifying this entry.")
    fields = jsl.ArrayField(items=jsl.DictField(
        properties={
            "field_name": jsl.StringField(required=True, description="Name of this field."),
            "field_width": jsl.IntField(required=True, description="Width of a field in bits."),
            "source": jsl.StringField(required=True, description="Type of source that originated this entry.", enum=[
                'zero',
                'instr',
                'adt_ptr',
                'meter_ptr',
                'stats_ptr',
                'stful_ptr',
                'sel_ptr',
                'next_table',
                'selection_length',
                'selection_length_shift',
                'immediate'
            ]),
            "lsb_mem_word_idx": jsl.IntField(required=True, description="Index of the wide word containing the least significant bit of this field."),
            "msb_mem_word_idx": jsl.IntField(required=True, description="Index of the wide word containing the most significant bit of this field."),
            "lsb_mem_word_offset": jsl.IntField(required=True, description="Offset, within a table word, corresponding to the start of this field, starting from the least significant bit."),
            "start_bit": jsl.IntField(required=True, description="A field could be split in multiple slices. Corresponds to the offset, from the least significant bit, where this slice starts."),
            "enable_pfe": jsl.BooleanField(required=True, description="Whether to enable or disable per flow enable functionality on this entry."),
            "immediate_name": jsl.StringField(description="Name of the [source] field, if it was an IMMEDIATE source."),
        }, description="Description of a field in a ternary indirection table."),
        required=True,
        description="List of fields in this table.")

class ExactEntryFormat(jsl.Document):
    title = "ExactEntryFormat"
    description = "Context information for an ExactMatchStageTable."

    entry_number = jsl.IntField(required=True, description="Entry number uniquely identifying this entry.")
    fields = jsl.ArrayField(items=jsl.DictField(properties={
        "field_name": jsl.StringField(required=True, description="Name of this field."),
        "field_width": jsl.IntField(required=True, description="Width of a field, in bits."),
        "source": jsl.StringField(required=True, description="Type of source that originated this entry.", enum=[
            'zero',
            'version',
            'instr',
            'adt_ptr',
            'meter_ptr',
            'stats_ptr',
            'stful_ptr',
            'sel_ptr',
            'next_table',
            'selection_length',
            'selection_length_shift',
            'proxy_hash',
            'spec',
            'immediate'
        ]),
        "lsb_mem_word_idx": jsl.IntField(required=True, description="Index of the wide word containing the least significant bit of this field."),
        "msb_mem_word_idx": jsl.IntField(required=True, description="Index of the wide word containing the most significant bit of this field."),
        "lsb_mem_word_offset": jsl.IntField(required=True, description="Offset, within a table word, corresponding to the start of this field, starting from the least significant bit."),
        "start_bit": jsl.IntField(required=True, description="A field could be split in multiple slices. Corresponds to the offset, from the least significant bit, where this slice starts."),
        "immediate_name": jsl.StringField(description="Name of the [source] field, if it was an IMMEDIATE source."),
        "enable_pfe": jsl.BooleanField(required=True, description="Whether to enable or disable per flow enable functionality on this entry."),
        "match_mode": jsl.StringField(enum=["exact", "s0q1", "s1q0", "unused"], description="Indicates the how the hardware is configured to match on this region.  Only applicable when the source is SPEC and for ATCAM tables."),
    }, required=True), required=True)

#### STAGE TABLES ####

class StageTable(jsl.Document):
    class ActionHandleFormat(jsl.Document):
        title = "ActionHandleFormat"
        description = "ActionHandleFormat context information."

        vliw_instruction = jsl.IntField(required=True, description="The VLIW instruction address.")
        vliw_instruction_full = jsl.IntField(required=True, description="Full VLIW address. This value is necessary in case this action is used as default..")
        next_table = jsl.IntField(required=True, description="The next table address for the driver to use when programming the match overhead.  This can be less than 8 bits if the hardware indirection table is used.")
        next_table_full = jsl.IntField(required=True, description="The full hardware address of the next table pointer to use when this action is called.  This is an 8-bit value consisting of {stage, logical table ID}.")
        action_name = jsl.StringField(description="The name of the action.")
        action_handle = jsl.IntField(required=True, description="The handle of this particular action.")
        table_name = jsl.StringField(description="The name of the match table.")

        immediate_fields = jsl.ArrayField(items=jsl.AnyOfField([
            jsl.DictField(properties={
                "param_shift": jsl.IntField(required=True, description="The parameter start least significant bit stored in the immediate.  P4 parameters can be stored in match overhead and/or action data tables."),
                "param_name": jsl.StringField(required=True, description="The name of the parameter."),
                "param_type": jsl.StringField(required=True, enum=["parameter", "constant"], description="The type of this immediate field."),
                "dest_start": jsl.IntField(required=True, description="Multiple parameters/constants can be mapped to the match overhead immediate field.  This integer indicates the least significant bit in that match overhead field where this immediate field begins."),
                "dest_width": jsl.IntField(required=True, description="Width of the slice being written to the immediate field.")
            }, description="An action parameter stored in match overhead, for the case of a parameter (non-constant) overhead."),
            jsl.DictField(properties={
                "const_value": jsl.IntField(required=True, description="Indicates a constant value to be programmed."),
                "param_name": jsl.StringField(required=True, description="The name of the parameter."),
                "param_type": jsl.StringField(required=True, enum=["parameter", "constant"], description="The type of this immediate field."),
                "dest_start": jsl.IntField(required=True, description="Multiple parameters/constants can be mapped to the match overhead immediate field.  This integer indicates the least significant bit in that match overhead field where this immediate field begins."),
                "dest_width": jsl.IntField(required=True, description="Width of the slice being written to the immediate field.")
            }, description="An action parameter stored in match overhead, for the case of a constant (immediate) overhead.")]),
            required=True, description="An array of action parameters stored in the match overhead. The parameters can be either from the match spec, or constants.")

    class ATCAMMemoryResourceAllocation(jsl.Document):
        title = "ATCAMMemoryResourceAllocation"
        description = "ATCAMMemoryResourceAllocation context information."

        column_priority = jsl.IntField(required=True, description="Priority for this column. A lower value means higher priority.")
        memory_units_and_vpns = jsl.ArrayField(items=jsl.DictField(properties={
            "memory_units": jsl.ArrayField(items=jsl.IntField(), required=True, description="An array of memory unit IDs.  For SRAMs, the memory unit ID is 12 * row + col.  For TCAMs, the memory unit ID is 12 * col + row.  (The formula difference is not a typo.)"),
            "vpns": jsl.ArrayField(items=jsl.IntField(), required=True, description="An array of VPNs assigned for the match entries packed in these memory units.")
        }), required=True, description="Array of bins of 1024 partitions that constitute a column.")

    class MemoryResourceAllocation(jsl.Document):
        title = "MemoryResourceAllocation"
        description = "MemoryResourceAllocation context information."

        memory_type = jsl.StringField(required=True, enum=['tcam', 'sram', 'map_ram', 'gateway', 'ingress_buffer'], description="Type of memory allocated.")
        spare_bank_memory_unit = jsl.IntField(description="For synthetic two-port tables (stateful, meter, stats, selectors), indicates which memory unit ID is the spare bank initially.  This is used by the driver for initialization.")

        memory_units_and_vpns = jsl.ArrayField(items=jsl.DictField(properties={
            "memory_units": jsl.ArrayField(items=jsl.IntField(), required=True, description="An array of memory unit IDs.  For SRAMs, the memory unit ID is 12 * row + col.  For TCAMs, the memory unit ID is 12 * col + row.  (The formula difference is not a typo.)"),
            "vpns": jsl.ArrayField(items=jsl.IntField(), required=True, description="An array of VPNs assigned for the match entries packed in these memory units.")
        }), required=True, description="Memory resource allocation information.")

    class HashMatchMemoryResourceAllocation(jsl.Document):
        title = "HashMatchMemoryResourceAllocation"
        description = "HashMatchMemoryResourceAllocation context information."

        memory_units_and_vpns = jsl.ArrayField(items=jsl.DictField(properties={
            "memory_units": jsl.ArrayField(items=jsl.IntField(), required=True, description="An array of SRAM memory unit IDs.  The memory unit ID is 12 * row + col."),
            "vpns": jsl.ArrayField(items=jsl.IntField(), required=True, description="An array of VPNs assigned for the match entries packed in these memory units.")
        }), required=True, description="Memory resource allocation information in this ExactMatchStageTable.")

        hash_function_id = jsl.IntField(required=True, description="Hash function ID that is used to compute the RAM enable select bits and the RAM word entry bits.")
        hash_select_bit_lo = jsl.IntField(required=True, description="Position of the least significant bit boundary in the 52-bit hash value to use to activate a RAM unit. Value allowed: 40-51 (inclusive).")
        hash_select_bit_hi = jsl.IntField(required=True, description="Position of the most significant bit boundary in the 52-bit hash value to use to activate a RAM unit. Values allowed: 40-51 (inclusive).")
        hash_entry_bit_lo = jsl.IntField(required=True, enum=[0, 10, 20, 30, 40], description="Position of the least significant bit boundary in the 52-bit hash value to use to determine a RAM unit row.")
        hash_entry_bit_hi = jsl.IntField(required=True, enum=[9, 19, 29, 39, 49], description="Position of the most significant bit boundary in the 52-bit hash value to use to determine a RAM unit row.")
        number_select_bits = jsl.IntField(required=True, description="Number of hash bits used for selecting the RAM. Values allowed: 0-12 (inclusive).")
        number_entry_bits = jsl.IntField(required=True, enum=[10], description="Number of hash bits used for selecting the word in a RAM.")

    title = "StageTable"
    description = "StageTable common context information."

    stage_table_type = jsl.StringField(required=True, enum=[
        'hash_way',
        'ternary_match',
        'ternary_indirection',
        'action_data',
        'direct_match',
        'hash_match',
        'selection',
        'idletime',
        'phase_0_match',
        'statistics',
        'hash_action',
        'meter',
        'algorithmic_tcam_match',
        'proxy_hash_match',
        'match_with_no_key'
    ], description="Type of this stage table.")

    stage_number = jsl.IntField(required=True, description="Number identifying the stage containing this stage table.")
    logical_table_id = jsl.IntField(required=True, description="Unique identifier for this logical table within this stage.")
    size = jsl.IntField(required=True, description="Number of entries in this stage table.")

    pack_format = jsl.ArrayField(items=jsl.DictField(properties={
            "table_word_width": jsl.IntField(required=True, description="Bit width of the table's word."),
            "memory_word_width": jsl.IntField(required=True, description="Bit width of a single physical memory word."),
            "entries_per_table_word": jsl.IntField(required=True, description="Number of entries that are packed into a given table word."),
            "number_memory_units_per_table_word": jsl.IntField(required=True, description="Number of units combined together to form a single table word. Notice that for table words that occupy multiple memory units, the most significant bits of the table word are found in the lowest indexed memory unit.")
        }, required=True, description="Structure containing information about how the memory for this stage table is layed out."))

    memory_resource_allocation = jsl.OneOfField([
        jsl.NullField(),
        jsl.DocumentField("MemoryResourceAllocation", as_ref=True)
    ], required=True, description="Representation of the Memory resource allocation for this stage table.")

class HashWayStageTable(StageTable):
    title = "HashWayStageTable"
    description = "HashWayStageTable context information."

    way_number = jsl.IntField(required=True, description="The number identifying this hash way.")
    logical_table_id = jsl.IntField(description="Unique identifier for this stage table within the stage. This is not required for Phase0.")

    pack_format = jsl.ArrayField(items=jsl.DictField(properties={
            "table_word_width": jsl.IntField(required=True, description="Bit width of the table's word."),
            "memory_word_width": jsl.IntField(required=True, description="Bit width of a single physical memory word."),
            "entries_per_table_word": jsl.IntField(required=True, description="Number of entries that are packed into a given table word."),
            "number_memory_units_per_table_word": jsl.IntField(required=True, description="Number of units combined together to form a single table word. Notice that for table words that occupy multiple memory units, the most significant bits of the table word are found in the lowest indexed memory unit."),
            "entries": jsl.ArrayField(items=jsl.DocumentField("ExactEntryFormat"), required=True, description="Entries packed in this stage table's memory.")
        }, required=True, description="Structure containing information about how the memory for this stage table is layed out."))

    memory_resource_allocation = jsl.OneOfField([
        jsl.DocumentField("HashMatchMemoryResourceAllocation", description="Representation of the memory resource allocation for this stage table. This structure is particular to a HashWayStageTable."),
        jsl.NullField()
    ], required=True)

class ExactMatchStageTable(StageTable):
    title = "ExactMatchStageTable"
    description = "ExactMatchStageTable context information."

    hash_functions = jsl.ArrayField(items=jsl.DictField(properties={
        "hash_bits": jsl.ArrayField(items=jsl.DictField(properties={
            "hash_bit": jsl.IntField(required=True, description="Identifier for this particular hash bit."),
            "bits_to_xor": jsl.ArrayField(items=jsl.DictField(properties={
                "field_name": jsl.StringField(required=True, description="Identifier for this particular hash bit."),
                "field_bit": jsl.IntField(required=True, description="Bit within the byte of the field corresponding to this hash.")
            }, description="Description of bit from the match spec to include in the hash computation for a particular hash output bit."))
        }), required=True, description="Array of match spec bit properties to include in the calculation for each particular hash result output bit.")}), description="Array of hash functions for this match table.")

    ways = jsl.ArrayField(items=jsl.DocumentField("HashWayStageTable", as_ref=True), required=True, description="Context information for each particular way in this exact match stage table.")

    action_format = jsl.ArrayField(items=jsl.DocumentField("ActionHandleFormat", as_ref=True), required=True, description="List of action handles for this exact match stage table.")

    memory_resource_allocation = jsl.OneOfField([
        jsl.DocumentField("HashMatchMemoryResourceAllocation", as_ref=True, description="Representation of the memory resource allocation for this stage table. This structure is particular to ExactMatchStageTables, except for ATCAM."),
        jsl.NullField()], required=True)

    default_next_table = jsl.OneOfField([jsl.IntField(), jsl.NullField()], required=True, description="Full address of the default next table, if any.")
    idletime_stage_table = jsl.DocumentField("IdletimeStageTable", as_ref=True, description="Idletime stage table associated to this stage table.")

class HashMatchStageTable(ExactMatchStageTable):
    title = "HashMatchStageTable"
    description = "HashMatchStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['hash_match'], description="Type of exact match stage table.")

class HashActionStageTable(StageTable):
    title = "HashActionStageTable"
    description = "HashActionStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['hash_action'], description="Type of exact match stage table.")

    hash_functions = jsl.ArrayField(items=jsl.DictField(properties={
        "hash_bits": jsl.ArrayField(items=jsl.DictField(properties={
            "hash_bit": jsl.IntField(required=True, description="Identifier for this particular hash bit."),
            "bits_to_xor": jsl.ArrayField(items=jsl.DictField(properties={
                "field_name": jsl.StringField(required=True, description="Identifier for this particular hash bit."),
                "field_bit": jsl.IntField(required=True, description="Bit within the byte of the field corresponding to this hash."),
            }, description="Description of bit from the match spec to include in the hash computation for a particular hash output bit."))
        }), required=True, description="Array of match spec bit properties to include in the calculation for each particular hash result output bit.")}), description="Array of hash functions for this match table.")

    default_next_table = jsl.OneOfField([jsl.IntField(), jsl.NullField()], required=True, description="Full address of the default next table, if any.")
    action_format = jsl.ArrayField(items=jsl.DocumentField("ActionHandleFormat", as_ref=True), required=True, description="List of action handles for this exact match stage table.")

    memory_resource_allocation = jsl.NullField()
    idletime_stage_table = jsl.DocumentField("IdletimeStageTable", as_ref=True, description="Idletime stage table associated to this stage table.")

class DirectMatchStageTable(ExactMatchStageTable):
    title = "DirectMatchStageTable"
    description = "DirectMatchStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['direct_match'], description="Type of exact match stage table.")

class ProxyHashMatchStageTable(ExactMatchStageTable):
    title = "ProxyHashMatchStageTable"
    description = "ProxyHashMatchStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['proxy_hash_match'], description="Type of exact match stage table.")

    proxy_hash_bit_width = jsl.IntField(required=True, description="An integer indicating the bit width of proxy value stored in place of the normal exact match key.")
    proxy_hash_algorithm = jsl.StringField(description="The name of the hash algorithm used to compute the proxy value.")

class MatchWithNoKeyStageTable(StageTable):
    title = "MatchWithNoKeyStageTable"
    description = "MatchWithNoKeyStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['match_with_no_key'], description="Type of exact match stage table.")

    default_next_table = jsl.OneOfField([jsl.IntField(), jsl.NullField()], required=True, description="Full address of the default next table, if any.")
    action_format = jsl.ArrayField(items=jsl.DocumentField("ActionHandleFormat", as_ref=True), required=True, description="List of action handles for this exact match stage table.")

class ATCAMMatchStageTable(StageTable):
    title = "ATCAMMatchStageTable"
    description = "ATCAMMatchStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['algorithmic_tcam_match'], description="Type of exact match stage table.")

    default_next_table = jsl.OneOfField([jsl.IntField(), jsl.NullField()], required=True, description="Full address of the default next table, if any.")
    memory_resource_allocation = jsl.ArrayField(jsl.DocumentField("ATCAMMemoryResourceAllocation", as_ref=True), required=True, description="A representation of the memory resources used by this ATCAM stage table.")

    hash_functions = jsl.ArrayField(items=jsl.DictField(properties={
        "hash_bits": jsl.ArrayField(items=jsl.DictField(properties={
            "hash_bit": jsl.IntField(required=True, description="Identifier for this particular hash bit."),
            "bits_to_xor": jsl.ArrayField(items=jsl.DictField(properties={
                "field_name": jsl.StringField(required=True, description="Identifier for this particular hash bit."),
                "field_bit": jsl.IntField(required=True, description="Bit within the byte of the field corresponding to this hash."),
            }, description="Description of bit from the match spec to include in the hash computation for a particular hash output bit."))
        }), required=True, description="Array of match spec bit properties to include in the calculation for each particular hash result output bit.")}), description="Array of hash functions for this match table.")

    action_format = jsl.ArrayField(items=jsl.DocumentField("ActionHandleFormat", as_ref=True), required=True, description="List of action handles for this exact match stage table.")

    idletime_stage_table = jsl.DocumentField("IdletimeStageTable", as_ref=True, description="Idletime stage table associated to this stage table.")

class Phase0MatchStageTable(StageTable):
    title = "Phase0MatchStageTable"
    description = "Phase0MatchStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['phase_0_match'], description="Type of exact match stage table.")

    logical_table_id = jsl.IntField(description="Unique identifier for this stage table within the stage. This is not required for Phase0.")

    pack_format = jsl.ArrayField(items=jsl.DictField(properties={
            "table_word_width": jsl.IntField(required=True, description="Bit width of the table's word."),
            "memory_word_width": jsl.IntField(required=True, description="Bit width of a single physical memory word."),
            "entries_per_table_word": jsl.IntField(required=True, description="Number of entries that are packed into a given table word."),
            "number_memory_units_per_table_word": jsl.IntField(required=True, description="Number of units combined together to form a single table word. Notice that for table words that occupy multiple memory units, the most significant bits of the table word are found in the lowest indexed memory unit."),
            # FIXME: Add Phase0 entry format.
            "entries": jsl.ArrayField()
        }, required=True, description="Structure containing information about how the memory for this stage table is layed out."))

class TernMatchStageTable(StageTable):
    title = "TernMatchStageTable"
    description = "TernMatchStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['ternary_match'], description="Type of match stage table.")

    pack_format = jsl.ArrayField(items=jsl.DictField(properties={
            "table_word_width": jsl.IntField(required=True, description="Bit width of the table's word."),
            "memory_word_width": jsl.IntField(required=True, description="Bit width of a single physical memory word."),
            "entries_per_table_word": jsl.IntField(required=True, description="Number of entries that are packed into a given table word."),
            "number_memory_units_per_table_word": jsl.IntField(required=True, description="Number of units combined together to form a single table word. Notice that for table words that occupy multiple memory units, the most significant bits of the table word are found in the lowest indexed memory unit."),
            "entries": jsl.ArrayField(items=jsl.DocumentField("TernEntryFormat"), required=True, description="Entries packed in this stage table's memory.")
        }, required=True, description="Structure containing information about how the memory for this stage table is layed out."))

    ternary_indirection_stage_table = jsl.DocumentField("TindStageTable", as_ref=True, description="Ternary indirection stage table associated to this stage table.")
    idletime_stage_table = jsl.DocumentField("IdletimeStageTable", as_ref=True, description="Idletime stage table associated to this stage table.")
    default_next_table = jsl.OneOfField([jsl.IntField(), jsl.NullField()], required=True, description="Full address of the default next table, if any.")

class StatisticsStageTable(StageTable):
    title = "StatisticsStageTable"
    description = "StatisticsStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['statistics'], description="Type of stage table.")

class MeterStageTable(StageTable):
    title = "MeterStageTable"
    description = "MeterStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['meter'], description="Type of stage table.")

    default_lower_huffman_bits_included = jsl.IntField(required=True, enum=[7], description="An integer that indicates how many of the hardware meter address bits are being provided by default configuration registers programmed by the compiler.  The meter address field in match overhead never includes the 7 least significant bits of the hardware meter address.")

class SelectionStageTable(StageTable):
    title = "SelectionStageTable"
    description = "SelectionStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['selection'], description="Type of stage table.")

class StatefulStageTable(StageTable):
    title = "StatefulStageTable"
    description = "StatefulStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['stateful'], description="Type of stage table.")

class IdletimeStageTable(StageTable):
    title = "IdletimeStageTable"
    description = "IdletimeStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['idletime'], description="Type of stage table.")

    precision = jsl.IntField(required=True, description="An integer representing how many bits are stored per idletime entry.")
    disable_notification = jsl.BooleanField(required=True, description="A Boolean indicating that no CPU notification will be sent when the flow state changes.")
    two_way_notification = jsl.BooleanField(required=True, description="A Boolean indicating if the CPU will be notified when a flow goes from inactive to active.  (For flows that go from active to inactive, the CPU is notified by default.)")
    enable_pfe = jsl.BooleanField(required=True, description="A Boolean indicating that entry aging can be done on a per-flow basis.  Note that this reserves one of the states in the aging state machine to indicate the entry does not timeout.")

class TindStageTable(StageTable):
    title = "TindStageTable"
    description = "TindStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['ternary_indirection'], description="Type of stage table.")

    logical_table_id = jsl.IntField(description="Unique identifier for this stage table within the stage. This is not required for TernaryIndirection.")

    pack_format = jsl.ArrayField(items=jsl.DictField(properties={
            "table_word_width": jsl.IntField(required=True, description="Bit width of the table's word."),
            "memory_word_width": jsl.IntField(required=True, description="Bit width of a single physical memory word."),
            "entries_per_table_word": jsl.IntField(required=True, description="Number of entries that are packed into a given table word."),
            "number_memory_units_per_table_word": jsl.IntField(required=True, description="Number of units combined together to form a single table word. Notice that for table words that occupy multiple memory units, the most significant bits of the table word are found in the lowest indexed memory unit."),
            "entries": jsl.ArrayField(items=jsl.DocumentField("TindEntryFormat"), required=True, description="Entries packed in this stage table's memory.")
        }, required=True, description="Structure containing information about how the memory for this stage table is layed out."))

    action_format = jsl.ArrayField(items=jsl.DocumentField("ActionHandleFormat", required=True, as_ref=True), required=True, description="List of action handles in this stage table.")

class ActionDataStageTable(StageTable):
    title = "ActionDataStageTable"
    description = "ActionDataStageTable context information."
    stage_table_type = jsl.StringField(required=True, enum=['action_data'], description="Type of stage table.")

    pack_format = jsl.ArrayField(items=jsl.DictField(properties={
            "action_handle": jsl.IntField(required=True, description="Action handle to which this pack format refers. On an ActionDataStageTable's pack format, there is one pack format per action."),
            "table_word_width": jsl.IntField(required=True, description="Bit width of the table's word."),
            "memory_word_width": jsl.IntField(required=True, description="Bit width of a single physical memory word."),
            "entries_per_table_word": jsl.IntField(required=True, description="Number of entries that are packed into a given table word."),
            "number_memory_units_per_table_word": jsl.IntField(required=True, description="Number of units combined together to form a single table word. Notice that for table words that occupy multiple memory units, the most significant bits of the table word are found in the lowest indexed memory unit."),
            "entries": jsl.ArrayField(items=jsl.DocumentField("ActionDataEntryFormat"), required=True, description="Entries packed in this stage table's memory.")
        }, required=True, description="Structure containing information about how the memory for this stage table is layed out."))

#### MATCH TABLE ATTRIBUTES ####

class MatchWithNoKeyTableAttr(jsl.Document):
    title = "MatchWithNoKeyTableAttributes"
    description = "Attributes of an MatchWithNoKeyTable context information."
    match_type = jsl.StringField(required=True, enum=['match_with_no_key'], description="Type of match table.")

    stage_tables = jsl.ArrayField(jsl.DocumentField("MatchWithNoKeyStageTable", as_ref=True), required=True, description="An array of stage-specific resource objects for this match table. Keyless match tables should have only one of these.")

class HashActionTableAttr(jsl.Document):
    title = "HashActionTableAttributes"
    description = "Attributes of an HashActionTable context information."
    match_type = jsl.StringField(required=True, enum=['hash_action'], description="Type of match table.")

    stage_tables = jsl.ArrayField(jsl.DocumentField("HashActionStageTable", as_ref=True), required=True, description="An array of stage-specific resource objects for this match table. Keyless match tables should have only one of these.")

class Phase0MatchTableAttr(jsl.Document):
    title = "Phase0MatchTableAttributes"
    description = "Attributes of an Phase0MatchTable context information."
    match_type = jsl.StringField(required=True, enum=['phase_0_match'], description="Type of match table.")

    stage_tables = jsl.ArrayField(jsl.DocumentField("Phase0MatchStageTable", as_ref=True), required=True, description="An array of stage-specific resource objects for this match table. Phase 0 match tables should have only one of these.")

class ExactMatchTableAttr(jsl.Document):
    title = "ExactMatchTableAttributes"
    description = "Attributes of an ExactMatchTable context information."
    match_type = jsl.StringField(required=True, enum=['exact'], description="Type of match table.")

    prefix_length = jsl.IntField(description="Bit width of the prefix field. Only applicable if this table is also a CLPM unit.")
    prefix_upper = jsl.IntField(description="Maximum prefix length to be used. Only applicable if this table is also a CLPM Unit.")
    prefix_lower = jsl.IntField(description="Minimum prefix length to be used. Only applicable if this table is also a CLPM Unit.")

    stage_tables = jsl.ArrayField(items=jsl.AnyOfField([
        jsl.DocumentField("HashMatchStageTable", as_ref=True),
        jsl.DocumentField("HashActionStageTable", as_ref=True),
        jsl.DocumentField("ProxyHashMatchStageTable", as_ref=True),
        jsl.DocumentField("DirectMatchStageTable", as_ref=True),
    ]), required=True, description="An array of stage-specific resource objects for this match table.")

class TernMatchTableAttr(jsl.Document):
    title = "TernMatchTableAttributes"
    description = "Attributes of a TernMatchTable."
    match_type = jsl.StringField(required=True, enum=['ternary'], description="Type of match table.")

    prefix_length = jsl.IntField(description="Bit width of the prefix field. Only applicable if this table is also a CLPM unit.")
    prefix_upper = jsl.IntField(description="Maximum prefix length to be used. Only applicable if this table is also a CLPM Unit.")
    prefix_lower = jsl.IntField(description="Minimum prefix length to be used. Only applicable if this table is also a CLPM Unit.")

    stage_tables = jsl.ArrayField(items=jsl.DocumentField("TernMatchStageTable", as_ref=True), required=True, description="An array of stage-specific resource objects for this match table.")

class ALPMMatchTableAttr(jsl.Document):
    title = "ALPMMatchTableAttributes"
    description = "Attributes of a ALPMMatchTable."
    match_type = jsl.StringField(required=True, enum=['alpm'], description="Type of match table.")

    number_partitions = jsl.IntField(required=True, description="Number of partitions in this ALPM table.")
    pre_classifier = jsl.DocumentField("MatchTable", required=True, description="Match table that serves as the ternary pre-classifier table for this ALPM table.")

    action_function_name = jsl.StringField(required=True, description="Name of the action function related to this ALPM table.")
    field_name = jsl.StringField(required=True, description="FIXME")

    algorithmic_units = jsl.ArrayField(items=jsl.DocumentField("MatchTable", as_ref=True), required=True, description="List of ATCAM algorithmic units related to this ALPM table.")

    # No stage tables here, actually.
    stage_tables = jsl.ArrayField(max_items=0)

class ATCAMMatchTableAttr(jsl.Document):
    title = "ATCAMMatchTableAttributes"
    description = "Attributes of a ATCAMMatchTable."
    match_type = jsl.StringField(required=True, enum=['algorithmic_tcam'], description="Type of match table.")

    number_partitions = jsl.IntField(description="Number of partitions in this ATCAM table.")
    algorithmic_units = jsl.ArrayField(items=jsl.DocumentField("MatchTable", as_ref=True), description="List of ATCAM algorithmic units related to this ATCAM table.")

    # No stage tables here, actually. BUT the units do...
    stage_tables = jsl.ArrayField(jsl.DocumentField("ATCAMMatchStageTable", as_ref=True))

class CLPMMatchTableAttr(jsl.Document):
    title = "CLPMMatchTableAttributes"
    description = "Attributes of a CLPMMatchTable."
    match_type = jsl.StringField(required=True, enum=['chained_lpm'], description="Type of match table.")

    prefix_length = jsl.IntField(required=True, description="Bit width of the prefix field.")
    prefix_upper = jsl.IntField(description="Maximum prefix length to be used.")
    prefix_lower = jsl.IntField(description="Minimum prefix length to be used.")
    prefix_units = jsl.ArrayField(items=jsl.DocumentField("MatchTable", as_ref=True), required=True, description="List of match tables that are prefixes to this CLPM match.")

    # No stage tables here, actually.
    stage_tables = jsl.ArrayField(max_items=0)

#### TABLES ####

class Table(jsl.Document):
    title = "Table"
    description = "Common table context information."

    # Properties of a P4-level table.
    name = jsl.StringField(required=True, description="Name of this table.")
    handle = jsl.IntField(required=True, description="Unique identifier for this table.")
    size = jsl.IntField(required=True, description="Minimum size of this table, as specified in P4.")
    direction = jsl.StringField(required=True, description="Whether this table is used for ingress or egress.", enum=['ingress', 'egress'])

class MatchTable(Table):
    class ReferencedTable(jsl.Document):
        title = "ReferencedTable"
        description = "Information about P4 tables referenced from another table."

        name = jsl.StringField(required=True, description="Name of the referenced table.")
        handle = jsl.IntField(required=True, description="Handle of the referenced table.")
        how_referenced = jsl.StringField(required=True, enum=['direct', 'indirect'], description="Whether the table is directly or indirectly referenced.")

    title = "MatchTable"
    description = "MatchTable context information."
    table_type = jsl.StringField(required=True, enum=['match'], description="Type of table.")

    uses_range = jsl.BooleanField(required=True, description="Whether this table uses range fields or not.")

    action_data_table_refs = jsl.ArrayField(jsl.DocumentField("ReferencedTable", as_ref=True), required=True, description="Action Data Tables referenced from this table.")
    selection_table_refs = jsl.ArrayField(jsl.DocumentField("ReferencedTable", as_ref=True), required=True, description="Selection Tables referenced from this table.")
    statistics_table_refs = jsl.ArrayField(jsl.DocumentField("ReferencedTable", as_ref=True), required=True, description="Statistics Tables referenced from this table.")
    meter_table_refs = jsl.ArrayField(jsl.DocumentField("ReferencedTable", as_ref=True), required=True, description="Meter Tables referenced from this table.")
    stateful_table_refs = jsl.ArrayField(jsl.DocumentField("ReferencedTable", as_ref=True), required=True, description="Stateful Tables referenced from this table.")
    default_next_table_mask = jsl.IntField(required=True, description="Mask used to not overwrite the next_table field in the match spec. FIXME")

    default_selector_value = jsl.IntField(description="FIXME. Only applicable if this match table uses a selector.")
    default_selector_mask = jsl.IntField(description="FIXME. Only applicable if this match table uses a selector.")

    match_key_fields = jsl.ArrayField(items=jsl.DictField(properties={
        "name": jsl.StringField(required=True, description="The name of the field."),
        "match_type": jsl.StringField(required=True, enum=["exact", "lpm", "range", "ternary", "valid"], description="An indication of the match type for this field."),
        "start_bit": jsl.IntField(required=True, description="An integer indicating the start bit, from the least significant bit, to use for the field."),
        "bit_width": jsl.IntField(required=True, description="The number of bits of the field involved in match.  If this is not the entire field, the field slice can be represented as field[start_bit + bit_width - 1 : 0]."),
        "bit_width_full": jsl.IntField(required=True, description="The bit width of the field in its entirety.  This will match the bit_width attribute except when it is a field slice."),
    }), required=True, description="An array of match key field properties.")

    actions = jsl.ArrayField(items=jsl.DictField(properties={
        "name": jsl.StringField(required=True, description="The P4 name of the action."),
        "handle": jsl.IntField(required=True, description="A unique identifier for this action."),
        "allowed_as_default_action": jsl.BooleanField(required=True, description="A Boolean indicating if this action can be used as a table default action (the table miss action)."),
        "disallowed_as_default_action_reason": jsl.StringField(description="If this action cannot be used as a default action, a short description indicating the reason it cannot."),
        "p4_parameters": jsl.ArrayField(items=jsl.DictField(properties={
            "name": jsl.StringField(required=True, description="The name of the parameter from P4."),
            "start_bit": jsl.IntField(required=True, description="The bit offset of this parameter in the action parameter list. This value refers to the most significant bit."),
            "bit_width": jsl.IntField(required=True, description="The bit width of the parameter."),
            "default_value": jsl.IntField(description="Default value of this parameter, in case this table is the default one.")
        }), required=True, description="An array of P4 parameter properties used by this action."),
        "indirect_resources": jsl.ArrayField(items=jsl.AnyOfField([
            jsl.DictField(properties={
                "access_mode": jsl.StringField(required=True, enum=['index'], description="The mode used to access the indirect resource. If this value is 'constant', then the indirect resource is accessed through a constant index that cannot be changed at runtime. If it is 'index', the index comes from action data."),
                "parameter_name": jsl.StringField(description="The action parameter name corresponding to how the resource is accessed. Only applicable if the access mode is 'index'."),
                "parameter_index": jsl.IntField(description="The index of the parameter in the action parameter list."),
                "resource_name": jsl.StringField(required=True, description="The name of the indirect resource consumed.")
            }),
            jsl.DictField(properties={
                "access_mode": jsl.StringField(required=True, enum=['constant'], description="The mode used to access the indirect resource. If this value is 'constant', then the indirect resource is accessed through a constant index that cannot be changed at runtime. If it is 'index', the index comes from action data."),
                "value": jsl.IntField(required=True, description="The constant value. Only applicable if the access mode is 'constant'."),
                "resource_name": jsl.StringField(required=True, description="The name of the indirect resource consumed.")
            }),
        ]), required=True, description="A list of the indirect resources consumed by this action."),
        "override_stat_addr_pfe": jsl.BooleanField(required=True, description="A Boolean indicating the driver should always write a 1 to the PFE bit in the statistics address in match overhead."),
        "override_meter_addr_pfe": jsl.BooleanField(required=True, description="A Boolean indicating the driver should always write a 1 to the PFE bit in the meter address in match overhead."),
        "override_stateful_addr_pfe": jsl.BooleanField(required=True, description="A Boolean indicating the driver should always write a 1 to the PFE bit in the stateful address in match overhead."),
        "override_stat_addr": jsl.BooleanField(required=True, description="A Boolean indicating the driver should always write the value indicated in override_stat_full_addr to the statistics address in match overhead."),
        "override_meter_addr": jsl.BooleanField(required=True, description="A Boolean indicating the driver should always write the value indicated in override_meter_full_addr to the meter address in match overhead."),
        "override_stateful_addr": jsl.BooleanField(required=True, description="A Boolean indicating the driver should always write the value indicated in override_stateful_full_addr to the stateful address in match overhead."),
        "override_stat_full_addr": jsl.IntField(required=True, description="The full hardware address of the statistics address to encode in the match overhead.  This is a 20-bit value."),
        "override_meter_full_addr": jsl.IntField(required=True, description="The full hardware address of the meter address to encode in the match overhead.  This is a 27-bit value."),
        "override_stateful_full_addr": jsl.IntField(required=True, description="The full hardware address of the stateful address to encode in the match overhead.  This is a 27-bit value.")
    }), required=True, description="An array of action properties that are available for this match table.")

    # dynamic_match_key_masks = jsl.BooleanField(description="A Boolean indicating if dynamic match key masks are available for this table.  This is only application for exact match tables.")

    static_entries = jsl.ArrayField(items=jsl.DictField(properties={
        "match_key": jsl.ArrayField(items=jsl.DictField(properties={
            "name": jsl.StringField(required=True, description="The name of the field."),
            "match_type": jsl.StringField(required=True, enum=["exact", "lpm", "ternary"], description="The match type to use for the field."),
            "value": jsl.IntField(required=True, description="An integer indicating the value to program for this field."),
            "mask": jsl.IntField(description="An integer indicating the mask value to program for this field.  This is required if the match type is ternary.")
        }), required=True, description="An array of match key field properties for this entry."),
        "priority": jsl.IntField(description="An integer indicating the entry priority.  Not currently used."),
        "default_entry": jsl.BooleanField(required=True, description="A Boolean indicating if this is the default table entry."),
        "action_entry": jsl.DictField(properties={
            "name": jsl.StringField(required=True, description="The name of the action to run."),
            "action_id": jsl.IntField(required=True, description="The unique handle for the action to run."),
            "action_data": jsl.ArrayField(items=jsl.DictField(properties={
                "name": jsl.StringField(required=True, description="The name of the action parameter."),
                "value": jsl.IntField(required=True, description="An integer indicating the value to program for this parameter.")
            }), required=True, description="An array of the action data parameter properties.")
        }, required=True, description="An array of action properties for this entry.")
    }, description="An array of the static entries to be programmed by the driver."))

    default_action_handle = jsl.IntField(description="The handle to the P4-specified default action for a table.  This is the action run when the match table misses.  If no default action is specified, no action is taken.")

    action_profile = jsl.StringField(description="Name of the action profile currently in use. This information is used for PD generation.")
    ap_bind_indirect_res_to_match = jsl.ArrayField(jsl.StringField(), description="This value is deduced from the bind_indirect_res_to_match pragma. It is used by PD to indicate that an indirect resource is attached to the match table, and not to the action data as it usually is.")

    is_resource_controllable = jsl.BooleanField(description="A Boolean specifying whether this table is controllable by the driver. This information is used by the PD generation tool.")

    # Attributes specific to each type of MatchTable.
    match_attributes = jsl.OneOfField([
        jsl.DocumentField("ExactMatchTableAttr", as_ref=True),
        jsl.DocumentField("TernMatchTableAttr", as_ref=True),
        jsl.DocumentField("ATCAMMatchTableAttr", as_ref=True),
        jsl.DocumentField("ALPMMatchTableAttr", as_ref=True),
        jsl.DocumentField("CLPMMatchTableAttr", as_ref=True),
        jsl.DocumentField("MatchWithNoKeyTableAttr", as_ref=True),
        jsl.DocumentField("HashActionTableAttr", as_ref=True),
        jsl.DocumentField("Phase0MatchTableAttr", as_ref=True)
    ], required=True, description="The implementation type for this match table.")

class ActionDataTable(Table):
    title = "ActionDataTable"
    description = "ActionDataTable context information."

    # Require the table to be of this type. This attaches the attributes to the type.
    table_type = jsl.StringField(required=True, enum=['action'], description="Type of table.")
    how_referenced = jsl.StringField(required=True, enum=['direct', 'indirect'], description="Whether the table is directly or indirectly referenced.")

    actions = jsl.ArrayField(items=jsl.DictField(properties={
        "name": jsl.StringField(required=True, description="The P4 name of the action."),
        "handle": jsl.IntField(required=True, description="A unique identifier for this action."),
        "allowed_as_default_action": jsl.BooleanField(required=True, description="A Boolean indicating if this action can be used as a table default action (the table miss action)."),
        "disallowed_as_default_action_reason": jsl.StringField(description="If this action cannot be used as a default action, a short description indicating the reason it cannot."),
        "p4_parameters": jsl.ArrayField(items=jsl.DictField(properties={
            "name": jsl.StringField(required=True, description="The name of the parameter from P4."),
            "start_bit": jsl.IntField(required=True, description="The bit offset of this parameter in the action parameter list. This value refers to the most significant bit."),
            "bit_width": jsl.IntField(required=True, description="The bit width of the parameter."),
            "default_value": jsl.IntField(description="Default value of this parameter, in case this table is the default one.")
        }), required=True, description="An array of P4 parameter properties used by this action."),
        "indirect_resources": jsl.ArrayField(items=jsl.AnyOfField([
            jsl.DictField(properties={
                "access_mode": jsl.StringField(required=True, enum=['index'], description="The mode used to access the indirect resource. If this value is 'constant', then the indirect resource is accessed through a constant index that cannot be changed at runtime. If it is 'index', the index comes from action data."),
                "parameter_name": jsl.StringField(description="The action parameter name corresponding to how the resource is accessed. Only applicable if the access mode is 'index'."),
                "parameter_index": jsl.IntField(description="The index of the parameter in the action parameter list."),
                "resource_name": jsl.StringField(required=True, description="The name of the indirect resource consumed.")
            }),
            jsl.DictField(properties={
                "access_mode": jsl.StringField(required=True, enum=['constant'], description="The mode used to access the indirect resource. If this value is 'constant', then the indirect resource is accessed through a constant index that cannot be changed at runtime. If it is 'index', the index comes from action data."),
                "value": jsl.IntField(required=True, description="The constant value. Only applicable if the access mode is 'constant'."),
                "resource_name": jsl.StringField(required=True, description="The name of the indirect resource consumed.")
            }),
        ]), required=True, description="A list of the indirect resources consumed by this action."),
        "override_stat_addr_pfe": jsl.BooleanField(required=True, description="A Boolean indicating the driver should always write a 1 to the PFE bit in the statistics address in match overhead."),
        "override_meter_addr_pfe": jsl.BooleanField(required=True, description="A Boolean indicating the driver should always write a 1 to the PFE bit in the meter address in match overhead."),
        "override_stateful_addr_pfe": jsl.BooleanField(required=True, description="A Boolean indicating the driver should always write a 1 to the PFE bit in the stateful address in match overhead."),
        "override_stat_addr": jsl.BooleanField(required=True, description="A Boolean indicating the driver should always write the value indicated in override_stat_full_addr to the statistics address in match overhead."),
        "override_meter_addr": jsl.BooleanField(required=True, description="A Boolean indicating the driver should always write the value indicated in override_meter_full_addr to the meter address in match overhead."),
        "override_stateful_addr": jsl.BooleanField(required=True, description="A Boolean indicating the driver should always write the value indicated in override_stateful_full_addr to the stateful address in match overhead."),
        "override_stat_full_addr": jsl.IntField(required=True, description="The full hardware address of the statistics address to encode in the match overhead.  This is a 20-bit value."),
        "override_meter_full_addr": jsl.IntField(required=True, description="The full hardware address of the meter address to encode in the match overhead.  This is a 27-bit value."),
        "override_stateful_full_addr": jsl.IntField(required=True, description="The full hardware address of the stateful address to encode in the match overhead.  This is a 27-bit value.")
    }), required=True, description="An array of action properties that are available in this action data table.")

    # dynamic_match_key_masks = jsl.BooleanField(description="A Boolean indicating if dynamic match key masks are available for this table.  This is only application for exact match tables.")

    static_entries = jsl.ArrayField(items=jsl.DictField(properties={
        "match_key": jsl.ArrayField(items=jsl.DictField(properties={
            "name": jsl.StringField(required=True, description="The name of the field."),
            "match_type": jsl.StringField(required=True, enum=["exact", "lpm", "ternary"], description="The match type to use for the field."),
            "value": jsl.IntField(required=True, description="An integer indicating the value to program for this field."),
            "mask": jsl.IntField(description="An integer indicating the mask value to program for this field.  This is required if the match type is ternary.")
        }), required=True, description="An array of match key field properties for this entry."),
        "priority": jsl.IntField(description="An integer indicating the entry priority.  Not currently used."),
        "default_entry": jsl.BooleanField(required=True, description="A Boolean indicating if this is the default table entry."),
        "action_entry": jsl.DictField(properties={
            "name": jsl.StringField(required=True, description="The name of the action to run."),
            # FIXME: Better name
            "action_id": jsl.IntField(required=True, description="The unique handle for the action to run."),
            "action_data": jsl.ArrayField(items=jsl.DictField(properties={
                "name": jsl.StringField(required=True, description="The name of the action parameter."),
                "value": jsl.IntField(required=True, description="An integer indicating the value to program for this parameter.")
            }), required=True, description="An array of the action data parameter properties.")
        }, required=True, description="An array of action properties for this entry.")
    }, description="An array of the static entries to be programmed by the driver."))

    stage_tables = jsl.ArrayField(items=jsl.DocumentField("ActionDataStageTable", as_ref=True), required=True, description="An array of stage-specific resource objects for this action data table.")

class SelectionTable(Table):
    title = "SelectionTable"
    description = "SelectionTable context information."
    table_type = jsl.StringField(required=True, enum=['selection'], description="Type of table.")

    selection_type = jsl.StringField(required=True, enum=['resilient', 'fair'], description="Whether the selection is [resilient] or [fair].")
    bound_to_action_data_table_handle = jsl.IntField(description="An integer indicating the action data table handle this is bound to, if any. FIXME: Update description.")
    bound_to_stateful_table_handle = jsl.IntField(description="An integer indicating the stateful table handle this is bound to, if any.  A selection table is bound to a stateful table in cases where a packet generator packet is used to update the live port members.")
    how_referenced = jsl.StringField(required=True, enum=['direct', 'indirect'], description="Whether the table is directly or indirectly referenced.")

    max_port_pool_size = jsl.IntField(description="An integer indicating the maximum number of members available in any selection group.")
    # dynamic_selection_configuration = jsl.DictField(additional_items=True, description="FIXME: There will need to be a new class for this.")

    stage_tables = jsl.ArrayField(items=jsl.DocumentField("SelectionStageTable", as_ref=True), required=True, description="An array of stage-specific resource objects for this selection table.")

class StatisticsTable(Table):
    title = "StatisticsTable"
    description = "StatisticsTable context information."
    table_type = jsl.StringField(required=True, enum=['statistics'], description="Type of table.")

    statistics_type = jsl.StringField(required=True, enum=['packets', 'bytes', 'packets_and_bytes'], description="Type of statistics that are being gathered, [packets], [bytes] or [packets_and_bytes].")
    how_referenced = jsl.StringField(required=True, enum=['direct', 'indirect'], description="Whether the table is directly or indirectly referenced.")
    enable_pfe = jsl.BooleanField(required=True, description="A Boolean indicating whether the per-flow enable (PFE) bit needs to be included in the statistics address in the match table overhead.")
    pfe_bit_position = jsl.IntField(required=True, description="An integer indicating the bit position in the statistics address field in match overhead, from the least significant bit position, of the PFE bit.")
    packet_counter_resolution = jsl.IntField(required=True, description="FIXME")
    byte_counter_resolution = jsl.IntField(required=True, description="FIXME")

    stage_tables = jsl.ArrayField(items=jsl.DocumentField("StatisticsStageTable", as_ref=True), required=True, description="An array of stage-specific resource objects for this statistics table.")

class MeterTable(Table):
    title = "MeterTable"
    description = "MeterTable context information."
    table_type = jsl.StringField(required=True, enum=['meter'], description="Type of table.")

    meter_type = jsl.StringField(required=True, enum=['standard', 'lpf', 'red'], description="Type of meter in use.")
    meter_granularity = jsl.StringField(required=True, enum=['bytes', 'packets'], description="Granularity of meter in use.")
    how_referenced = jsl.StringField(required=True, enum=['direct', 'indirect'], description="Whether the table is directly or indirectly referenced.")
    enable_pfe = jsl.BooleanField(required=True, description="A Boolean indicating whether the per-flow enable (PFE) bit needs to be included in the meter address in the match table overhead.")
    pfe_bit_position = jsl.IntField(required=True, description="An integer indicating the bit position in the meter address field in match overhead, from the least significant bit position, of the PFE bit.")
    enable_color_aware_pfe = jsl.BooleanField(required=True, description="A Boolean indicating whether the meter address type needs to be included in the meter address in the match table overhead.  This arises if some match table actions use pre-color and some do not.")
    color_aware_pfe_address_type_bit_position = jsl.IntField(required=True, description="An integer indicating the bit position in the meter address field in match overhead, from the least significant bit position, of the start of the meter address type (3 bits).")
    pre_color_field_name = jsl.StringField(description="The name of a pre-color field object used by this meter, if any.")

    reference_dictionary = jsl.DictField(additional_items=True, required=True, description="Dictionary that maps match table names to how it references this meter table. FIXME: This could be removed from future context JSON implementations.")

    stage_tables = jsl.ArrayField(items=jsl.DocumentField("MeterStageTable", as_ref=True), required=True, description="An array of stage-specific resource objects for this meter table.")

class StatefulTable(Table):
    title = "StatefulTable"
    description = "StatefulTable context information."
    table_type = jsl.StringField(required=True, enum=['stateful'], description="Type of table.")

    how_referenced = jsl.StringField(required=True, enum=['direct', 'indirect'], description="Whether the table is directly or indirectly referenced.")

    # FIXME: These things are dependent on the width mode...
    dual_width_mode = jsl.BooleanField(required=True, description="A Boolean indicating if this stateful table operates in dual-width mode.")
    alu_width = jsl.IntField(required=True, enum=[1, 8, 16, 32], description="An integer indicating the stateful ALU data path width.  Normally, this corresponds to the memory entry width, but for dual-width mode, the memory entry width is twice this value. ")
    set_instr_adjust_total = jsl.IntField(enum=[0, 1, 2, 3], description="An integer indicating which stateful ALU instruction number contains a set bit adjust total instruction.  This is only applicable in single bit mode.  The driver uses this when creating the stateful ALU address.")
    set_instr = jsl.IntField(enum=[0, 1, 2, 3], description="An integer indicating which stateful ALU instruction number contains a set bit instruction.  This is only applicable in single bit mode.  The driver uses this when creating the stateful ALU address.")
    clr_instr_adjust_total = jsl.IntField(enum=[0, 1, 2, 3], description="An integer indicating which stateful ALU instruction number contains a clear bit adjust total instruction.  This is only applicable in single bit mode.  The driver uses this when creating the stateful ALU address.")
    clr_instr = jsl.IntField(enum=[0, 1, 2, 3], description="An integer indicating which stateful ALU instruction number contains a clear bit instruction.  This is only applicable in single bit mode.  The driver uses this when creating the stateful ALU address.")
    initial_value_lo = jsl.NumberField(required=True, description="An integer indicating the initial value to use for the stateful word.  If the stateful table is not in dual-width mode, this is the initial value for the entire stateful word.  If no initial value was specified, 0 will be used.")
    initial_value_hi = jsl.NumberField(description="An integer indicating the initial value to use for the most significant half of the stateful word.  This is only valid in double-width mode.  If no initial value was specified, 0 will be used.")
    bound_to_selection_table_handle = jsl.IntField(description="An integer indicating the selection table handle this is bound to, if any.  A stateful table is bound to a selector in cases where a packet generator packet is used to update the live port members.")

    action_to_stateful_instruction_slot = jsl.ArrayField(items=jsl.DictField(properties={
            "action_handle": jsl.IntField(required=True, description="Unique identifier for an action."),
            "instruction_slot": jsl.IntField(required=True, description="Stateful ALU instruction slot used by the action.")
        }, description="A dictionary that maps action handles to the stateful ALU instruction slot used by that action, if any.  This is used by the driver to help encode the stateful ALU address."),
        required=True,
        description="List of dictionaries containing action handles and their corresponding stateful ALU instruction, if any.")

    stage_tables = jsl.ArrayField(items=jsl.DocumentField("StatefulStageTable", as_ref=True), required=True, description="An array of stage-specific resource objects for this stateful table.")

#### PARSER ####

class Parser(jsl.Document):
    class PVS(jsl.Document):
        title = "PVS"
        description = "Parser value set context information."

        name = jsl.StringField(required=True, description="P4 parser state name.")
        state_id = jsl.IntField(required=True, description="Compiler-assigned parser state ID.  Allowed values are 0 to 255.")
        handle = jsl.IntField(required=True, description="Unique identifier for the parser value set.")

        tcam_row_list = jsl.ArrayField(jsl.IntField(), required=True, description="An array of parser TCAM rows that are used by this parse state.")
        tcam_key_map_array = jsl.ArrayField(jsl.DictField(properties={
            "tcam_container_hw_id": jsl.IntField(required=True, enum=[0, 2, 3], description="The hardware ID of a parser match extractor.  Allowed values correspond to the byte in the 32-bit match window.  ID 0 is the 16-bit match register.  ID 2 is the first 8-bit match register, and ID 3 is the second 8-bit match register."),
            "tcam_container_width": jsl.IntField(required=True, enum=[8, 16], description="The bit width of the match register.  ID 0 must have a value of 16.  IDs 2 and 3 must have a value of 8."),
            "tcam_container_bitmap": jsl.ArrayField(jsl.IntField(), required=True, description="A list of integers mapping bits in the match extraction to bits in the P4 program's match key. A null value means the bit is a don't-care in the P4 match")
        }, description="Parser match register properties."), required=True, description="An array of parser match registers in use by this parser value set.")

    title = "Parser"
    description = "Parser context information."

    ingress = jsl.ArrayField(jsl.DocumentField("PVS", as_ref=True), required=True, description="Parser value set information for Ingress.")
    egress = jsl.ArrayField(jsl.DocumentField("PVS", as_ref=True), required=True, description="Parser value set information for Egress.")

#### PHV ALLOCATION ####

class PHVStageAllocation(jsl.Document):
    class PHV(jsl.Document):
        title = "PHV"
        description = "PHV context information."

        phv_number = jsl.IntField(required=True, description="Unique address of this PHV container.")
        fields = jsl.ArrayField(jsl.DictField(
            properties={
                "is_pov": jsl.BooleanField(required=True, description="A Boolean indicating whether this field is a POV."),
                "field_name": jsl.StringField(required=True, description="Name of the field."),
                "field_lsb": jsl.IntField(required=True, description="Least significant bit of the field in this container."),
                "field_msb": jsl.IntField(required=True, description="Most significant bit of this field in this container.  This container will hold field[msb:lsb]."),
                "word_bit_width": jsl.IntField(required=True, description="PHV container bit width.", enum=[8, 16, 32]),
                "phv_lsb": jsl.IntField(required=True, description="Least significant bit of this PHV container that is occupied."),
                "phv_msb": jsl.IntField(required=True, description="Most significant bit of this PHV container that is occupied.  This allocation is phv[phv_msb:phv_lsb] = field[field_msb:field_lsb]."),
                "compiler_generated": jsl.BooleanField(required=True, description="Indicates whether this field was generated by the compiler.")
            }, description="Description of a field occupying this PHV."),
            required=True,
            description="List of fields occupying this PHV container.")

    title = "PHVStageAllocation"
    description = "PHVStageAllocation info."

    stage_number = jsl.IntField(required=True, description="Number of the stage attached to this PHV.")
    ingress = jsl.ArrayField(jsl.DocumentField("PHV", as_ref=True), required=True)
    egress = jsl.ArrayField(jsl.DocumentField("PHV", as_ref=True), required=True)

class LearnQuanta(jsl.Document):
    title = "LearnQuanta"
    description = "LearnQuanta context information."

    name = jsl.StringField(required=True, description="Name of the field list in the learn quanta.")
    handle = jsl.IntField(required=True, description="Unique identifier to this learn quanta.")
    lq_cfg_type = jsl.IntField(required=True, description="An int representing the unique hardware ID that has been given to this field list, if used for hardware learning (generate digest).")
    fields = jsl.ArrayField(jsl.DictField(properties={
        "field_name": jsl.StringField(required=True, description="Name of this field."),
        "field_width": jsl.IntField(required=True, description="Bit width of this field."),
        "start_bit": jsl.IntField(required=True, description="FIXME The start bit of the field from which the learner will take information from."),
        "start_byte": jsl.IntField(required=True, description="FIXME The start byte of the field from which the learner will take information from."),
    }, description="Dictionary containing the field name and its width."),
    required=True,
    description="List of fields in this learn quanta.")

class ContextJSONSchema(jsl.Document):
    title = "ContextJSONSchema"
    description = "ContextJSON for a P4 program compiled to the Tofino backend."
    program_name = jsl.StringField(required=True, description="Name of the compiled program.")
    build_date = jsl.StringField(required=True, description="Timestamp of when the program was built.")
    compiler_version = jsl.StringField(required=True, description="Compiler version used in compilation.")

    # Match, Selection, Statistics, ActionData, Meter, Stateful.
    tables = jsl.ArrayField(items=jsl.AnyOfField([
        jsl.DocumentField("MatchTable", as_ref=True),
        jsl.DocumentField("SelectionTable", as_ref=True),
        jsl.DocumentField("StatisticsTable", as_ref=True),
        jsl.DocumentField("ActionDataTable", as_ref=True),
        jsl.DocumentField("MeterTable", as_ref=True),
        jsl.DocumentField("StatefulTable", as_ref=True)
    ], description="Possible types of tables in this program."), required=True, description="List of tables and their specifications in this P4 program.")

    phv_allocation = jsl.ArrayField(items=jsl.DocumentField("PHVStageAllocation", as_ref=True), required=True, description="PHV allocation context for a given stage.")
    parser = jsl.DocumentField("Parser", as_ref=True, description="Parser context information.")
    learn_quanta = jsl.ArrayField(items=jsl.DocumentField("LearnQuanta", as_ref=True), required=True, description="LearnQuanta context information.")

#### DOCS GEN ####

def gen_docs(klass):
    """
    Very, very simple doc generation routine that trims out irrelevant things
    such as refs and some confusing JSON Schema notation to something a little
    bit simpler. Can be used with a JSON visualizer to have some nice documentation!
    """
    def should_skip(name):
        return (not name) or (name[0] == '_') or name == 'title' or name == 'description'

    def get_item_docs(item, docs):
        info = None

        if isinstance(item, jsl.ArrayField):
            info = handle_array(item, docs)
        elif isinstance(item, jsl.DictField):
            info = handle_dict(item, docs)
        elif isinstance(item, jsl.DocumentField):
            handle_doc(item.document_cls, docs)
            info = {
                "type": item.document_cls.title,
                "required": item.required
            }
        elif isinstance(item, jsl.StringField):
            info = {
                "type": "string",
                "description": item.description,
                "required": item.required
            }
        elif isinstance(item, jsl.IntField):
            info = {
                "type": "integer",
                "description": item.description,
                "required": item.required
            }
        elif isinstance(item, jsl.BooleanField):
            info = {
                "type": "boolean",
                "description": item.description,
                "required": item.required
            }
        elif isinstance(item, jsl.fields.compound.BaseOfField):
            info = {
                "type": "baseOf",
                "description": item.description,
                "options": [get_item_docs(field, docs) for field in item.fields],
                "required": item.required
            }
        if info and hasattr(item, "_enum") and item._enum:
            info["enum"] = item._enum
        return info

    def handle_array(array, docs):
        # currently not accepting lists as items.
        assert isinstance(array, jsl.ArrayField)
        assert not isinstance(array.items, list)

        info = {
            "type": "array",
            "description": array.description,
            "items": get_item_docs(array.items, docs),
            "required": array.required
        }
        return info

    def handle_dict(d, docs):
        assert isinstance(d, jsl.DictField)
        info = {
            "type": "object",
            "description": d.description,
            "properties": {},
            "required": d.required
        }
        props = info["properties"]
        if d.properties:
            for prop_name, prop in d.properties.items():
                assert prop_name not in props
                props[prop_name] = get_item_docs(prop, docs)
        return info

    def handle_doc(doc, docs):
        assert issubclass(doc, jsl.Document)
        title = doc.title
        if title in docs:
            return

        docs[title] = {
            "type": "object",
            "description": doc.description,
            "properties": {}
        }
        props = docs[title]["properties"]
        for prop_name, prop in inspect.getmembers(doc):
            if callable(prop) or should_skip(prop_name):
                continue
            assert prop_name not in props
            props[prop_name] = get_item_docs(prop, docs)

    docs = {}
    try:
        handle_doc(klass, docs)
    except:
        return None
    return docs

print json.dumps(ContextJSONSchema.get_schema())
