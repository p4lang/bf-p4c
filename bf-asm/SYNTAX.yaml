# yaml format tags for tofino assembler
#
# symbols used below:
#   <name>      ::= a string of 1 or more letters, digits, '_', '-', '.',
#                   '$', or '@' not starting with a digit.  Cannot start or
#                   end with '-' or '.' or have two consecutive '-' or '.'
#   <thread>    ::= "ingress" | "egress" | "ghost"
#                   ghost is only availble in jbay mau and phv sections
#   <register>  ::= <name> that matches a predefined register name
#   <slice>     ::= <name>(<lo>..<hi>) | <name>(<bit>)
#                   no spaces between parts of the <slice>
#   <constant>  ::= unsigned integer constant
#                   0x/0b/0o prefix for hex/binary/octal
#   <match-constant> ::= constant where one or more digits may be replaced
#                   by '*' to denote don't-care for ternary matches.
#   <range>     ::= <constant>..<constant>
#                   no spaces between parts of the <range>
#   <vector>    ::= <constant> | <range> | '[' <constant> | <range> , ... ']'
#                   can be a single constant or range or multiple constants
#                   or ranges in a yaml list
#   <phv-location> ::= <name> | <slice>
#                   Must be a register name or a name defined in the phv section
#   <bit-location> ::= <phv-location>
#                   Denotes a single bit
#   <matcher>    ::= half | byte0 | byte1
#            denotes one of the parser match units
#   <operands>   ::= <operand> { , <operand> }
#   <operand>    ::= <phv-location> | <field> | <constant>
#                  | hash_dist <unit> [ <lo>..<hi> ]
#                  | rng <unit> [ <lo>..<hi> ]
#
phv [<thread>]:
    # Defines PHV alias names for registers.  <thread> is 'ingress', 'ghost' or
    # 'egress' and is optional.  If present, aliases are defined only for
    # that thread.  If not present, aliases are for all threads
    <name>: <register> | <slice>
        # Makes <name> an alias for a register or piece of a register.
        # register B0 through B63 for byte registers, H0-H95 for half
        # (16-bit) registers, or W0-W63 for word (32-bit) registers.
        # May also use R0-R224 for all registers in W/B/H order.
        # TW0-TW31, TB0-TB21, TH0-TH47, R256-R367 for tagalong
    <name>:
        stage <lo>..<hi>: <register> | <slice>
        stage <int>: <register> | <slice>
            # makes name an alias that varies over stages.  In the first form, the map
            # applies just for those stages; in the second form it applies from that stage
            # up until the next stage specified by another stage key.  Stage numbers
            # apply to iPHV (input), so uses for VLIW destinations use the mapping for the
            # next stage.  Parser uses stage 0 and deparser uses the end-of-pipe stage
    context_json:
        <name>:
            # any keys/vector/values here are converted to json and output into
            # the context.json phv_allocation.records info for field <name>
            # verbatim
parser [<thread>] [<port_use>, ...]:
    # Defines a parser.  <thread> must be 'ingress' or 'egress'
    # <port_use> can have numerical values, such as range, int, vector of range and int.
    # <port_use> can also have symbolic values, such as "ALL", "CPU", "PCIE", "UNUSED"
    # "CPU" and "PCIE" are symbolic names that the corresponding numeric values are device-specific.
    # "UNUSED" represents the parser program that is not configured to any physical
    # parser during device initialization, but may be used by driver during runtime.
    start: <name>
    start: '[' <name>, ... ']'
        # define up to 4 distinct initial start states for the four channels
    priority: <int> | '[' <int>, ... ']'
    priority_threshold: <int> | '[' <int>, ... ']'
        # define initial parser priority and threshold for the 4 channels
    states:
        # Parser states can be defined with or without the 'states' key but this
        # is preferred as it avoids name collisions with other assembly
        # directives,
        <name> [<match-constant>]:
            # Defines a parser state.  The state 'start' is the implicit initial state
            # if there is no explicit initial state defined by a separate 'start' entry.
            # The state 'end' cannot exist (used for exit)
            # The optional constant is the 8-bit value used to denote the state;
            # overlapping state values will be flagged as an error
            match: <vector> | { <matcher> : <byte-loc> }
                # specifies up to 4 bytes to match against in the input buffer
                # may also specify 'ctr_zero' and 'ctr_neg' to match those
                # special bits, or the specific matchers 'byte0', 'byte1' or 'half'
                # to match against values explicitly loaded by a 'save' in a previous
                # state.  May additionally specify specific matchers to use.
            <match-constant>:
                # actions to perform when the match matches this match constant
                # this is a tcam priority match, so only the first match triggers
                buf_req: <constant>
                    # number bytes that must be in the input buffer to not stall
                counter: [set] <constant> | inc <constant> | dec <constant> | load <expression>
                    # modification of the counter
                checksum <int>:
                    # modification of checksum unit <int>
                    type: VERIFY | RESIDUAL | CLOT
                    mask: <vector> # vector of byte ranges of input buffer
                    swap: <vector>
                    dest: <phv-location> | clot <tag> # write destination
                    start: 0 | 1
                    end: 0 | 1
                next: <name> | <match-constant>
                    # next state -- match-constant takes don't care bits
                    # from current state
                offset: [set] <constant> | inc <constant>
                    # modificate to the offset
                priority: <constant> | @ <offset> [ >> <constant> ] [ & <constant> ]
                    # update the packet priority
                save: { <matcher> : <byte-loc>, ... } | <matcher>
                    # specifies one or more values from the input stream to be
                    # loaded into specific matchers or specific matchers to have
                    # their values preserved for use by later states
                shift: <constant>
                    # number of bytes to shift out
                [rotate] <constant> : [offset] <phv_location>
                [rotate] <range> : [offset] <phv_location>
                    # write the specifed byte (or range) to named phv slot
                [offset] <phv_location>: [rotate] <constant>
                    # write the specified constant to the phv location
                clot <tag>:
                    # output a CLOT (jbay only)
                    start: <constant>
                    length: <constant> | <expression>
                        # expression is generally '@' <const> [ '>>' <const> ] [ '&' <const> ]
                        # with variations (unary is highest precedence, followed by shift,
                        # mask(&), +/- lowest)
                    max_length: <constant>
            value_set <name> <size>:
                field_mapping:
                  <fieldname>(range) : <Matcher>(range)
                # actions to perform for a value set of the given <name> and integer <size>
            default:
                # actions to perform regardless of the match
            # if there is no 'default' tag in a state, anything that is not
            # recognized as a valid state tag is treated as part of an implicit
            # default
    counter_init:
        - { add: <int>, max: <int>, mask: <int>, src: <matcher>, rot: <int> }
        # intial values for the counter init ram
    hdr_len_adj: <constant>
        # value for the hdr_len_adj register
    init_zero: [ <phv_location>,... ]
        # list of phv slots that should be initialized to (valid) zero
    meta_opt: <constant>
        # value for the meta_opt register
    multi_write: [ <phv_location>,... ]
        # list of phv slots that the parser may write multiple times
        # values OR'd with previous values
    parser_error: <phv_location>
        # define a phv location to receive parser error codes
stage <constant> <thread>:
    # Defines a single stage of the MAU.  The order of the tables within the
    # stage is the logical table ordering, so order matters
    <table-type> <name> [<logical_id>]:
        # common keys available in (almost) all tables types
        row: <vector>
            # one or more ram rows the table uses
            # whether these are physical or logical rows depends on the table type
        column: <vector> | '[' <vector>, ... ']'
            # May be a single vector or a list of vectors.  If a list, length
            # must match the number of rows specified
            # Denotes the rams used on each row.  RAM type (sram, tcam or mapram)
            # depends on the table type
        bus: 0 | 1 | '[' 0 | 1, ... ']'
            # bus(es) to use.  If a list, must match the number of rows
        word: <vector>
            # for wide tables, specify which word of the wide word is in each row of the table
        vpns: <vector>
            # vpn values to use for rams
        input_xbar:
            # Input xbar config for this table
            group <constant>: <phv-location> | '[' <phv_location>, ... ']' |
                { <int>: <phv_location> | <int>..<int>: <phv_location>,... }
                # One or more registers to be mapped into the specified match group
                # in order or at the locations specified,
            hash <constant>:
                # hash table config
                <int>: <hash>
                    # specify one column of the table -- hash is a 64-bit constant
                <int> | <range>: <expression>
                    # specify one or more columns according to expression.  Phv refs
                    # must be in the corresponding input group of this input_xbar
                    <phv-location>
                        # identity copy of phv (must match width of range)
                    random(<phv-location>, ...)
                        # random hash of the given phv locations.  We generate
                        # with random(3) and we do NOT call srand, so the hash
                        # for a given program is repeatable.
                    crc(<int>, [<int>,] <phv-location>, ...)
                        # Deprecated.
                        # crc hash of the given phv locations -- first arg is integer
                        # constant denoting polynomial (Koopman notation).  Second arg
                        # is an initial constant prefixed to the input.
                    crc(<int>, [<int>,] '{' <int> : <phv-location>, ... '}' [, '{' <range> : <int> '}' ])
                        # crc hash of the given phv locations, at the specified offsets
                        # from the lsb of the crc input as a whole.
                        # arguments are polynomial (Koopman Notation)
                        # init shift register
                        # final xor
                        # total number of bits in the crc
                        # --
                        # hash calculation could have a list of constants as inputs.
                        # <range> : <int> represents the constant value in hash calculation,
                        # the key <range> encodes the offset and length of the constant
                        # the value <int> encodes the value of the constant
                    crc_rev(...)
                        # bit-reversed (little endian instead of the defaul big endian) crc
                    <expression> ^ <expression>
                        # xor of other expressions.
                    stripe(<expression>, ...)
                        # stripe other expressions across the width required,
                        # repeating as necessary
                valid <int>: <int>
                    # specifies the 16-bit valid hash for one column of the table
            hash group <constant>:
                # hash group config
                table: <vector>
                    # one or more hash tables to xor together for this group
                seed: <hash>
                    # 52-bit hash seed value
                <int>
                    # a single table to use for the group
            group <constant>: '[]'
            - group <constant>
                # use an xbar group configured elsewhere
            random_seed: <constant>
                # random seed from pragma for the table
        gateway:
            # gateway table on this table -- see below
        format: { <name>: <range>, <name>: <size> ... }
            # format of data in the table, mapping names to ranges of bits.
            # fields with sizes instead of explicit ranges will be laid out
            # by the assembler following preceeding fields
        hash_dist: { <unit>: <config>, ... }
            <int>: # hash distribution unit to config
                hash: <int>
                mask: <int>
                shift: <int>
                expand: <int>
                    # hash distribution config params
                output: <name> | '[' <name>,... ']'
                    # outputs to enable for this hast_dist unit
                    # 'lo' | 'hi' | 'meter' | 'stats' | 'action' | 'hashmod'
        action: <table-name>(<action> [, <index>])
            # Action table to use -- action is a named field from the format
            # that determines which action to do.  Index is optional (for
            # indirect action), named field from format.  If not present use
            # direct action (index is match address).
        action_enable: <int>
        enable_action_data_enable: true | false
        enable_action_instruction_enable: true | false
        default_action: <action>
        default_action_handle: <int>
            # Specifies a unique integer for action handle, used to match glass
            # If not present assembler generate handles
        default_action_parameters: { <name> : <int>, ... }
            # Specifies list of params and values
        action_bus: { <int> : <name> | <int>..<int> : <name>, ... }
            # immediate actions data
            # meter output data
        actions:
            # defines actions that can be used in the table
            <name> [<index>]:
                # the optional index is the index to use in the 8-entry
                # instruction indirection map of the table.
            [- <address>]   # constant imem address to use for this action
            [- <data alias map>]        # map of aliases for data operands
                <name> : <name> [ (<bit-range>) ]
                    # defines a name as an alias for (a slice of) something else
            [- p4_param_order: '{' param_name : <int>, ... '}' ]
                # Param order specifying param name and width for context json (p4_parameters)
            [- default_action: '{' allowed: true|false, reason: <string> '}' ]
               # the next table to be run when the entry hits with this action, could be
               # an index into the hit_next
            [- next_table: <int> | <name> ]
               # the next table to run when the entry misses with this action
            [- next_table_miss: <name> ]
            - <instruction> <operands>
        selector: <table-name>(<index-field> [ , <length-field> [ , <shift-field> ] ] )
            # selection table to use
        stats: <table-name> [ (<index-field>) ]
            # statistics table to use
        meter: <table-name> [ (<index-field>) ]
            # meter table to use
        stateful: <table-name> [ (<sful action> [, <index-field> ]) ]
        stateful: <table-name> [ (<sful action>, counter [ hit | miss | gateway ]) ]
            # stateful table to use
        idletime:
            # idletime table
            row: <vector>
            column: <vector> | '[' <vector>, ... ']'
            bus: <int>
            precision: 1 | 2 | 3 | 6
            sweep_interval: <int>
            notification: enable | disable | two_way
            per_flow_enable: true | false
        table_counter: disable | table_miss | table_hit | gateway_miss |
                   gateway_hit | gateway_inhibit
            # event type to count in per-table event counter
        hit: <table-name> | '[' <table-name>, ... ']'
            # next table on table hit.  If a list, 'format' must contain a
            # 'next' field that determines which next table to use
        miss: <table-name>
            # next table on table miss
        next: <table-name>
            # default (unconditional) next table.  Exclusive with hit/miss
        p4: # information about P4 level tables and control plane API
            name: <name>
                # P4 table name
            handle: <int>
                # runtime API handle for the table
            size: <int>
                # table size specified in P4 -- may be smaller than the actual
                # table size, as table is rounded up to fill memories
            match_type: exact | ternary | lpm | ...
            action_profile: <name>
            how_referenced: direct | indirect
        p4_param_order:
            # order of match params as seen in p4 program
            # PD generated has same order and needs to match context
            # json output
            <name>: { type: <table-type>, size: <int> } ...
                # param names with their types and size info
        context_json:
            # any keys/vector/values here are converted to json and output into
            # the context.json info for this table verbatim
          static_entries:
            # List of static entries as described in the p4 program. These are
            # passed on directly to the driver through context json. The
            # match_key_fields_values and action_parameters_values follow the
            # same order as the p4_param_order list in the table and action
            # sections. 
            # Match Key Fields Values based on match type:
            # Exact - field_name, value
            # Ternary - field_name, value, mask
            # Range - field_name, range_start, range_end
            # Lpm - field_name, value, prefix_length // TODO
            - priority: <int>
              match_key_fields_values: 
              - field_name: <name> 
                value: <int>
                mask: <hex> # Only for ternary match
                range_start: <int> # Only for range match
                range_end: <int> # Only for range match
                prefix_length: <int> # Only for lpm match // TODO
              action_handle: <int>
              is_default_entry: <bool>
              action_parameters_values: 
              - parameter_name: <string>
                value: <int>
    exact_match <name> [<logical_id>]:
        # Exact match table
        row: <vector>
        column: <vector> | '[' <vector>, ... ']'
            # physical rows and srams used by the table
        stash: # Stash Allocation for exact match tables only
          row: <vector> 
          col: <vector>
          # Row and col are indexed in sync to give RAM used to determine word
          # in entry
          unit: <vector>
          # Unit value can be (0,1) as there are 2 units per row and is indexed
          # in sync with row/col values to give stash unit
        input_xbar:
            # specifies exact match groups, hash tables, and groups (see above)
            # If there are multiple groups, the must match the total width of the
            # format, which must in turn match the rows and the ways.
        format: { <name>: <range>, <name>: <size> ... }
            # names may have `(<int>)` suffix denoting up to 5 match groups
            # all match groups must contain the same keys
            # some names have predefined meanings:
            match: ...  # exact match groups to match against
            action: ... # field that selects which action to run
            next: ...   # next table
        match: <phv-location> | '[' <phv-location>, ... ']'
            # value(s) to match against the 'match' field(s) in the format
        ways:
            - '[' <int>,<int>,<int>, '[' <row>,<col> ']',... ']'
            # description of one way of the table
            # initial 3 values are hash group, 10-bit slice from group, and
            # mask of upper 12 bits from the group.
            # FIXME -- needs to be done as a more descriptive map?
        match_group_map: '[' '[' <int>,... ']',... ']'
            # map from per-word match groups to overall match groups
            # one row for each word in the width of the table with up to
            # 5 values for up to 5 match groups in that word.  Values are
            # match groups in the format
        # common keys described above
        action:
        actions:
        action_bus:
        default_action:
        default_action_handle:
        default_action_parameters:
        context_json:
        gateway:
        hash_dist:
        hit:
        idletime:
        meter:
        miss:
        next:
        p4:
        selector:
        stateful:
        stats:
    ternary_match <name> [<logical_id>]:
        # Ternary match table
        row: <vector>
        column: <vector> | '[' <vector>, ... ']'
            # tcam rows and columns to use
        input_xbar:
            # specifies ternary match groups
            group <constant>: <phv-location> | '[' <phv_location>, ... ']'
                # odd groups are 5 bytes wide, even groups 6 -- the extra byte
                # is the byte group n/2
                # TBD -- Need a way to explicitly set byte swizzler?
        match:
            # Input xbar group(s) to match against -- may be a vector of maps for wide
            # matches using multiple groups
            group: <int>
                # Match group to match against (placed on tcam bus)
            byte_group: <int>
                # byte group to use for top 4 bits of tcam bus
            byte_config: <int>
                # value for tcams.vh_data_xbar.tcam_vh_xbar.tcam_row_halfbyte_mux_ctl
                #                             .tcam_row_halfbyte_mux_ctl_select
            dirtcam: <int>
                # dirtcam control bits for the group; used to set
                # tcams.col.tcam_mode.tcam_data_dirtcam_mode (bits 0..9)
                # and tcams.col.tcam_mode.tcam_vbit_dirtcam_mode (bits 10..11)
        indirect: <table-name>
            # ternary indirection table to use with this table
            # if there's an indirection table, it should contain all the table refs
        indirect_bus: <int>
            # which indirect bus to use for ternary tables with no indirection table
        # common keys described above
        action:
        actions:
        action_bus:
        default_action:
        default_action_handle:
        default_action_parameters:
        context_json:
        gateway:
        hash_dist:
        hit:
        idletime:
        meter:
        miss:
        next:
        p4:
        selector:
        stateful:
        stats:
    ternary_indirect <name>:
        # Ternary indirection table
        row: <vector>
        column: <vector> | '[' <vector>, ... ']'
            # physical rows and srams to use
        bus: 0 | 1 | '[' 0 | 1, ... ']'
            # ternary indirection bus to use.  List must match rows
        format: { <name>: <range-or-constant>, ... }
            # fields in the ram record, sized in bits
        # common keys described above
        action:
        actions:
        action_bus:
        default_action:
        default_action_handle:
        default_action_parameters:
        context_json:
        gateway:
        hash_dist:
        hit:
        idletime:
        meter:
        miss:
        next:
        p4:
        selector:
        stateful:
        stats:
    hash_action <name> [<logical_id>]:
        # hash-action table
        row: <int>
        bus: <int>
            # specify which physical row and exact match bus to use
        input_xbar:
            # input xbar config (as exact match table)
        # common keys described above
        action:
        actions:
        action_bus:
        default_action:
        default_action_handle:
        default_action_parameters:
        context_json:
        gateway:
        hash_dist:
        hit:
        idletime:
        meter:
        miss:
        next:
        p4:
        selector:
        stateful:
        stats:
    phase0_match <name>
        # special phase 0 match table before stage 0 (only in stage 0 ingress)
        p4: # information about P4 level tables and control plane API
        width: <int>
        # other common keys are NOT available in this table type
    proxy_hash <name> [<logical_id>]:
        # Proxy hash Table 
        row: <vector>
        column: <vector> | '[' <vector>, ... ']'
            # see exact_match 
        input_xbar:
            # see exact_match
        format: { <name>: <range>, <name>: <size> ... }
            # see exact_match
            match: ...  # exact match groups to match against
            action: ... # field that selects which action to run
            next: ...   # next table
        match: hash_group(<int>..<int>) | '[' hash_group(<int>..<int>), ... ']'
            # hash groups 
        ways:
            - '[' <int>,<int>,<int>, '[' <row>,<col> ']',... ']'
            # see exact_match
        proxy_hash_group:
            # hash group of the 8 possible hash groups to use
        proxy_hash_algorithm:
            # for the context JSON, proxy_hash_algorithm key
        # common keys described above
        action:
        actions:
        action_bus:
        default_action:
        default_action_handle:
        default_action_parameters:
        context_json:
        gateway:
        hash_dist:
        hit:
        idletime:
        meter:
        miss:
        next:
        p4:
        selector:
        stateful:
        stats:
    action <name>:
        # Action table
        logical_row: <vector>
        column: <vector> | '[' <vector>, ... ']'
            # srams to use -- in logical (16x6) coords, not physical (8x12)
        home_row: <vector> | '[' <vector>, ... ']'
            # row(s) to use as home rows for the table
        format [<action>]: { <name>: <range-or-constant>, ... }
            # fields in the ram record.  Different actions may have
            # different formats (and different sizes)...
        action_bus: { <int> : <name> | <int>..<int> : <name>, ... }
            # mapping from action bus bytes to values in the table.  Names
            # must be present in the 'format' for the table.
            # Can be optional -- if not present, assembler will attempt to
            # lay out fields in the action bus based on usage in actions.
        actions:
            # defines actions that can be used in the table
            <name> [<index>]:
                # the optional index is the index to use in the 8-entry
                # instruction indirection map of the table.
            [- <address>]   # constant imem address to use for this action
            [- <data alias map>]        # map of aliases for data operands
                <name> : <name> [ (<bit-range>) ]
                    # defines a name as an alias for (a slice of) something else
            [- p4_param_order: '{' param_name : <int>, ... '}' ]
                # Param order specifying param name and width for context json (p4_parameters)
            [- default_action: '{' allowed: true|false, reason: <string> '}' ]
            - <instruction> <operands>
        p4: # information about P4 level tables and control plane API
            # same as exact_match p4 info
        context_json: #anything
    gateway <name> [<logical_id>]:
        # 'bare' Gateway table -- no corresponding match table, so must
        # always specify next table
        name: <gateway-name>
            # Only output when gateway associated with a match table i.e. not
            # 'bare'
        row: <constant>
            # physical match row to use
        bus: 0 | 1
            # match bus to use
        payload_row: <constant>
        payload_bus: <constant>
            # row/bus to use for payload -- can only be specified on a
            # standalone gateway, as an attached gateway uses the row(s)
            # specified by the table it is attached to
        input_xbar:
            # as for exact_match, but can only specify one group
        match: <phv-location> | '[' <phv-location>, ... ']'
            # value(s) to match against the match constants
        xor: <phv-location> | '[' <phv-location>, ... ']'
            # value(s) to xor against the match value
        range: 2 | 4
            # do 2 or 4 bit range matches in the upper 12 bits of the gateway
        <match-constant>:
            # match row for gateway.  Value may be <table-name> (for next table)
            # or "run_table" or a map with either or both of these keys.
            next: <table-name>
                # next table for this match
            run_table: <true> | <false>
                # disable the gateway (run the logical match normally)
                # not applicable to bare gateways
        ? [ <int>, ..., <match-constant> ] :
            # Range match row for gateway.  Each value except the ladt is a
            # 2**n bit lookup table for a range match unit (so 4 bit values
            # for range:2 and 16 bit values for range:4).  The last value is
            # the normal tcam match for the bottm 32 bits of the gateway
            # Same value options as normal match rows.  Big-endian order
            # for units (last int is bottom 2 or 4 bits of upper 12 bits)
        miss:
            # behavior if no row matches (same options as match row above)
        condition:
            # condition output used for model logging
          expression : <string>
            # condition string as specified in p4
          true : <string>
            # next table name when condition is true
          false : <string>
            # next table name when condition is false
        payload: <constant>
            # payload data to use if gateway is not disabled (run_table is false)
        match_address: <constant>
            # gateway match address to use if the gateway is not disabled
        context_json: #anything
    selection <name> [<logical_id>]:
        logical_row: <vector>
        column: <vector> | '[' <vector>, ... ']'
            # srams to use -- in logical (16x6) coords, not physical (8x12)
        maprams: <vector> | '[' <vector>, ... ']'
            # map rams to use
        bus: <vector>
        input_xbar:
            # hash match groups on input xbar
        mode: resilient <int> | fair <int>
        non_linear: true | false
        per_flow_enable: true | false
        pool_sizes: <vector>
        selection_hash: <int>
        hash_dist: <hash_distribution>
            # see hash_action hash_dist
        p4: # information about P4 level tables and control plane API
            # same as exact_match p4 info
        context_json: #anything
    counter <name> [<logical_id>]:
        logical_row: <vector>
        column: <vector> | '[' <vector>, ... ']'
            # srams to use -- in logical (16x6) coords, not physical (8x12)
        maprams: <vector> | '[' <vector>, ... ']'
            # map rams to use
        vpns: <vector>
        format:
        count: bytes | packets | both | packets_and_bytes
        lrt: '{' <threshold>: <interval>, ... '}'
          - '{' threshold: <int>, interval: <int> '}' ...
          # largest recent with threshold params
        global_binding: true | false
        per_flow_enable: true | false
    meter <name> [<logical_id>]:
        logical_row: <vector>
        column: <vector> | '[' <vector>, ... ']'
            # srams to use -- in logical (16x6) coords, not physical (8x12)
        maprams: <vector> | '[' <vector>, ... ']'
            # map rams to use
        vpns: <vector>
        bus: <vector>
        input_xbar:
            # hash match groups on input xbar
        color_aware: true | false | per_flow
        color_maprams:
            row: <vector>
                # logical rows
            column: <vector> | '[' <vector>, ... ']'
            bus: <vector>
            vpns: <vector>
        hash_dist: <hash_distribution>
            # see hash_action hash_dist
        type: standard | lpf | red
        count: bytes | packets
        sweep_interval: <int>
        global_binding: true | false
        per_flow_enable: true | false
        context_json: #anything
    stateful <name> [<logical_id>]:
        logical_row: <vector>
        column: <vector> | '[' <vector>, ... ']'
            # srams to use -- in logical (16x6) coords, not physical (8x12)
        maprams: <vector> | '[' <vector>, ... ']'
            # map rams to use
        vpns: <vector>
        bus: <vector>
        hash_dist: <hash_distribution>
            # see hash_action hash_dist
        initial_value: { lo : <int> , hi : <int> }
            # Specify initial value for register, assumed 0 otherwise
        const_table: <vector> | '{' <index>: <value> '}'
        math_table:
          data: <vector> | '{' <index>: <value> '}'
          invert: true | false
          shift: <int>
          scale: <int>
        log_vpn: <int> | <range>
          # vpns to use in stateful logging mode
        pred_shift: <int>
        pred_comb_shift: <int>
          # set the salu_output_pred_shift and _comb_shift csr regs explicitly
          # FIXME -- should have a better way of doing this?
        actions:
            <action name> :
                - <instruction>
                    # SALU instructions to run for this table
        context_json: #anything
        # jbay additional features:
        sbus:
          # jbay only -- shared bus use
          learn: <table> | '[' <table>, ... ']'
          match: <table> | '[' <table>, ... ']'
          combine: "and" | "or"
        fifo: { push: <mode>, pop: <mode> }
        stack: { push: <mode>, pop: <mode> }
        bloom filter clear: <mode>
          # fifo or stack or bloom filter fast clear mode (mutually exclusive)
          # <mode> is hit | miss | gateway | active | control_plane
          # controls when the stack/fifo is pushed or popped
        watermark: push <level> | pop <level>
          # watermark interrupts sent every <level> pushes or pops
        offset_vpn: true | false
          # adjust immediate data by vpn offset to compute vpns for multistage
          # fifo/stack (jbay only)
        address_shift: <int>
          # shift up the incoming meter address before vpn/index/subword extract (jbay only)
        stage_alu_id: <int>
          # stage + alu id to be preprended to output addresses
    dependency: concurrent | action | match
        # set the interstage dependency between this stage and the
        # previous stage.  Ignored in stage 0
    error_mode: no_config | propagate | map_to_immediate | disable
    always_run_action:
        # action that runs automatcially in the stage independent of tables
        - <instruction> <operands>
deparser <thread>:
    # Defines a deparser.  <thread> must be 'ingress' or 'egress'
    dictionary:
        # ordered list of phv locations to write out as the output deparser
        - <phv-location> : <bit-location>
            # single value to write iff the referred bit is set
        - checksum <int> : <bit-location>
            # checksum result to write iff the referred bit is set
        - <constant> : <bit-location>
            # constant to write iff the referred bit is set (jbay only)
        - clot <tag>:
            # clot to output (jbay only)
            pov: <bit-location>
            length: <int>
                # maximum length of the clot
            <int>: <phv_location> | checksum <int>
                # offset in clot to replace with a PHV or checksum value
    pov: <phv-location> | '[' <phv-location>, ... ']'
        # optional explicit use/ordering of phvs for POV.  All phvs used for POV bits
        # in the dictionary will be added to the end of this, if not already present
    checksum <int>:
        <phv-location> | clot <tag> : { swap: <constant> [, pov: <phv-location> ] }
        # checksum unit programming -- pov bits for jbay only
    <name>: <phv-location> [ ':' <pov-bit ] | <digest-params>
        # more generally, any deparser param that comes from the phv is
        # specified this way.  Only jbay has pov bits here
        # <digest-params> are as follows
        select: <phv-location> [ ':' <pov-bit> ]
            # controls which digest group is output
        shift: <constant>
        <int>: <phv-location> | '[' <phv-location>, ... ']'
                # values for a single digest group; specifies the sequence of
                # phv containers in the appropriate table entry. this is usually
                # data that is included in the digest, but it may also contain
                # control metadata; for example, when configuring mirroring on
                # Tofino, the first phv container specifies the mirror session id.
        context_json: # anything
    # ingress or egress params:
    mirror: <digest-params>
    egress_unicast_port: <phv-location> [ ':' <pov-bit> ]
        # specifies the port to write to
    drop_ctl: <phv-location> [ ':' <pov-bit> ]
    # jbay only, ingress or egress
    afc: '{' <phv->location> ':' <pov-bit> '}'
    mirr_egress_port: '{' <phv->location> ':' <pov-bit> '}'
    mirr_c2c_ctrl: '{' <phv->location> ':' <pov-bit> '}'
    mirr_coal_smpl_len: '{' <phv->location> ':' <pov-bit> '}'
    mirr_dond_ctrl: '{' <phv->location> ':' <pov-bit> '}'
    mirr_hash: '{' <phv->location> ':' <pov-bit> '}'
    mirr_icos: '{' <phv->location> ':' <pov-bit> '}'
    mirr_io_sel: '{' <phv->location> ':' <pov-bit> '}'
    mirr_mc_ctrl: '{' <phv->location> ':' <pov-bit> '}'
    mirr_qid: '{' <phv->location> ':' <pov-bit> '}'
    mtu_trunc_err_f: '{' <phv->location> ':' <pov-bit> '}'
    mtu_trunc_len: '{' <phv->location> ':' <pov-bit> '}'
    # ingress only deparser params:
    learning: <digest-params> [ ':' <pov-bit> ]
    resubmit: <digest-params> [ ':' <pov-bit> ]
    copy_to_cpu: <phv-location> [ ':' <pov-bit> ]
    egress_multicast_group_<int>: <phv-location> [ ':' <pov-bit> ]
    hash_lag_ecmp_mcast_<int>: <phv-location> [ ':' <pov-bit> ]
    copy_to_cpu_cos: <phv-location> [ ':' <pov-bit> ]
    ingress_port_source: <phv-location> [ ':' <pov-bit> ]
    deflect_on_drop: <phv-location> [ ':' <pov-bit> ]
    meter_color: <phv-location> [ ':' <pov-bit> ]
    icos: <phv-location> [ ':' <pov-bit> ]
    qid: <phv-location> [ ':' <pov-bit> ]
    xid: <phv-location> [ ':' <pov-bit> ] 
    yid: <phv-location> [ ':' <pov-bit> ]
    rid: <phv-location> [ ':' <pov-bit> ]
    warp: <phv-location> [ ':' <pov-bit> ]
    ct_disable: <phv-location> [ ':' <pov-bit> ]
    ct_mcast: <phv-location> [ ':' <pov-bit> ]
    # jbay ingress only
    bypass_egr: '{' <phv->location> ':' <pov-bit> '}'
    # egress only deparser params: [ ':' <pov-bit> ]
    force_tx_err: <phv-location> [ ':' <pov-bit> ]
    tx_pkt_has_offsets: <phv-location> [ ':' <pov-bit> ]
    capture_tx_ts: <phv-location> [ ':' <pov-bit> ]
    coal: <phv-location> [ ':' <pov-bit> ]
    ecos: <phv-location> [ ':' <pov-bit> ]
primitives: <filename>
    # Defines the name of the json file that has information on primitives used
    # within table actions. These are placed in the respective actions as
    # primitives node. This node is mainly used by model for logging
    # instructions as specified in original p4 program
dynhash: <filename>
    # Defines the name of the json file that has the dynamic hash calculation
    # node. This node is directly merged into the context json at the top level
# version 1.0.0
version: <number>
    # semantic versioning number
# version 1.0.1
version:
    version: <number>
       # semantic versioning number
    run_id: <sha>
       # defines an id that ties together all the files produced by the compiler
       # part of the Version section
