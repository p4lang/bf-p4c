#!/usr/bin/env python

""" Run bfas with manifest.json """

import argparse
import json
import os
import subprocess
import sys
# add path to p4c_src
sys.path.append(os.path.dirname(os.environ['P4C_CFG_PATH']))
from p4c_src.util import find_file

# Search the environment for assets
if os.environ['P4C_BUILD_TYPE'] == "DEVELOPER":
    bfas = find_file('bf-asm', 'bfas')
else:
    bfas = find_file(os.environ['P4C_BIN_DIR'], 'bfas')

parser = argparse.ArgumentParser()
parser.add_argument('--manifest', '-m', metavar='manifest', type=str,
                    help='a manifest.json file generated by p4c')

known_args, unparsed_args = parser.parse_known_args()

def parse_manifest(manifest_filename):
    with open(manifest_filename, "rb") as json_file:
        try:
            manifest_json=json.load(json_file)
        except:
            sys.stderr.write("ERROR: Input file '"+manifest_filename+"' could not be decoded as JSON.\n")
            sys.exit(1)
        if (type(manifest_json) is not dict or
            "programs" not in manifest_json):
            sys.stderr.write("ERROR: Input file '"+manifest_filename+"' does not appear to be valid manifest JSON.\n")
            sys.exit(1)
    return manifest_json['programs']

def strip_right(text, suffix):
    if not text.endswith(suffix):
        return text
    return text[:len(text)-len(suffix)]

def run_assembler(known_args):
    manifest_filename = known_args.manifest
    programs = parse_manifest(manifest_filename)
    unique_table_offset = 0
    for prog in programs:
        if (type(prog) is not dict or
            "contexts" not in prog):
            sys.stderr.write("ERROR: Input file '"+manifest_filename+"' does not contain valid program contexts.\n")
            sys.exit(1)
        contexts=prog["contexts"]
        program_name = prog['program_name']
        p4_version=prog["p4_version"]
        for ctxt in contexts:
            if (p4_version == "p4-16"):
                pipe_name = ctxt['pipe']
            cmd = [bfas]
            # remove either .p4 or .p4i suffix
            p4_filename = strip_right(program_name, ".p4")
            p4_filename = strip_right(p4_filename, ".p4i")
            dirname = os.path.dirname(os.path.realpath(manifest_filename))
            dirname_prefix = os.path.join(os.path.dirname(manifest_filename), '')
            if (p4_version == "p4-16"):
                dirname = os.path.join(dirname, pipe_name)
            # forward unparsed arguments to bfas, rewriting paths that refer to the output
            # directory to instead refer to the pipe output directory
            for a in unparsed_args:
                if (len(dirname_prefix) > 1 and a[:len(dirname_prefix)] == dirname_prefix):
                    a = os.path.join(dirname, a[len(dirname_prefix):])
                cmd.append(a)
            # prepend unique offset to table handle
            cmd.append("--table-handle-offset{0}".format(unique_table_offset))
            # output dir
            cmd.append("-o")
            cmd.append(dirname)
            # input file
            bfa_filename = p4_filename + ".bfa"
            cmd.append(os.path.join(dirname, bfa_filename))
            unique_table_offset = unique_table_offset + 1
            #print cmd
            subprocess.check_call(cmd)

def main():
    try:
        run_assembler(known_args)
    except:
        sys.stderr.write("ERROR: configuration generation failed.")
        sys.exit(1) 
    sys.exit(0) 

if __name__ == "__main__":
    # add the parent directory
    curdir=os.path.dirname(os.path.realpath(__file__))
    sys.path.append(os.path.dirname(curdir))
    main()
