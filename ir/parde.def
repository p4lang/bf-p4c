namespace Tofino {

class ParserMatch {
    match_t                     value;
    int                         shift;
    inline Vector<Expression>   stmts;
    NullOK ParserState          next;
    NullOK ParserException      except;
#noconstructor
    ParserMatch(match_t v, const Vector<Expression> &e)
    : value(v), shift(-1), stmts(e), next(0), except(0) {}
#emit
    ParserMatch(match_t v, int sh, const std::initializer_list<const Expression *> &st,
                const ParserState *n, const ParserException *ex = nullptr)
    : value(v), shift(sh), stmts(st), next(n), except(ex) {}
#end
}

class ParserState : Unit {
    cstring                     name;
    inline Vector<Expression>   select;
    inline Vector<ParserMatch>  match;
#noconstructor
    NullOK Node p4state = 0; /* informational only! not visited or compared for equal */
    ParserState(Node n);
    ParserState(cstring n, const std::initializer_list<Expression> &sel,
                const std::initializer_list<ParserMatch> &m)
    : name(n), select(sel), match(m) {}
    int stage() const override { return -1; }
    toString { return name; }
    visit_children {
        select.visit_children(v);
        match.parallel_visit_children(v); }
}

class Parser {
    gress_t     gress;
    ParserState start;
#noconstructor
    Parser(gress_t gr, ParserState s) : gress(gr), start(s) {}
#apply
    toString { return gress ? "egress parser" : "ingress parser"; }
}

class Deparser : Unit {
    gress_t                     gress;
    inline Vector<Expression>   emits;
    NullOK Expression           egress_port;
#noconstructor
    Deparser(gress_t gr, Parser s);
    int stage() const override { return 999999; /* assumed larger than the number of stages */ }
#apply
    toString { return gress ? "egress deparser" : "ingress deparser"; }
}

}  // end namespace Tofino
