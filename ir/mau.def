/* -*-c++-*- */

#emit
struct TableResourceAlloc;
#end
#emit_impl
#include "tofino/mau/resource.h"
#end

#emit_impl
#include "extensions/tofino/mau/resource.h"
#end

namespace MAU {

/* A Tofino logical table (group) -- a gateway and/or match table
 * along with whatever attached tables are run.  The basic scheduling
 * unit for tofino; there are 16 such 'logical' tables available in
 * each stage, which will run simultaneously and have their results
 * predicated by the predicate mask calculated from the next tables */
class Table : Tofino::Unit {
    cstring                                     name;
    gress_t                                     gress;
    int                                         logical_id = -1;
    vector<std::pair<Expression, cstring>>      gateway_rows;
    /* each gateway_row is a an expression for a single row of the gateway,
     * with the string being a tag to run in 'next' for next table, or null
     * if the match_table should run.  The last row (only) may have a NULL
     * expression for 'always' -- corresponding to the gateway miss action
     * (taken if no gateway rows match).  If this last row NULL expression
     * is not present, the default action is to run the table. */
    NullOK ActionFunction                       gateway_payload;
    NullOK IR::V1Table                          match_table;
    inline Vector<Attached>                     attached;
    inline NameMap<ActionFunction, ordered_map> actions;
    inline NameMap<TableSeq>                    next;

    class Layout {
        /* POD type */
        int             entries = 0;
        bool            gateway = false;
        bool            ternary = false;
        int             ixbar_bytes = 0;
        int             match_bytes = 0;
        int             match_width_bits = 0;
        int             action_data_bytes = 0;
        int             action_data_bytes_in_overhead = 0;
        int             overhead_bits = 0;
        Layout() { memset(this, 0, sizeof(*this)); }
        operator== { return memcmp(this, &a, sizeof(Layout)) == 0; }
        toJSON {
            json << json.indent << "\"entries\" : " << entries << ",\n"
                 << json.indent << "\"gateway\" : " << gateway << ",\n"
                 << json.indent << "\"ternary\" : " << ternary << ",\n"
                 << json.indent << "\"ixbar_bytes\" : " << ixbar_bytes << ",\n"
                 << json.indent << "\"match_width_bits\" : " << match_width_bits << ",\n"
                 << json.indent << "\"action_data_bytes\" : " << action_data_bytes << ",\n"
                 << json.indent << "\"action_data_bytes_in_overhead\" : "
                                << action_data_bytes_in_overhead << ",\n"
                 << json.indent << "\"overhead_bits\" : " << overhead_bits; }
#emit
        Layout &operator+=(const Layout &a);
#end
    }
#emit
    Layout layout;  // need operator<< to remove #emit here.
#end
    class Way {
        /* POD type */
        int             match_groups = 0;
        int             entries = 0;
        int             width = 0;
        Way() { memset(this, 0, sizeof(*this)); }
        operator== { return memcmp(this, &a, sizeof(Way)) == 0; }
        toJSON {
            json << json.indent << "\"match_groups\" : " << match_groups << ",\n"
                 << json.indent << "\"entries\" : " << entries << ",\n"
                 << json.indent << "\"width\" : " << width; }
        static IR::MAU::Table::Way* fromJSON(JSONLoader& json) {
            Way* way = new Way();
            json.load("match_groups", way->match_groups);
            json.load("entries", way->entries);
            json.load("width", way->width);
            return way;
        }
    }
    vector<Way>    ways;
    const TableResourceAlloc            *resources = nullptr;

#noconstructor
    Table(cstring n, gress_t gr, IR::V1Table t)
    : Tofino::Unit(t->srcInfo), name(n), gress(gr), match_table(t) {}
#emit
    Table(cstring n, gress_t gr, const Expression *gw)
    : Tofino::Unit(gw->srcInfo), name(n), gress(gr),
      gateway_rows{ std::make_pair(gw, "$true"), std::make_pair(nullptr, "$false") } {}
    // ir-generator can't parse {}-initializer (thinks it is the ctor body
#end

    int logical_order() const { return logical_id + gress * 4096; }
    Table *clone_rename(const char *ext) const {
        Table *rv = clone();
        rv->name += ext;
        for (auto &at : rv->attached) at = at->clone_rename(ext);
        return rv; }
#nooperator==
#emit
    bool operator==(const Table &a) const override;
#end
    bool uses_gateway() const { return !gateway_rows.empty(); }
    int stage() const override {
        return logical_id < 0 ? -1 : logical_id / StageUse::MAX_LOGICAL_IDS; }
    gress_t thread() const override { return gress; }
    validate {
        std::set<cstring> gw_next;
        for (auto &gw : gateway_rows) {
            if (&gw != &gateway_rows.back())
                CHECK_NULL(gw.first);
            else if (gw.first)
                gw_next.emplace(cstring());
            gw_next.emplace(gw.second); }
        if (!match_table && !uses_gateway())
            BUG("table with no gateway or match table");
        if (!match_table && gw_next.count(cstring()))
            BUG("gateway with no match table wants to run match table");
        if (match_table && uses_gateway() && !gw_next.count(cstring()))
            BUG("gateway always overrides match table");
        for (auto &nxt : next) {
            if (nxt.first == "$default") {
            } else if (nxt.first == "$hit" || nxt.first == "$miss") {
                if (!match_table)
                    BUG("%s next on table with no match_table", nxt.first);
            } else if (!gw_next.count(nxt.first) && !actions.count(nxt.first)) {
                BUG("%s next on table with no such action or gw result", nxt.first); } } }
    visit_children {
        for (auto &gw : gateway_rows)
            v.visit(gw.first, "gateway_row");
        auto &gateway_inhibit(v.flow_clone());
        gateway_inhibit.visit(gateway_payload, "gateway_payload");
        v.visit(match_table, "match_table");
        auto &clone(v.flow_clone());
        if (match_table) {
            auto &default_action(clone.flow_clone());
            bool need_default_action = false;
            for (auto &action : Values(actions)) {
                auto &clone2(clone.flow_clone());
                clone2.visit(action);
                if (next.count(action->name)) {
                    clone2.visit(next.at(action->name), action->name.name);
                    v.flow_merge(clone2);
                } else {
                    default_action.flow_merge(clone2);
                    need_default_action = true; } }
            if (next.count("$default")) {
                default_action.visit(next.at("$default"), "$default");
                need_default_action = true; }
            else if (next.count("$hit")) {
                default_action.visit(next.at("$hit"), "$hit");
                need_default_action = true; }
            if (need_default_action)
                v.flow_merge(default_action);
            if (next.count("$miss")) {
                auto &clone2(clone.flow_clone());
                clone2.visit(next.at("$miss"), "$miss");
                v.flow_merge(clone2); } }
        std::set<cstring> gw_next;
        for (auto &gw : gateway_rows) {
            if (gw.second && next.count(gw.second) && !gw_next.count(gw.second)) {
                auto &clone2(gateway_inhibit.flow_clone());
                clone2.visit(next.at(gw.second), gw.second);
                v.flow_merge(clone2);
                gw_next.emplace(gw.second); } }
        attached.visit_children(v);
    }
}

class TernaryIndirect : Attached {
#noconstructor
#nodbprint
    TernaryIndirect(cstring tbl_name) { name = IR::ID(tbl_name + "$tind"); }
    const char *kind() const override { return "indirect"; }
}

class ActionData : Attached {
    bool        direct = true;
#noconstructor
#nodbprint
    ActionData(cstring tbl_name) { name = IR::ID(tbl_name + "$action"); }
    const char *kind() const override { return "action"; }
    bool indexed() const override { return !direct; }
}

// a sequence of tables -- may be reordered if deps allow.
// deps(i,j) is true iff tables[i] is dependent on tables[j]
// (so must have j < i) */
class TableSeq {
    inline Vector<Table>        tables;
    LTBitMatrix                 deps;
#noconstructor
    TableSeq() = default;
    TableSeq(Table a) { if (a) tables.push_back(a); }
    TableSeq(Table a, Table b) {
        if (a) tables.push_back(a);
        if (b) tables.push_back(b); }
    TableSeq(TableSeq a, Table b) {
        if (a) tables.insert(tables.end(), a->tables.begin(), a->tables.end());
        if (b) tables.push_back(b); }
    bool empty() const { return tables.empty(); }
    Table front() const { return tables.empty() ? nullptr : tables.front(); }
#apply
}

// A single MAU instruction.  For the most part instructions look exactly like Primitives,
// just with more constraints applied.  For example, an "add" instruction has the same
// destination and two sources as an "add" primitive, with the additional constraints that
// the dest and first source are PHV while second source can be PHV, action bus, or constant.
// We convert the primitive into an instruction when we check those constraints
// TODO(cdodd) -- stateful ALU has its own disctinct instruction set -- should use a different
// class for those or reuse this?
class Instruction : Primitive {
#nodbprint
#emit
    using Primitive::Primitive;
#end
    Instruction(const Primitive &p) : Primitive(p) {}
    bool isOutput(int operand_index) const override { return operand_index == 0; }
}

}  // end namespace MAU
