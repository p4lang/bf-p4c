#emit
enum gress_t { INGRESS, EGRESS };
struct StageUse {
    static constexpr int MAX_STAGES = 12;
    static constexpr int MAX_LOGICAL_IDS = 16;
    static constexpr int MAX_SRAMS = 80;
    static constexpr int MAX_TCAMS = 24;
    static constexpr int MAX_MAPRAMS = 48;
    static constexpr int MAX_IXBAR_BYTES = 128;
    static constexpr int MAX_TERNARY_GROUPS = 12;
};
inline std::ostream &operator<<(std::ostream &out, gress_t gress) {
    return out << (gress ? "egress" : "ingress"); }
#end

#emit_impl
#include "tofino/ir/thread_visitor.h"
#end

class Tofino::Pipe {
    Metadata    standard_metadata; // not visited
#noconstructor
#emit
    struct thread_t {
        const Tofino::Parser    *parser;
        const MAU::TableSeq     *mau;
        const Tofino::Deparser  *deparser;
        bool operator==(const thread_t &a) const {
            return parser == a.parser && mau == a.mau && deparser == a.deparser; }
    } thread[2] = { { nullptr, nullptr, nullptr } };  // INGRESS and EGRESS
#end
#apply
    operator== { return standard_metadata == a.standard_metadata &&
                        thread[0] == a.thread[0] && thread[1] == a.thread[1]; }
    visit_children {
        if (auto *th = dynamic_cast<ThreadVisitor *>(&v)) {
            v.visit(thread[th->thread].parser, "parser");
            v.visit(thread[th->thread].mau, "mau");
            v.visit(thread[th->thread].deparser, "deparser");
        } else {
            for (auto &th : thread) {
                v.visit(th.parser, "parser");
                v.visit(th.mau, "mau");
                v.visit(th.deparser, "deparser"); } } }
}

class InstanceRef : HeaderRef {
    HeaderOrMetadata            obj;
    inline NameMap<InstanceRef> nested;
#noconstructor
#emit
    InstanceRef(ID n, const Type *t);
#end
    toString { return obj->name; }
    dbprint { out << obj; }
}

class HeaderSliceRef : Slice {
#nodbprint
#noconstructor
#emit
  HeaderSliceRef(Util::SourceInfo si, const IR::HeaderRef* header_ref,
                 const int &msb, const int &lsb) :
    Slice(si, header_ref, new IR::Constant(msb), new IR::Constant(lsb)) {
    assert(lsb <= msb);
    type = Type_Bits::get(si, msb - lsb + 1); }
  HeaderSliceRef(const Member *fr) :
    Slice(fr->srcInfo, fr->expr, new Constant(fr->msb()), new Constant(fr->lsb())) {
    assert(fr->lsb() <= fr->msb());
    type = Type_Bits::get(fr->srcInfo, fr->msb() - fr->lsb() + 1); }
  const HeaderRef* header_ref() const {
    return e0->to<const HeaderRef>(); }
  vector<const Member*> fields() const {
    vector<const Member*> rv;
    for (auto field : *header_ref()->type->to<IR::Type_StructLike>()->fields) {
      const IR::Member fr(srcInfo, field->type, header_ref(), field->name);
      if (fr.lsb() >= lsb() && fr.msb() <= msb())
        rv.push_back(new Member(fr));
    }
    return rv; }
  int offset_bits() const { return e2->to<const Constant>()->asInt(); }
  int lsb() const { return offset_bits(); }
  int msb() const { return offset_bits() + type->width_bits() - 1; }
#end
}
