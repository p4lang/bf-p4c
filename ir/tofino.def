#emit
enum gress_t { INGRESS, EGRESS };
struct StageUse {
    static constexpr int MAX_STAGES = 12;
    static constexpr int MAX_LOGICAL_IDS = 16;
    static constexpr int MAX_SRAMS = 80;
    static constexpr int MAX_TCAMS = 24;
    static constexpr int MAX_MAPRAMS = 48;
    static constexpr int MAX_IXBAR_BYTES = 128;
    static constexpr int MAX_TERNARY_GROUPS = 12;
};
inline std::ostream &operator<<(std::ostream &out, gress_t gress) {
    return out << (gress ? "egress" : "ingress"); }
inline bool operator>>(cstring s, gress_t &gress) {
    if (s == "ingress") gress = INGRESS;
    else if (s == "egress") gress = EGRESS;
    else return false;
    return true;
}
#end

#emit_impl
#include "tofino/ir/thread_visitor.h"
#end

class Tofino::Pipe {
    Metadata    standard_metadata; // not visited
#noconstructor
    Pipe() = default;
    class thread_t {
        Tofino::Parser    parser = nullptr;
        MAU::TableSeq     mau = nullptr;
        Tofino::Deparser  deparser = nullptr;
        operator== { return parser == a.parser && mau == a.mau && deparser == a.deparser; }
        toJSON {
            json << json.indent << "\"parser\" : " << parser << "," << std::endl
                 << json.indent << "\"mau\" : " << mau << "," << std::endl
                 << json.indent << "\"deparser\" : " << deparser; }
        fromJSON {
            IR::Tofino::Pipe::thread_t * thread = new IR::Tofino::Pipe::thread_t();
            json.load("parser", thread->parser);
            json.load("mau", thread->mau);
            json.load("deparser", thread->deparser);
            return thread;
        }
    }
    thread_t[2] thread = {};  // INGRESS and EGRESS
#apply
    operator== { return standard_metadata == a.standard_metadata &&
                        thread[0] == a.thread[0] && thread[1] == a.thread[1]; }
    visit_children {
        if (auto *th = dynamic_cast<ThreadVisitor *>(&v)) {
            v.visit(thread[th->thread].parser, "parser");
            v.visit(thread[th->thread].mau, "mau");
            v.visit(thread[th->thread].deparser, "deparser");
        } else {
            for (auto &th : thread) {
                v.visit(th.parser, "parser");
                v.visit(th.mau, "mau");
                v.visit(th.deparser, "deparser"); } } }
}

abstract Tofino::Unit {
    /* Abstract base class for any of
       - parser state
       - mau logical table
       - deparser
       A packet running through a tofino pipe executes a sequence of Units in order;
       each Unit completes before the next executes.  All accesses of PHV containers
       are associated with a particular Unit.  */
    virtual gress_t thread() const = 0;
    virtual int stage() const = 0;
}

class InstanceRef : HeaderRef {
    HeaderOrMetadata            obj;
    inline NameMap<InstanceRef> nested;
#noconstructor
    InstanceRef(cstring prefix, ID n, Type t, bool forceMeta = false);
    InstanceRef(ID n, Type t, bool forceMeta = false) : InstanceRef(cstring(), n, t, forceMeta) {}
    HeaderOrMetadata baseRef() const override { return obj; }
    toString { return obj->name; }
    dbprint { out << obj; }
}

class TempVar : Expression {
    bool        POV;
    cstring     name;
    static int  uid;
#noconstructor
    TempVar(Type t, bool p = false, const char *n = 0) : Expression(t), POV(p), name(n) {
        if (!name) {
            std::string n("$tmp");
            n += std::to_string(++uid);
            name = n; } }
    TempVar(Type t, const char *n) : TempVar(t, false, n) {}
    toString { return name; }
    dbprint { out << name; }
}

