#emit
enum gress_t { INGRESS, EGRESS };
struct StageUse {
    static constexpr unsigned MAX_STAGES = 12;
    static constexpr unsigned MAX_LOGICAL_IDS = 16;
    static constexpr unsigned MAX_SRAMS = 80;
    static constexpr unsigned MAX_TCAMS = 24;
    static constexpr unsigned MAX_MAPRAMS = 48;
    static constexpr unsigned MAX_IXBAR_BYTES = 128;
    static constexpr unsigned MAX_TERNARY_GROUPS = 12;
};
inline std::ostream &operator<<(std::ostream &out, gress_t gress) {
    return out << (gress ? "egress" : "ingress"); }
#end

#emit_impl
#include "tofino/ir/thread_visitor.h"
#end

class Tofino::Pipe {
    Metadata    standard_metadata; // not visited
#noconstructor
#emit
    struct thread_t {
        const Tofino::Parser    *parser;
        const MAU::TableSeq     *mau;
        const Tofino::Deparser  *deparser;
        bool operator==(const thread_t &a) const {
            return parser == a.parser && mau == a.mau && deparser == a.deparser; }
    } thread[2] = { { nullptr, nullptr, nullptr } };  // INGRESS and EGRESS
#end
#apply
    operator== { return standard_metadata == a.standard_metadata &&
                        thread[0] == a.thread[0] && thread[1] == a.thread[1]; }
    visit_children {
        if (auto *th = dynamic_cast<ThreadVisitor *>(&v)) {
            v.visit(thread[th->thread].parser, "parser");
            v.visit(thread[th->thread].mau, "mau");
            v.visit(thread[th->thread].deparser, "deparser");
        } else {
            for (auto &th : thread) {
                v.visit(th.parser, "parser");
                v.visit(th.mau, "mau");
                v.visit(th.deparser, "deparser"); } } }
}

class InstanceRef : HeaderRef {
    ID                          name;
    HeaderOrMetadata            obj;
    inline NameMap<InstanceRef> nested;
#noconstructor
#emit
    InstanceRef(ID n, const Type *t);
#end
    toString { return name; }
    dbprint { out << obj; }
}
