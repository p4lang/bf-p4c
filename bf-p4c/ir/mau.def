

#emit
struct TableResourceAlloc;
#include "bf-p4c/mau/hash_function.h"
#end
#emit_impl
#include "bf-p4c/mau/resource.h"
#end

#emit_impl
#include "extensions/bf-p4c/mau/resource.h"
#end


#emit
namespace IR {
namespace MAU {
enum class DataAggregation { NONE, PACKETS, BYTES, BOTH };
enum class MeterType { UNUSED, STFUL_INST0, COLOR_BLIND, STFUL_INST1, SELECTOR, STFUL_INST2,
                       COLOR_AWARE, STFUL_INST3 };
}
}

inline std::ostream& operator<<(std::ostream &out, IR::MAU::DataAggregation d) {
    switch (d) {
        case IR::MAU::DataAggregation::NONE:
            out << "NONE";
            break;
        case IR::MAU::DataAggregation::PACKETS:
            out << "PACKETS";
            break;
        case IR::MAU::DataAggregation::BYTES:
            out << "BYTES";
            break;
        case IR::MAU::DataAggregation::BOTH:
            out << "BOTH";
            break;
        default:
            BUG("Unhandled case");
    }
    return out;
}

inline bool operator>>(cstring s, IR::MAU::DataAggregation &d) {
    if (!s || s == "" || s == "NONE") d = IR::MAU::DataAggregation::NONE;
    else if (s == "PACKETS") d = IR::MAU::DataAggregation::PACKETS;
    else if (s == "BYTES") d = IR::MAU::DataAggregation::BYTES;
    else if (s == "BOTH") d = IR::MAU::DataAggregation::BOTH;
    else return false;
    return true;
}

inline std::ostream& operator<<(std::ostream &out, IR::MAU::MeterType m) {
    switch(m) {
        case IR::MAU::MeterType::UNUSED:
            out << "UNUSED";
            break;
        case IR::MAU::MeterType::STFUL_INST0:
            out << "STFUL_INST0";
            break;
        case IR::MAU::MeterType::COLOR_BLIND:
            out << "COLOR_BLIND";
            break;
        case IR::MAU::MeterType::STFUL_INST1:
            out << "STFUL_INST1";
            break;
        case IR::MAU::MeterType::SELECTOR:
            out << "SELECTOR";
            break;
        case IR::MAU::MeterType::STFUL_INST2:
            out << "STFUL_INST2";
            break;
        case IR::MAU::MeterType::COLOR_AWARE:
            out << "COLOR_AWARE";
            break;
        case IR::MAU::MeterType::STFUL_INST3:
            out << "STFUL_INST3";
            break;
    }
    return out;
}

inline bool operator>>(cstring s, IR::MAU::MeterType &m) {
    if (!s || s == "" || s == "UNUSED") m = IR::MAU::MeterType::UNUSED;
    else if (s == "STFUL_INST0") m = IR::MAU::MeterType::STFUL_INST0;
    else if (s == "COLOR_BLIND") m = IR::MAU::MeterType::COLOR_BLIND;
    else if (s == "STFUL_INST1") m = IR::MAU::MeterType::STFUL_INST1;
    else if (s == "SELECTOR") m = IR::MAU::MeterType::SELECTOR;
    else if (s == "STFUL_INST2") m = IR::MAU::MeterType::STFUL_INST2;
    else if (s == "COLOR_AWARE") m = IR::MAU::MeterType::COLOR_AWARE;
    else if (s == "STFUL_INST3") m = IR::MAU::MeterType::STFUL_INST3;
    else return false;
    return true;
}
#end

namespace MAU {

/** A Tofino logical table (group) -- a gateway and/or match table
 * along with whatever attached tables are run.  The basic scheduling
 * unit for tofino; there are 16 such 'logical' tables available in
 * each stage, which will run simultaneously and have their results
 * predicated by the predicate mask calculated from the next tables */
class Table : BFN::Unit {
    cstring                                     name;
    gress_t                                     gress;
    cstring                                     gateway_name;
    /** Each stage has 16 slots for tables.  Logical IDs are numbered from 0
     * (Stage 0, Slot 0) to N * 16 + 15 (Stage N, Slot 15).  The @logical_id is
     * where this table has been assigned, or -1 if it has not yet been
     * assigned.
     *
     * If @logical_id is not -1, the stage this table is assigned to is
     * `(int)(logical_id/16)`.
     */
    int                                         logical_id = -1;
    // The split within the stage for an atcam/dleft table
    int                                         logical_split = -1;
    int                                         logical_tables_in_stage = -1;
    safe_vector<std::pair<Expression, cstring>> gateway_rows;
    /** each gateway_row is a an expression for a single row of the gateway,
     * with the string being a tag to run in 'next' for next table, or null
     * if the match_table should run.  The last row (only) may have a NULL
     * expression for 'always' -- corresponding to the gateway miss action
     * (taken if no gateway rows match).  If this last row NULL expression
     * is not present, the default action is to run the table. */
    NullOK Action                               gateway_payload;
    // match_table never visited, keys are in match_key, default action also in action
    NullOK IR::P4Table                          match_table;
    inline Vector<BackendAttached>              attached;
    // ordered_map is used because assembly assumes the order of actions
    // matches to the next table name in the hit list.
    inline ordered_map<cstring, Action>         actions;
    // std::map is used because using ordered_map fails stful.p4 by generating
    // stful alu that are supposed to be in the same stage to different stages.
    // XXX(hanw): we should get to the bottom of this issue.
    inline std::map<cstring, TableSeq>          next;
    inline Vector<InputXBarRead>                match_key;
    int                                         random_seed = -1;

    class Layout {
        /* POD type */
        int             entries = 0;
        bool            pre_classifier = false;
        bool            gateway = false;
        bool            exact = false;
        bool            ternary = false;
        bool            hash_action = false;
        bool            atcam = false;
        bool            alpm = false;
        bool            has_range = false;
        int             ixbar_bytes = 0;
        int             match_bytes = 0;
        int             ixbar_width_bits = 0;
        int             match_width_bits = 0;
        int             ghost_bytes = 0;
        int             action_data_bytes = 0;
        int             action_data_bytes_in_table = 0;
        int             overhead_bits = 0;
        int             meter_addr_bits = 0;
        int             meter_type_bits = 0;
        int             counter_addr_bits = 0;
        int             action_addr_bits = 0;
        int             immediate_bits = 0;
        int             partition_bits = 0;
        int             partition_count = 0;
        int             pre_classifer_number_entries = 0;
        int             subtrees_per_partition = 0;
        int             total_actions = 0;
        Layout() { memset(this, 0, sizeof(*this)); }
        operator== { return memcmp(this, &a, sizeof(Layout)) == 0; }
        toJSON {
            json << json.indent << "\"entries\" : " << entries << ",\n"
                 << json.indent << "\"gateway\" : " << gateway << ",\n"
                 << json.indent << "\"ternary\" : " << ternary << ",\n"
                 << json.indent << "\"ixbar_bytes\" : " << ixbar_bytes << ",\n"
                 << json.indent << "\"match_width_bits\" : " << match_width_bits << ",\n"
                 << json.indent << "\"action_data_bytes_in_table\" : "
                                << action_data_bytes_in_table << ",\n"
                 << json.indent << "\"immediate_bits\" : " << immediate_bits << ",\n"
                 << json.indent << "\"overhead_bits\" : " << overhead_bits; }
        fromJSON {
            if (!json.json) return nullptr;
            Layout *rv = new Layout();
            json.load("entries", rv->entries);
            json.load("gateway", rv->gateway);
            json.load("ternary", rv->ternary);
            json.load("ixbar_bytes", rv->ixbar_bytes);
            json.load("match_width_bits", rv->match_width_bits);
            json.load("action_data_bytes_in_table", rv->action_data_bytes_in_table);
            json.load("immediate_bits", rv->immediate_bits);
            json.load("overhead_bits", rv->overhead_bits);
            return rv; }

        bool direct_ad_required() const {
            if (action_addr_bits > 0)
                return false;
            if (action_data_bytes == 0)
                return false;
            return action_data_bytes_in_table > 0;
        }
        bool ternary_indirect_required() const { return ternary; }
        bool no_match_data() const {
            return ixbar_width_bits == 0;
        }
        /** Currently hash action tables and default action tables that cannot be adapted by
         *  runtime go through the hit pathway in Glass, so allocating accordingly.
         */
        bool no_match_hit_path() const {
            return no_match_data() && ((overhead_bits == 0 && action_data_bytes == 0
                && total_actions == 1) || hash_action);
        }
        /** Any keyless table that has parameters that can be adjusted during runtime, such
         *  as action or action data must go through the miss pathway, as those are the registers
         *  configured by the driver when the control plane requests a change
         */
        bool no_match_miss_path() const {
            return no_match_data() && !no_match_hit_path();
        }
#emit
        Layout &operator+=(const Layout &a);
#end
    }
#emit
    Layout layout;  // need Layout operator<< or dbprint to remove #emit here.
#end
    class Way {
        /* POD type */
        int             match_groups = 0;
        int             entries = 0;
        int             width = 0;
        Way() { memset(this, 0, sizeof(*this)); }
        operator== { return memcmp(this, &a, sizeof(Way)) == 0; }
        toJSON {
            json << json.indent << "\"match_groups\" : " << match_groups << ",\n"
                 << json.indent << "\"entries\" : " << entries << ",\n"
                 << json.indent << "\"width\" : " << width; }
        fromJSON {
            if (!json.json) return nullptr;
            Way* way = new Way();
            json.load("match_groups", way->match_groups);
            json.load("entries", way->entries);
            json.load("width", way->width);
            return way; }
    }
    safe_vector<Way>    ways;
    const TableResourceAlloc            *resources = nullptr;
    bool is_placed() const { return resources != nullptr; }
    bool action_chain() const;
    bool has_default_path() const;
    int action_next_paths() const;
    int get_provided_stage() const;
    int hit_actions() const;
    int get_random_seed() const;
    bool for_dleft() const;

#emit
    static constexpr int TIND_NAME = 1;
    static constexpr int AD_NAME = 2;
#end
    cstring get_use_name(const IR::MAU::AttachedMemory *at = nullptr, bool is_gw = false,
                         int type = 0, int logical_table = -1) const;

#noconstructor
    Table(cstring n, gress_t gr) : name(n), gress(gr) {}
    Table(cstring n, gress_t gr, IR::P4Table t)
    : BFN::Unit(t->srcInfo), name(n), gress(gr), match_table(t) {}
#emit
    Table(cstring n, gress_t gr, const Expression *gw)
    : BFN::Unit(gw->srcInfo), name(n), gress(gr),
      gateway_rows{ std::make_pair(gw, "$true"), std::make_pair(nullptr, "$false") } {}
    // ir-generator can't parse {}-initializer (thinks it is the ctor body
#end

    int logical_order() const { return logical_id + gress * 4096; }
    Table *clone_rename(cstring ext) const {
        Table *rv = clone();
        rv->name += ext;
        return rv; }
#nooperator==
#emit
    bool operator==(const Table &a) const override;
#end
    bool uses_gateway() const { return !gateway_rows.empty(); }
    bool gateway_only() const { return match_key.empty() && actions.empty(); }
    int stage() const override {
        return logical_id < 0 ? -1 : logical_id / StageUse::MAX_LOGICAL_IDS; }
    gress_t thread() const override { return gress; }
    validate {
        std::set<cstring> gw_next;
        for (auto &gw : gateway_rows) {
            if (&gw != &gateway_rows.back())
                CHECK_NULL(gw.first);
            else if (gw.first)
                gw_next.emplace(cstring());
            gw_next.emplace(gw.second); }
        if (gateway_only() && !uses_gateway())
            BUG("table with no gateway or match table");
        if (gateway_only() && gw_next.count(cstring()))
            BUG("gateway with no match table wants to run match table");
        if (!gateway_only() && uses_gateway() && !gw_next.count(cstring()))
            BUG("gateway always overrides match table");
        for (auto &nxt : next) {
            if (nxt.first == "$default") {
            } else if (nxt.first == "$hit" || nxt.first == "$miss"
                       || nxt.first == "$try_next_stage") {
                if (!match_table)
                    BUG("%s next on table with no match_table", nxt.first);
            } else if (!gw_next.count(nxt.first) && !actions.count(nxt.first)) {
                BUG("%s next on table with no such action or gw result", nxt.first);
            }
            if (!gateway_only()) {
                if (next.count("$hit") || next.count("$miss")) {
                    size_t valid_next_table_size = next.count("$hit") + next.count("$miss")
                                                   + next.count("$try_next_stage");
                    BUG_CHECK(valid_next_table_size == next.size(),
                              "Somehow have a hit/miss table combined with an action chain");
                }
            }
        }
     }
    visit_children {
        for (auto &gw : gateway_rows)
            v.visit(gw.first, "gateway_row");
        auto &gateway_inhibit(v.flow_clone());
        gateway_inhibit.visit(gateway_payload, "gateway_payload");
        match_key.visit_children(v);
        if (!gateway_only()) {
            auto &clone(v.flow_clone());
            v.flow_dead();
            // Can separate table using hit/miss from tables using action chaining,
            // as in P4 semantically, a table can not use both hit/miss and action chaining
            // Potentially if that changes, we will have to support it with a layered approach
            // to the next table propagation
            if (!next.count("$hit") && !next.count("$miss")) {
                auto &default_action(clone.flow_clone());
                default_action.flow_dead();
                for (auto &action : Values(actions)) {
                    auto &clone2(clone.flow_clone());
                    clone2.visit(action);
                    if (next.count(action->internal_name)) {
                        clone2.visit(next.at(action->internal_name), action->internal_name);
                        v.flow_merge(clone2);
                    } else {
                        default_action.flow_merge(clone2);
                    }
                }
                if (next.count("$default"))
                    default_action.visit(next.at("$default"), "$default");
                v.flow_merge(default_action);
            } else {
                auto &hit_actions(clone.flow_clone());
                auto &miss_actions(clone.flow_clone());
                hit_actions.flow_dead();
                miss_actions.flow_dead();

                for (auto &action : Values(actions)) {
                    auto &clone2(clone.flow_clone());
                    clone2.visit(action);
                    if (!action->hit_only())
                        miss_actions.flow_merge(clone2);
                    if (!action->miss_only())
                        hit_actions.flow_merge(clone2);
                }

                if (next.count("$hit"))
                    hit_actions.visit(next.at("$hit"), "$hit");
                if (next.count("$miss"))
                    miss_actions.visit(next.at("$miss"), "$miss");
                v.flow_merge(hit_actions);
                v.flow_merge(miss_actions);
            }
            if (next.count("$try_next_stage")) {
                auto &clone2(clone.flow_clone());
                clone2.visit(next.at("$try_next_stage"), "$try_next_stage");
                v.flow_merge(clone2);
            }
        } else {
            v.flow_dead(); }
        std::set<cstring> gw_next;
        for (auto &gw : gateway_rows) {
            if (gw.second && !gw_next.count(gw.second)) {
                auto &clone2(gateway_inhibit.flow_clone());
                if (next.count(gw.second)) {
                    clone2.visit(next.at(gw.second), gw.second); }
                v.flow_merge(clone2);
                gw_next.emplace(gw.second); } }
        // FIXME -- attached tables are not properly visited here in the control-flow order,
        // FIXME -- because we don't really know which actions will trigger them.  They
        // FIXME -- should be visited after the action(s) that trigger them and before
        // FIXME -- the next tables that happen after those actions?
        // FIXME -- If the actions contain references to them, then they'll be visited when
        // FIXME -- the action is visited, and this will be a 'revisit'
        attached.visit_children(v);
    }
#apply
}


// attachement of an AttachedMemory table to a match table -- different match tables
// may attach the same AttachedMemory table with different BackendAttached, as long as
// the match tables are mutually exclusive
class BackendAttached {
    NullOK HashDist hash_dist = nullptr;
#emit
    enum use_t { NO_USE, DIRECT, INDIRECT, LOG, STACK_PUSH, STACK_POP, FIFO_PUSH, FIFO_POP };
    enum addr_location_t { ADDR_DIRECT, ADDR_OVERHEAD, ADDR_HASH, ADDR_NOT_SET };
    enum pfe_location_t { PFE_DEFAULT, PFE_OVERHEAD, PFE_PAYLOAD, PFE_NOT_SET };
    enum type_location_t { TYPE_DEFAULT, TYPE_OVERHEAD, TYPE_NOT_SET };
#end
    use_t use = NO_USE;
    addr_location_t addr_location = ADDR_NOT_SET;
    pfe_location_t pfe_location = PFE_NOT_SET;
    type_location_t type_location = TYPE_NOT_SET;
    safe_vector<cstring>                                learn = {};
    safe_vector<cstring>                                match = {};
    AttachedMemory attached;
}

#emit
inline bool operator>>(cstring s, IR::MAU::BackendAttached::use_t &u) {
    if (!s || s == "" || s == "NO_USE") u = IR::MAU::BackendAttached::NO_USE;
    else if (s == "DIRECT") u = IR::MAU::BackendAttached::DIRECT;
    else if (s == "INDIRECT") u = IR::MAU::BackendAttached::INDIRECT;
    else if (s == "LOG") u = IR::MAU::BackendAttached::LOG;
    else if (s == "FIFO_PUSH") u = IR::MAU::BackendAttached::FIFO_PUSH;
    else if (s == "FIFO_POP") u = IR::MAU::BackendAttached::FIFO_POP;
    else if (s == "STACK_PUSH") u = IR::MAU::BackendAttached::STACK_PUSH;
    else if (s == "STACK_POP") u = IR::MAU::BackendAttached::STACK_POP;
    else return false;
    return true;
}

inline bool operator>>(cstring s, IR::MAU::BackendAttached::addr_location_t &a) {
    if (!s || s == "" || s == "ADDR_NOT_SET") a = IR::MAU::BackendAttached::ADDR_NOT_SET;
    else if (s == "ADDR_DIRECT") a = IR::MAU::BackendAttached::ADDR_DIRECT;
    else if (s == "ADDR_OVERHEAD") a = IR::MAU::BackendAttached::ADDR_OVERHEAD;
    else if (s == "ADDR_HASH") a = IR::MAU::BackendAttached::ADDR_HASH;
    else return false;
    return true;
}

inline bool operator>>(cstring s,  IR::MAU::BackendAttached::pfe_location_t &p) {
    if (!s || s == "" || s == "PFE_NOT_SET") p = IR::MAU::BackendAttached::PFE_NOT_SET;
    else if (s == "PFE_DEFAULT") p = IR::MAU::BackendAttached::PFE_DEFAULT;
    else if (s == "PFE_OVERHEAD") p = IR::MAU::BackendAttached::PFE_OVERHEAD;
    else if (s == "PFE_PAYLOAD") p = IR::MAU::BackendAttached::PFE_PAYLOAD;
    else return false;
    return true;
}

inline bool operator>>(cstring s, IR::MAU::BackendAttached::type_location_t &t) {
    if (!s || s == "" || s == "TYPE_NOT_SET") t = IR::MAU::BackendAttached::TYPE_NOT_SET;
    else if (s == "TYPE_DEFAULT") t = IR::MAU::BackendAttached::TYPE_DEFAULT;
    else if (s == "TYPE_OVERHEAD") t = IR::MAU::BackendAttached::TYPE_OVERHEAD;
    else return false;
    return true;
}
#end


#emit
#include "extensions/bf-p4c/ir/unique_id.h"
#end

abstract AttachedMemory : Attached {
    bool direct = false;
    int size = 0;
    virtual bool indexed() const override { return !direct; }
    virtual UniqueAttachedId::type_t get_id_type() const = 0;
    UniqueAttachedId unique_id() const { return UniqueAttachedId(name, get_id_type()); }
}

/** Any attached table that has a keeps stateful information about flows.
 */
abstract Synth2Port : AttachedMemory {
    ID table = {};
    bool saturating = false;
    int width = 0;
    DataAggregation type = DataAggregation::NONE;
    void settype(cstring t) {
        if (strcasecmp(t.c_str(), "packets") == 0) type = DataAggregation::PACKETS;
        else if (strcasecmp(t.c_str(), "bytes") == 0) type = DataAggregation::BYTES;
        else if (strcasecmp(t.c_str(), "packets_and_bytes") == 0 ||
                 strcasecmp(t.c_str(), "packetsandbytes") == 0) type = DataAggregation::BOTH;
        else error("%s: Unknown type %s", srcInfo, t); }  // NOLINT
}

class Counter : Synth2Port {
    int min_width = -1;
    int max_width = -1; // Perhaps to play with a range of widths
    int threshold = -1;
    int interval = -1;
    const char *kind() const override { return "stats"; }
#nodbprint
    const Type *getType() const override { return Type_Counter::get(); }
    UniqueAttachedId::type_t get_id_type() const override { return UniqueAttachedId::COUNTER; } 
}

class Meter : Synth2Port {
    int red_drop_value = -1;
    int red_nodrop_value = -1;
    NullOK Expression  result = nullptr;     // Field which meter writes, eventually be deprecated
                                             // as it should be contained in AttachedOutput
    NullOK HashDist    pre_color = nullptr;  // Field to pre-color the meter.  Eventually
                                             // brought through hash distribution
    NullOK Expression  input = nullptr;      // LPF and WRED have 32 bit inputs
    ID                 implementation = {};  // Normal, LPF, WRED
    const char *kind() const override { return "meter"; }
    const Type *getType() const override { return Type_Meter::get(); }
    UniqueAttachedId::type_t get_id_type() const override { return UniqueAttachedId::METER; }
    bool alu_output() const { return implementation.name == "lpf"
                               || implementation.name == "wred"; }
    bool color_output() const { return implementation.name == "normal"
                                 || implementation.name.isNull(); }
#nodbprint
}

/** Configuration for a stateful table -- a register object (for the memory) plus
 * the associated stateful alu instructions and config */
class StatefulAlu : Synth2Port {
    // The single register or action_selector extern used in this stateful alu
    Declaration_Instance                                reg;
    NullOK Selector                                     selector = nullptr;
    bool                                                dual = false;  // dual mode
        // if dual is true, the ALU width is half the Register width (field)
        // if dual is false, the ALU width is equal to the Register width
        // this means that ALU width can be calculated as `width >> dual`
    // The possible stateful_alu externs executed in this table
    inline NameMap<SaluAction, ordered_map>             instruction = {};
    // The stateful_alu externs executed for each action in the match table
    ordered_map<cstring, cstring>                       action_map = {};
    // overflow and underflow actions, if any
    cstring                                             overflow = {};
    cstring                                             underflow = {};

    class MathUnit {
        bool            valid = false;
        bool            exp_invert = false;
        int             exp_shift = 0;
        int             scale = 0;
        int[16]         table = { 0 };
        MathUnit() { memset(this, 0, sizeof(*this)); }
        operator== { return memcmp(this, &a, sizeof(*this)) == 0; }
        dbprint { out << valid; }
    }
    MathUnit            math = MathUnit();

    const char *kind() const override { return "stateful"; }
    const Type *getType() const override { return Type_Register::get(); }
    UniqueAttachedId::type_t get_id_type() const override { return UniqueAttachedId::STATEFUL_ALU; }

    int source_width() const {
        if (dual)
            return width / 2;
        return width;
    }
}

class Selector : AttachedMemory {
    ID type = {};
    ID mode = {};
    hash_function algorithm = {};
    const char *kind() const override { return "selector"; }
    UniqueAttachedId::type_t get_id_type() const override { return UniqueAttachedId::SELECTOR; }
    int num_groups = 0;
    int group_size = 0;
#nodbprint
}


/** Tofino-specific attached table type **/

/** Ternary indirect table used to hold overhead (adressing pointers and next table info)
 * of ternary match tables */
class TernaryIndirect : AttachedMemory {
#noconstructor
#nodbprint
    TernaryIndirect(cstring tbl_name) { name = IR::ID(tbl_name + "$tind"); direct = true; }
    const char *kind() const override { return "indirect"; }
    UniqueAttachedId::type_t get_id_type() const override {
        return UniqueAttachedId::TERNARY_INDIRECT;
    }
}

/** Action data table used to hold action parameters */
class ActionData : AttachedMemory {
#nodbprint
    const char *kind() const override { return "action"; }
    bool indexed() const override { return !direct; }
    UniqueAttachedId::type_t get_id_type() const override {
        return UniqueAttachedId::ACTION_DATA;
    }
}

/** Idletime table **/
class IdleTime : AttachedMemory {
    int precision = 3;
    int interval = 7;
    cstring two_way_notification = "enable";
    bool per_flow_idletime = true;
#noconstructor
#nodbprint
    IdleTime(cstring tbl_name) { name = IR::ID(tbl_name + "$idletime"); direct = true; }
    const char *kind() const override { return "idletime"; }
    UniqueAttachedId::type_t get_id_type() const override {
        return UniqueAttachedId::IDLETIME;
    }
}

// a sequence of tables -- may be reordered if deps allow.
// deps(i,j) is true iff tables[i] is dependent on tables[j]
// (so must have j < i) */
class TableSeq {
    inline Vector<Table>        tables;
    LTBitMatrix                 deps;
#noconstructor
    TableSeq() = default;
    TableSeq(Table a) { if (a) tables.push_back(a); }
    TableSeq(Table a, Table b) {
        if (a) tables.push_back(a);
        if (b) tables.push_back(b); }
    TableSeq(TableSeq a, Table b) {
        if (a) tables.insert(tables.end(), a->tables.begin(), a->tables.end());
        if (b) tables.push_back(b); }
    bool empty() const { return tables.empty(); }
    Table front() const { return tables.empty() ? nullptr : tables.front(); }
#apply
}

/// A primitive function, optionally annotated with its front end type.
class TypedPrimitive : Primitive {
#nodbprint
#noconstructor
    IR::Type method_type;

    TypedPrimitive(cstring name)
    : Primitive(name), method_type(nullptr) { }
    TypedPrimitive(Util::SourceInfo srcInfo, const IR::Type* return_type, const IR::Type* m_type, cstring name)
    : Primitive(srcInfo, return_type, name), method_type(m_type) { }

    visit_children { Primitive::visit_children(v); }
}

/// A single MAU instruction.  For the most part instructions look exactly like Primitives,
/// just with more constraints applied.  For example, an "add" instruction has the same
/// destination and two sources as an "add" primitive, with the additional constraints that
/// the dest and first source are PHV while second source can be PHV, action bus, or constant.
/// We convert the primitive into an instruction when we check those constraints
// TODO(cdodd) -- stateful ALU has its own disctinct instruction set -- should use a different
// class for those or reuse this?  Currently reusing this.
class Instruction : Primitive {
#nodbprint
#emit
    using Primitive::Primitive;
#end
    // This is a vector, filled after BackendCopyPropagation, indicating which operands
    // have been copy propagated from an earlier instruction.  Copy propagated operands
    // don't have to be checked in order to guarantee parallelism
    safe_vector<bool> copy_propagated = {};
    Instruction(const Primitive &p) : Primitive(p) {}
    Instruction(cstring op, const std::vector<Expression> &args) : Primitive(op) {
        for (auto a : args) operands.push_back(a); }
    bool isOutput(int operand_index) const override { return operand_index == 0; }
    validate { BUG_CHECK(name, "empty name in instruction"); }
}

/// The IR::MAU::Action argument.
class ActionArg : Expression {
    cstring     action_name;
    ID          name;
    ActionArg { if (!srcInfo) srcInfo = name.srcInfo; }
    dbprint{ out << action_name << ':' << name; }
    toString{ return name.name; }
}

/// The base class for MAU::Action and MAU::SaluAction, both represent a wide VLIW action.
abstract VLIWInstruction {
}

/// The Action part of an action table -- basically a single VLIW instruction, which is a
/// set of instructions on different PHV containers that all run simultaneously
class Action : VLIWInstruction {
    optional ID                 name;
    inline Vector<Primitive>    action = {};
    safe_vector<ActionArg>      args = {};
    optional Annotations        annotations = Annotations::empty;
    bool miss_action_only = false;
    bool init_default = false;
    bool default_allowed = false;
    // Currently if a table used hash distribution or the RNG, then the table must go
    // go through the hit pathway.  However, due to different driver implementation, this
    // could be different than being table_only, and thus it is left out of the
    // visit_children of the table.
    bool hit_path_imp_only = false;
    cstring internal_name = "";
    cstring disallowed_reason = "none";
    inline Vector<Argument> default_params = {};

    // Separate stateful primitives from actions, as they aren't instructions
    // as such.

    std::set<UniqueAttachedId> per_flow_enables = {};
    std::map<UniqueAttachedId, MeterType> meter_types = {};

    inline Vector<Primitive>    stateful = {};

    bool hit_only() const { return default_allowed == false; }
    bool miss_only() const { return miss_action_only == true; }

    validate {
        ERROR_CHECK(!(hit_only() && miss_only()), "Action %s cannot be both a hit only and a "
                    "miss only action.  Can only be at most one of those categories", name);
    }
}

/// A stateful ALU VLIW instruction -- multiple instructions that all run together
/// "simultanesouly" in different ALUs (certain ALUs are actually later in the pipeline)
/// in the stateful ALU block (there are 2 comparison, 4 "normal" and 1 output alus)
class SaluAction : VLIWInstruction {
    cstring                     name;
    inline Vector<Primitive>    action = {};
    safe_vector<ActionArg>      args = {};
    optional Annotations        annotations = Annotations::empty;
    NullOK Expression  output_dst = nullptr;  // implicit write of output to this lvalue

    toString {
        return cstring("action ") + name + " {\n" +
                 cstring::join(action.begin(), action.end(), ";\n") +
                 " }"; }
}


/** Tofino-specific expressions that may be present in various places */

/** Hash Distribution Unit, used to bring PHV information directly into Match Central for
 *  action data lookup or action data itself.  Uses include addressing a table by a PHV field
 *  as well as a calculated hash to be used by PHV
 */
class HashDist : Expression {

    dbprint {
        out << "hash_dist(" << field_list << ", " << algorithm << ", " << bit_width << ")";
    }
    // Fields read by this HashDist
    Expression           field_list;
    hash_function        algorithm;
    int                  bit_width = 0;
    // Pointer to the IR::Primitive that was used to generate this HashDist
    // (and then removed).  This is not visited as part of IR traversal.
    NullOK Primitive     prim;

    visit_children {
        Expression::visit_children(v);
        v.visit(field_list, "field_list"); }
}


class ActionDataConstant : Expression {
    cstring name;
    Constant constant;

    ActionDataConstant { type = constant->type; }
    dbprint { out << "action data constant " << constant; }
}

class RandomNumber : Expression {
    dbprint { out << "rng(" << type << ")"; }
}

/// A use of an attached table output; an operand of an instruction
class AttachedOutput : Expression {
    AttachedMemory     attached;
    dbprint { out << attached->name; }
}

/// reference to a fixed Stateful ALU resource -- these can only appear in SALU Instructions
class SaluReg : Expression {
    cstring                name;
    bool                   hi;     // corresponds to the high half of the alus
    NullOK Expression      phv_src = nullptr;
    dbprint { out << name << (hi ? " {hi}" : ""); }
}

class SaluMathFunction : Operation_Unary {
    stringOp = "math_unit";
    dbprint { out << "math_unit (" << expr << ")"; }
}

class MultiOperand : ListExpression {
#nodbprint
     cstring name;
     bool is_phv;
     MultiOperand(ListExpression &le, cstring n, bool ip)
        : ListExpression(le), name(n), is_phv(ip) {}
}

class InputXBarRead : Expression, IAnnotated {
    Expression expr;
    ID match_type;
    int p4_param_order = -1;
    bool from_mask = false;
    bool partition_index = false;

    bool for_selection() const { return match_type.name == "selector"; }
    bool for_dleft() const { return match_type.name == "dleft_hash"; }
    bool for_match() const { return !for_selection() && !for_dleft(); }

    dbprint { out << expr << ": " << match_type.name; }

    optional Annotations        annotations = Annotations::empty;
    Annotations getAnnotations() const override { return annotations; }
}

}  // end namespace MAU

class RangeMatch : Operation_Unary {
    // range match -- use operand (up to 4 bits) as index into constant (up to 16 bits)
    // to extract a single bit.  Result is boolean.
    unsigned    data;
    RangeMatch { type = Type::Boolean::get(); }
    precedence = DBPrint::Prec_Equ;
    stringOp = " in ";
}


