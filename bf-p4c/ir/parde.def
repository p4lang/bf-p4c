#emit
#include <boost/optional.hpp>
#include "bf-p4c/common/debug_info.h"
#include "bf-p4c/ir/bitrange.h"
#end

namespace BFN {

// An expression representing a `packet_in.lookahead()` call at the P4 level.
// The interface is very similar to Extract, and that's not a coincidence, since
// the two concepts are very closely related.
class LookaheadExpression : Expression {
#noconstructor
    LookaheadExpression(Util::SourceInfo si, nw_bitrange range)
        : Expression(si), range(range) { }
    LookaheadExpression(nw_bitrange range) : range(range) { }

    dbprint {
        out << "lookahead " << bitInterval() << "(" << range.size() << "b)";
    }

    void setBitRange(nw_bitrange newRange) { range = newRange; }

    /// @return the half-open range of bits being extracted, in network order.
    nw_bitinterval bitInterval() const { return toHalfOpenRange(range); }

    /// @return the closed range of bits being extracted, in network order.
    nw_bitrange bitRange() const { return range; }

    /// The region of the input buffer which will be extracted, expressed in
    /// bits in network order.
    nw_bitrange range;
}

/// Superclass for all unresolved header stack indices.
abstract UnresolvedStackRef : Expression {
#emit
    /// The next available id.
    static size_t nextId;
#end

#noconstructor
    UnresolvedStackRef(Util::SourceInfo si) : Expression(si), id(nextId++) { }
    UnresolvedStackRef() : id(nextId++) { }

    /// @return a clone of this UnresolvedStackRef which does not compare equal
    /// to the original or to any other existing UnresolvedStackRef.
    UnresolvedStackRef makeFresh() const {
        auto* newRef = this->clone();
        newRef->id = nextId++;
        return newRef;
    }

    size_t id;
}

/// An unresolved reference to a header stack's '.next' property. This is a
/// placeholder until we can resolve it into a concrete index.
class UnresolvedStackNext : UnresolvedStackRef {
#noconstructor
    UnresolvedStackNext(Util::SourceInfo si) : UnresolvedStackRef(si) { }
    UnresolvedStackNext() { }

    dbprint { out << "(unresolved next #" << id << ")"; }
    toString { return "next"; }
}

/// An unresolved reference to a header stack's '.last' property. This is a
/// placeholder until we can resolve it into a concrete index.
class UnresolvedStackLast : UnresolvedStackRef {
#noconstructor
    UnresolvedStackLast(Util::SourceInfo si) : UnresolvedStackRef(si) { }
    UnresolvedStackLast() { }

    dbprint { out << "(unresolved last #" << id << ")"; }
    toString { return "last"; }
}

/// A value that can *conceptually* be read from in the parser. This is a
/// superset of the values that can actually be read from on the hardware.
abstract ParserRVal { }

/// An r-value that represents a read from a range of bits in the input buffer.
/// The coordinate system used will depend on the specific type of
/// `BufferlikeRVal`.
abstract BufferlikeRVal : ParserRVal {
    /// @return this buffer range as a half-open range of bits in network order.
    nw_bitinterval bitInterval() const { return toHalfOpenRange(range); }

    /// @return this buffer range as a closed range of bits in network order.
    nw_bitrange extractedBits() const { return range; }

    /// The region represented by this `BufferlikeRVal`, expressed as a range of
    /// bits in network order.
    nw_bitrange range;
}

/// An r-value originating from the input packet. Represented as a range of bits
/// in the coordinate system of some parser state or, to describe the same thing
/// in a different way, relative to some (possibly unknown) offset within the
/// input packet. Mapping this to a location in the input *buffer* - that is, the
/// address space into which the input packet gets mapped by the hardware -
/// requires knowing which parser state it belongs to and which hardware it will
/// be used on.
class PacketRVal : BufferlikeRVal {
    dbprint {
        out << "packet bits " << bitInterval() << "(" << range.size() << "b)";
    }
}

/// An r-value representing a range of bits from the region of the input buffer
/// that's mapped onto special metadata, rather than data from the input packet.
/// This is analogous to memory-mapped I/O. The range of bits is specified in the
/// space of the input *buffer*, rather than the input *packet*, and thus the
/// coordinate system is independent of any parser state, although it's still
/// hardware-specific.
class BufferRVal : BufferlikeRVal {
    dbprint {
        out << "buffer bits " << bitInterval() << "(" << range.size() << "b)";
    }
}

/// A constant used as an r-value in the parser.
class ConstantRVal : ParserRVal {
#noconstructor
#emit
    explicit ConstantRVal(mpz_class value)
      : constant(new IR::Constant(value)) { }
    ConstantRVal(const IR::Type* type, mpz_class value)
      : constant(new IR::Constant(type, value)) { }
    ConstantRVal(Util::SourceInfo si, const IR::Type* type, mpz_class value)
      : ParserRVal(si), constant(new IR::Constant(type, value)) { }
#end

    dbprint { out << "constant " << constant; }

    Constant constant;
}

/// An r-value which is computed in the parser. The source may be an arbitrary
/// expression. These generally can't be implemented directly on any existing
/// Barefoot hardware, so if the compiler can't optimize them out, compilation
/// will fail.
class ComputedRVal : ParserRVal {
    dbprint { out << "computed value " << source; }

    /// An expression which should evaluate to an r-value usable in the parser.
    Expression source;
}

/// A value that can *conceptually* be written to in the parser. This is a
/// superset of the values that can actually be written to on the hardware.
abstract ParserLVal { }

/// A field or "field-like" value. This is something which will ultimately be
/// backed by a PHV container. It may be an `IR::Member`, an `IR::TempVar`, or
/// an `IR::Slice` wrapping either of those things.
class FieldLVal : ParserLVal {
    dbprint { out << field; }
    toString { return field->toString(); }

    validate {
        CHECK_NULL(field);
        BUG_CHECK(field->is<IR::Member>() || field->is<IR::TempVar>() ||
                  field->is<IR::Slice>(),
                  "FieldLVal contains unexpected value: %1%", field);
    }

    /// A reference to a "field-like" value backed by a PHV container.
    Expression field;
}

/// Supertype for all parser primitives - i.e., actions that can be executed in
/// parser states.
abstract ParserPrimitive { }

/// A parser extraction operation, representing a write by the parser into some
/// l-value.
class Extract : ParserPrimitive {
    Extract(Expression dest, ParserRVal source)
      : dest(new FieldLVal(dest)), source(source) { }
    Extract(Util::SourceInfo si, Expression dest, ParserRVal source)
      : ParserPrimitive(si), dest(new FieldLVal(dest)), source(source) { }

    dbprint { out << "extract " << source << " to " << dest; }

    /// The location to be written to.
    FieldLVal dest;

    /// The location that will be read from.
    ParserRVal source;
}

/// The high-level representation of a parser state transition.
class Transition {
    Transition(match_t value) : value(value), next(nullptr) { }
    Transition(match_t value, boost::optional<int> shift)
        : value(value), shift(shift), next(nullptr) { }

    /// If the owning state's select expressions evaluate to a value which
    /// matches this...
    match_t                        value;

    /// ...then shift the input buffer by this number of bytes (or boost::none
    /// if we don't know how many bytes we need to shift by yet)...
    boost::optional<int>           shift;

    /// ...and transition to this state (or, if null, end the parser program).
    NullOK ParserState             next;
}

/// A parser selection operation. These represent a load of a value from some
/// source which will be compared against the state's Transitions to select the
/// next state to transition to.
class Select {
    Select(ParserRVal source, Expression p4Source)
        : Node(p4Source->srcInfo), source(source), p4Source(p4Source) { }

    dbprint { out << "match " << source; }

    /// The value which will be matched against.
    ParserRVal source;

#emit
    /// The higher-level expression we were selecting against. Not visited.
    const Expression* p4Source = nullptr;
#end
}

/// A high-level parser state. Contains primitives which operate on fields and
/// field-like objects.
class ParserState : Unit {
#noconstructor
    ParserState(IR::ParserState p4State, cstring name, gress_t gr)
        : p4State(p4State), name(name), gress(gr) { }
    ParserState(cstring n, gress_t gr,
                std::initializer_list<ParserPrimitive> statements,
                std::initializer_list<Select> selects,
                std::initializer_list<Transition> transitions)
        : name(n), gress(gr), statements(statements), selects(selects),
          transitions(transitions) { }
    ParserState(cstring n, gress_t gr,
                const Vector<ParserPrimitive>& statements,
                std::initializer_list<Select> selects,
                std::initializer_list<Transition> transitions)
        : name(n), gress(gr), statements(statements), selects(selects),
          transitions(transitions) { }
     ParserState(cstring n, gress_t gr,
                const Vector<ParserPrimitive>& statements,
                std::initializer_list<Select> selects,
                const Vector<Transition>& transitions)
        : name(n), gress(gr), statements(statements), selects(selects),
          transitions(transitions) { }
    int stage() const override { return -1; }
    gress_t thread() const override { return gress; }
    toString { return name; }
    visit_children {
        statements.visit_children(v);
        selects.visit_children(v);
        transitions.parallel_visit_children(v); }

#emit
    /// The original P4 state. Null if this is a generated state that doesn't
    /// correspond to anything in the P4 program. Not visited.
    const IR::ParserState* p4State = nullptr;

    /// Debugging information about the P4 state or states that were used to
    /// generate this ParserState.
    ::BFN::DebugInfo debug;
#end

    cstring name;
    gress_t gress;
    inline Vector<ParserPrimitive> statements;
    inline Vector<Select> selects;
    inline Vector<Transition> transitions;
}

/// The supertype for all BFN IR parsers.
abstract AbstractParser {
#noconstructor
    AbstractParser(gress_t gr) : gress(gr) { }
#apply

    gress_t gress;
}

/// The high-level representation of a parser. This is the representation used
/// prior to PHV allocation. It contains primitives which operate on fields and
/// field-like objects; some operands may be expressions that can't yet be
/// evaluated.
class Parser : AbstractParser {
#noconstructor
    Parser(gress_t gress, ParserState start)
        : AbstractParser(gress), start(start) {}
#apply
    toString { return gress ? "egress parser" : "ingress parser"; }

    ParserState start;
}

/// A list of fields which will be written into a buffer as part of a deparser
/// digest.
class DigestFieldList {
    /// The fields to be copied into the buffer.
    inline Vector<FieldLVal> sources;

    /// The control plane name for this field list, if any. Only learning is
    /// exposed to the control plane; other kinds of digest field lists don't
    /// need a name.
    cstring controlPlaneName;
}

/// A deparser digest. Each digest writes one of several lists of fields into a
/// special hardware buffer, with the list to be used chosen by the value of a
/// selector field.
class Digest {
    Digest(cstring name, FieldLVal selector) : name(name), selector(selector) { }
    Digest(cstring name, Expression selector)
        : name(name), selector(new FieldLVal(selector)) { }

    /// The name of the digest, identifying a special buffer to be filled in by
    /// the deparser hardware. The name is chosen to match the corresponding
    /// assembly directive, which in turn is named based on definitions in the
    /// CSRs.
    cstring name;

    /// The field which controls which field list will be written into the
    /// buffer.
    FieldLVal selector;

    /// The available field lists; the index of each field list in the vector
    /// corresponds to the selector value which chooses it.
    inline Vector<DigestFieldList> fieldLists;
}

/// Supertype for all deparser primitives - i.e., actions that can be executed
/// in a deparser control.
abstract DeparserPrimitive { }

/// A deparser emit operation, representing a copy by the deparser of the
/// contents of some location (ultimately backed by a PHV container) to the
/// output packet.
class Emit : DeparserPrimitive {
    Emit(Expression source, Expression povBit)
      : source(new FieldLVal(source)), povBit(new FieldLVal(povBit)) { }
    Emit(Util::SourceInfo si, Expression source, Expression povBit)
      : DeparserPrimitive(si), source(new FieldLVal(source)),
        povBit(new FieldLVal(povBit)) { }

    dbprint {
        out << "emit " << source->field->toString()
            << " if " << povBit->field->toString();
    }

    /// The location to be copied into the output packet.
    FieldLVal source;

    /// The POV bit controlling whether the copy happens.
    FieldLVal povBit;
}

/// A deparser emit operation, representing a copy by the deparser of the
/// contents of some location (ultimately backed by a CLOT) to the
/// output packet.
class EmitClot : DeparserPrimitive {
    dbprint {
        out << "emit clot " << clot.tag << " if " << povBit->field->toString();
    }

    // XXX(zma): EmitClot should really be a lowered IR class, since these
    // are inferred from CLOT allocation.

    Clot clot;

    /// The POV bit controlling whether the copy happens.
    FieldLVal povBit;
}

/// A deparser computed checksum operation. This instructs the deparser to
/// compute the checksum of a group of fields and write the result into the
/// output packet.
class EmitChecksum : DeparserPrimitive {
    /// The fields from which the checksum will be computed.
    inline Vector<FieldLVal> sources;

    /// The POV bit controlling whether the checksum is generated and copied to
    /// the output packet.
    FieldLVal povBit;
}

/// Configures the location from which an intrinsic deparser parameter should
/// obtain its value.
class DeparserParameter {
    DeparserParameter(cstring name, Expression source)
      : name(name), source(new FieldLVal(source)), povBit(nullptr) { }
    DeparserParameter(Util::SourceInfo si, cstring name, Expression source)
      : Node(si), name(name), source(new FieldLVal(source)), povBit(nullptr) { }

    dbprint {
        out << "parameter " << name << " = " << source->field->toString();
        if (povBit) out << " if " << povBit->field->toString();
    }

    /// The deparser parameter to configure. The name is the one used in the
    /// assembly, which in turn derives from the CSR register name.
    cstring name;

    /// The location to read the parameter value from.
    FieldLVal source;

    /// If present, the POV bit controlling whether the contents of the source
    /// location are valid. Not used on Tofino.
    NullOK FieldLVal povBit = nullptr;

#emit
    /// If true, the source for this deparser parameter can be safely packed
    /// with other fields.
    bool canPack = true;
#end
}

/// The supertype for all BFN IR deparsers.
abstract AbstractDeparser : Unit {
#apply
    int stage() const override { return 999999; /* assumed larger than the number of stages */ }
    gress_t thread() const override { return gress; }

    gress_t gress;
}

class Deparser : AbstractDeparser {
#noconstructor
    Deparser(gress_t gr, P4Control dp);
#apply
    toString { return gress ? "egress deparser" : "ingress deparser"; }

    inline Vector<DeparserPrimitive>    emits;
    inline Vector<DeparserParameter>    params;
    inline NameMap<Digest>              digests;
}

}  // end namespace BFN
