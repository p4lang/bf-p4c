#emit
#include <boost/optional.hpp>
#include "bf-p4c/common/debug_info.h"
#include "bf-p4c/ir/bitrange.h"
#end

namespace BFN {

/// An expression representing a `packet_in.lookahead()` call at the P4 level.
/// The interface is very similar to ExtractBuffer, and that's not a
/// coincidence, since the two concepts are very closely related.
class LookaheadExpression : Expression {
#noconstructor
    LookaheadExpression(Util::SourceInfo si, nw_bitrange range)
        : Expression(si), range(range) { }
    LookaheadExpression(nw_bitrange range) : range(range) { }

    dbprint {
        out << "lookahead " << bitInterval() << "(" << range.size() << "b)";
    }

    void setBitRange(nw_bitrange newRange) { range = newRange; }

    /// @return the half-open range of bits being extracted, in network order.
    nw_bitinterval bitInterval() const { return toHalfOpenRange(range); }

    /// @return the closed range of bits being extracted, in network order.
    nw_bitrange bitRange() const { return range; }

    /// The region of the input buffer which will be extracted, expressed in
    /// bits in network order.
    nw_bitrange range;
}

/// Superclass for all unresolved header stack indices.
abstract UnresolvedStackRef : Expression {
#emit
    /// The next available id.
    static size_t nextId;
#end

#noconstructor
    UnresolvedStackRef(Util::SourceInfo si) : Expression(si), id(nextId++) { }
    UnresolvedStackRef() : id(nextId++) { }

    /// @return a clone of this UnresolvedStackRef which does not compare equal
    /// to the original or to any other existing UnresolvedStackRef.
    UnresolvedStackRef makeFresh() const {
        auto* newRef = this->clone();
        newRef->id = nextId++;
        return newRef;
    }

    size_t id;
}

/// An unresolved reference to a header stack's '.next' property. This is a
/// placeholder until we can resolve it into a concrete index.
class UnresolvedStackNext : UnresolvedStackRef {
#noconstructor
    UnresolvedStackNext(Util::SourceInfo si) : UnresolvedStackRef(si) { }
    UnresolvedStackNext() { }

    dbprint { out << "(unresolved next #" << id << ")"; }
    toString { return "next"; }
}

/// An unresolved reference to a header stack's '.last' property. This is a
/// placeholder until we can resolve it into a concrete index.
class UnresolvedStackLast : UnresolvedStackRef {
#noconstructor
    UnresolvedStackLast(Util::SourceInfo si) : UnresolvedStackRef(si) { }
    UnresolvedStackLast() { }

    dbprint { out << "(unresolved last #" << id << ")"; }
    toString { return "last"; }
}

/// Supertype for all parser primitives - i.e., actions that can be executed in
/// parser states.
abstract ParserPrimitive { }

/// A parser extraction operation, representing a write by the parser into some
/// location which will be ultimately backed by a PHV container.
abstract Extract : ParserPrimitive {
    validate { CHECK_NULL(dest); }

    // XXX(seth): It'd be ideal to constrain the type of `dest` a little more.
    // It's normally a field, represented by an Member, but right now we
    // sometimes extract into TempVars, and we represent partial writes using an
    // Slice, so we need a more general type.

    /// The location to be written to. Must be backed by a PHV container.
    Expression dest;
}

/// An extraction from the input buffer.
class ExtractBuffer : Extract {
#noconstructor
    ExtractBuffer(Util::SourceInfo si, Expression dest, nw_bitrange range)
        : Extract(si, dest), range(range) { }
    ExtractBuffer(Expression dest, nw_bitrange range)
        : Extract(dest), range(range) { }

    dbprint {
        out << "extract bits " << bitInterval() << "(" << range.size()
            << "b) to " << dest;
    }

    /// @return true if some of the bits being extracted were already shifted
    /// out of the input buffer.
    bool isShiftedOut() const { return range.lo < 0; }

    /// @return the half-open range of bits being extracted, in network order.
    /// These bytes are specified in the space of the input buffer.
    nw_bitinterval bitInterval() const { return toHalfOpenRange(range); }

    /// @return the closed range of bits being extracted, in network order.
    /// These bits are specified in the space of the input buffer.
    nw_bitrange extractedBits() const { return range; }

    /// The region of the input buffer which will be extracted, expressed in
    /// bits in network order.
    nw_bitrange range;
}

/// An extraction of a constant.
class ExtractConstant : Extract {
#noconstructor
    ExtractConstant(Util::SourceInfo si, Expression dest, Constant constant)
        : Extract(si, dest), constant(constant) { }
    ExtractConstant(Expression dest, Constant constant)
        : Extract(dest), constant(constant) { }

    validate { CHECK_NULL(constant); }
    dbprint { out << "extract constant " << constant << " to " << dest; }

    /// The constant to extract.
    Constant constant;
}

/// An extraction of some computed value. The source may be an arbitrary
/// expression. These can't be implemented directly on Tofino, so if the
/// compiler can't optimize them out, compilation will fail.
class ExtractComputed : Extract {
#noconstructor
    ExtractComputed(Util::SourceInfo si, Expression dest, Expression source)
        : Extract(si, dest), source(source) { }
    ExtractComputed(Expression dest, Expression source)
        : Extract(dest), source(source) { }

    validate { CHECK_NULL(source); }
    dbprint { out << "extract computed value " << source << " to " << dest; }

    /// An expression which computes the value to be extracted.
    Expression source;
}

/// The high-level representation of a parser state transition.
class Transition {
#noconstructor
    Transition(match_t value) : value(value), next(nullptr) { }
#emit
    Transition(match_t value, boost::optional<int> shift)
        : value(value), shift(shift), next(nullptr) { }
    Transition(match_t value, boost::optional<int> shift, const ParserState* next)
        : value(value), shift(shift), next(next) { }
#end

    /// If the owning state's select expressions evaluate to a value which
    /// matches this...
    match_t                        value;

    /// ...then shift the input buffer by this number of bytes (or boost::none
    /// if we don't know how many bytes we need to shift by yet)...
    boost::optional<int>           shift;

    /// ...and transition to this state (or, if null, end the parser program).
    NullOK ParserState             next;
}

/// Supertype for all parser selection operations. These represent a load of a
/// value from some source which will be compared against the state's
/// Transitions to select the next state to transition to.
abstract Select { }

/// A selection against a range of bits in the input buffer.
class SelectBuffer : Select {
#noconstructor
    SelectBuffer(Util::SourceInfo si, nw_bitrange range, Node source)
        : Select(si), range(range), source(source) { }
    SelectBuffer(Util::SourceInfo si, nw_bitrange range)
        : SelectBuffer(si, range, nullptr) { }
    SelectBuffer(nw_bitrange range, Node source)
        : range(range), source(source) { }
    SelectBuffer(nw_bitrange range)
        : SelectBuffer(range, nullptr) { }

    dbprint {
        out << "match bits " << bitInterval() << "(" << range.size() << "b)";
    }

    /// @return true if some of the bits being selected were already shifted
    /// out of the input buffer.
    bool isShiftedOut() const { return range.lo < 0; }

    /// @return the half-open range of bits being selected, in network order.
    nw_bitinterval bitInterval() const { return toHalfOpenRange(range); }

    /// @return the closed range of bits being selected, in network order.
    nw_bitrange selectedBits() const { return range; }

    /// The region of the input buffer which will be selected against, expressed
    /// in bits in network order.
    nw_bitrange range;

#emit
    /// The higher-level expression we were selecting against. Not visited.
    const Node* source;
#end
}

/// A selection against a computed value. The source may be an arbitrary
/// expression. These can't be implemented directly on Tofino, so if the
/// compiler can't optimize them out, compilation will fail.
class SelectComputed : Select {
#noconstructor
    SelectComputed(Util::SourceInfo si, Expression source)
        : Select(si), source(source) { }
    SelectComputed(Expression source) : source(source) { }

    validate { CHECK_NULL(source); }
    dbprint { out << "match computed value " << source; }

    /// An expression which computes the value to be matched against.
    Expression source;
}

/// A high-level parser state. Contains primitives which operate on fields and
/// field-like objects.
class ParserState : Unit {
#noconstructor
    ParserState(IR::ParserState p4State, cstring name, gress_t gr)
        : p4State(p4State), name(name), gress(gr) { }
    ParserState(cstring n, gress_t gr,
                std::initializer_list<ParserPrimitive> statements,
                std::initializer_list<Select> selects,
                std::initializer_list<Transition> transitions)
        : name(n), gress(gr), statements(statements), selects(selects),
          transitions(transitions) { }
    ParserState(cstring n, gress_t gr,
                const Vector<ParserPrimitive>& statements,
                std::initializer_list<Select> selects,
                std::initializer_list<Transition> transitions)
        : name(n), gress(gr), statements(statements), selects(selects),
          transitions(transitions) { }
    int stage() const override { return -1; }
    gress_t thread() const override { return gress; }
    toString { return name; }
    visit_children {
        statements.visit_children(v);
        selects.visit_children(v);
        transitions.parallel_visit_children(v); }

#emit
    /// The original P4 state. Null if this is a generated state that doesn't
    /// correspond to anything in the P4 program. Not visited.
    const IR::ParserState* p4State = nullptr;

    /// Debugging information about the P4 state or states that were used to
    /// generate this ParserState.
    ::BFN::DebugInfo debug;
#end

    cstring name;
    gress_t gress;
    inline Vector<ParserPrimitive> statements;
    inline Vector<Select> selects;
    inline Vector<Transition> transitions;
}

/// The supertype for all BFN IR parsers.
abstract AbstractParser {
#noconstructor
    AbstractParser(gress_t gr) : gress(gr) { }
#apply

    gress_t gress;
}

/// The high-level representation of a parser. This is the representation used
/// prior to PHV allocation. It contains primitives which operate on fields and
/// field-like objects; some operands may be expressions that can't yet be
/// evaluated.
class Parser : AbstractParser {
#noconstructor
    Parser(gress_t gress, ParserState start)
        : AbstractParser(gress), start(start) {}
#apply
    toString { return gress ? "egress parser" : "ingress parser"; }

    ParserState start;
}

class DeparserIntrinsic {
    Expression          value;
    NullOK Expression   povBit = nullptr;
}

class Digest {
    gress_t                             gress;
    cstring                             name;
    Expression                          select;
    std::vector<Vector<Expression>>     sets = {};
    Digest(gress_t gress, cstring name) : gress(gress), name(name),
        select(new TempVar(Type::Bits::get(3), cstring("$" + name))) {}
    visit_children {
        v.visit(select, "select");
        for (auto &s : sets)
            v.visit(s, "set"); }
}

/// Supertype for all deparser primitives - i.e., actions that can be executed
/// in a deparser control.
abstract DeparserPrimitive { }

/// A deparser emit operation, representing a copy by the deparser of the
/// contents of some location (ultimately backed by a PHV container) to the
/// output packet.
class Emit : DeparserPrimitive {
    dbprint {
        out << "emit " << source->toString() << " if " << povBit->toString();
    }

    // XXX(seth): Just like for Extracts, it'd be ideal to constrain the type of
    // `source` and `povBit` a little more, but for now we need to support
    // TempVars and Slices in addition to Members.

    /// The location to be copied into the output packet. Must be backed by a
    /// PHV container.
    Expression source;

    /// The POV bit controlling whether the copy happens. Must be backed by a
    /// PHV container.
    Expression povBit;
}

/// A deparser computed checksum operation. This instructs the deparser to
/// compute the checksum of a group of fields and write the result into the
/// output packet.
class EmitChecksum : DeparserPrimitive {
    /// The fields from which the checksum will be computed. May contain either
    /// Members or Slices. Must be backed by a PHV container.
    inline Vector<Expression> sources;

    /// The POV bit controlling whether the checksum is generated and copied to
    /// the output packet. Must be backed by a PHV container.
    Expression povBit;
}

class Deparser : Unit {
    gress_t                             gress;
    inline Vector<DeparserPrimitive>    emits;
    inline NameMap<DeparserIntrinsic>   metadata;
    inline NameMap<Digest>              digests;
#noconstructor
    Deparser(gress_t gr, Parser s);
    Deparser(gress_t gr, P4Control dp);
    int stage() const override { return 999999; /* assumed larger than the number of stages */ }
    gress_t thread() const override { return gress; }
#apply
    toString { return gress ? "egress deparser" : "ingress deparser"; }
}

}  // end namespace BFN
