#emit
#include <boost/optional.hpp>
#include "bf-p4c/common/debug_info.h"
#include "bf-p4c/ir/bitrange.h"
#include "bf-p4c/parde/marshal.h"
#include "bf-p4c/parde/match_register.h"
#end

namespace BFN {

/// Superclass for all unresolved header stack indices.
abstract UnresolvedStackRef : Expression {
#emit
    /// The next available id.
    static size_t nextId;
#end

#noconstructor
    UnresolvedStackRef(Util::SourceInfo si) : Expression(si), id(nextId++) { }
    UnresolvedStackRef() : id(nextId++) { }

    /// @return a clone of this UnresolvedStackRef which does not compare equal
    /// to the original or to any other existing UnresolvedStackRef.
    UnresolvedStackRef makeFresh() const { return clone()->makeFresh(); }
    UnresolvedStackRef makeFresh() {
        id = nextId++;
        return this; }

    size_t id;
}

/// An unresolved reference to a header stack's '.next' property. This is a
/// placeholder until we can resolve it into a concrete index.
class UnresolvedStackNext : UnresolvedStackRef {
#noconstructor
    UnresolvedStackNext(Util::SourceInfo si) : UnresolvedStackRef(si) { }
    UnresolvedStackNext() { }

    dbprint { out << "(unresolved next #" << id << ")"; }
    toString { return "next"; }
}

/// An unresolved reference to a header stack's '.last' property. This is a
/// placeholder until we can resolve it into a concrete index.
class UnresolvedStackLast : UnresolvedStackRef {
#noconstructor
    UnresolvedStackLast(Util::SourceInfo si) : UnresolvedStackRef(si) { }
    UnresolvedStackLast() { }

    dbprint { out << "(unresolved last #" << id << ")"; }
    toString { return "last"; }
}

/// A value that can *conceptually* be read from in the parser. This is a
/// superset of the values that can actually be read from on the hardware.
abstract ParserRVal { }

/// An r-value that represents a read from a range of bits in the input buffer.
/// The coordinate system used will depend on the specific type of
/// `InputBufferRVal`.
abstract InputBufferRVal : ParserRVal {
    /// @return this buffer range as a half-open range of bits in network order.
    nw_bitinterval interval() const { return toHalfOpenRange(range_); }

    /// @return this buffer range as a closed range of bits in network order.
    nw_bitrange range() const { return range_; }

    /// The region represented by this `InputBufferRVal`, expressed as a range of
    /// bits in network order.
    nw_bitrange range_;
}

/// location in the packet data section of the input buffer
class PacketRVal : InputBufferRVal {
    dbprint {
        out << "packet bits " << interval();
    }
}

/// location in the metadata secion of the input buffer
class MetadataRVal : InputBufferRVal {
    dbprint {
        out << "metadata bits " << interval();
    }
}

/// A constant used as an r-value in the parser.
class ConstantRVal : ParserRVal {
    ConstantRVal(mpz_class value) : constant(new IR::Constant(value)) { }
    ConstantRVal(int value) : constant(new IR::Constant(value)) { }
    ConstantRVal(const IR::Type* type, mpz_class value)
      : constant(new IR::Constant(type, value)) { }
    ConstantRVal(Util::SourceInfo si, const IR::Type* type, mpz_class value)
      : ParserRVal(si), constant(new IR::Constant(type, value)) { }

    dbprint { out << "constant " << constant; }

    Constant constant;
}

/// An r-value which is computed in the parser. The source may be an arbitrary
/// expression. These generally can't be implemented directly on any existing
/// Barefoot hardware, so if the compiler can't optimize them out, compilation
/// will fail.
class ComputedRVal : ParserRVal {
    dbprint { out << "computed value " << source; }

    /// An expression which should evaluate to an r-value usable in the parser.
    Expression source;
}

/// Common base class for parser write destination
abstract ParserLVal {
    toString { return field->toString(); }

    int size() const { return field->type->width_bits(); }

    validate {
        CHECK_NULL(field);
        BUG_CHECK(field->is<IR::Member>() || field->is<IR::TempVar>() ||
                  field->is<IR::Slice>() || field->is<IR::ConcreteHeaderRef>() ||
                  field->is<IR::Concat>(),
                  "FieldLVal contains unexpected value: %1%", field);
    }

    Expression field;
}

/// Parser write dest that will ultimately be backed by a PHV container.
class FieldLVal : ParserLVal {
    dbprint { out << field; }
}

/// Parser write dest that will be backed by non-PHV container.
class ChecksumLVal : FieldLVal {
    dbprint { out << "checksummed " << field; }
}

// Total container size (in byte) for a given set of fields.
// This is useful if we need PHV allocation to derive the size.
class TotalContainerSize : ParserRVal {
    dbprint { out << toString(); }
    toString { return "total size of containers for fields"; }

    inline Vector<FieldLVal> fields;
}

/// Supertype for all parser primitives - i.e., actions that can be executed in
/// parser states.
abstract ParserPrimitive { }

/// A parser extraction operation, representing a write by the parser into some
/// l-value.
class Extract : ParserPrimitive {
    Extract(Expression dest, ParserRVal source)
      : dest(new FieldLVal(dest)), source(source) { }
    Extract(Util::SourceInfo si, Expression dest, ParserRVal source)
      : ParserPrimitive(si), dest(new FieldLVal(dest)), source(source) { }

    dbprint { out << "extract " << source << " to " << dest; }

    /// The location to be written to.
    ParserLVal dest;

    /// The location that will be read from.
    ParserRVal source;

    /// This extract expects that data on the wire is marshaled from a `field`.
    optional boost::optional<MarshaledFrom> marshaled_from;  // not visited
}

/// Save data from input buffer to a match register.
class SaveToRegister : ParserPrimitive {
#emit
    SaveToRegister(const MatchRegister& reg, nw_byterange source)
      : source(new PacketRVal(source.toUnit<RangeUnit::Bit>())), dest(reg) { }
#end
    dbprint { out << "save " << source << " to " << dest.name; }

    /// The location that will be read from.
    InputBufferRVal source;

    /// The register this save writes to.
    MatchRegister dest;
};

class ParserPrioritySet : ParserPrimitive {
    dbprint { out << "priority set " << val; }
    unsigned val;
}

abstract ParserChecksumPrimitive : ParserPrimitive {
    cstring declName;
}

class ChecksumVerify : ParserChecksumPrimitive {
    dbprint { out << "verify checksum"; }
    optional NullOK FieldLVal dest;
}

class ChecksumUpdate : ParserChecksumPrimitive {
    dbprint { out << "update checksum"; }
    FieldLVal dest;
}

class ChecksumGet : ParserChecksumPrimitive {
    dbprint { out << "get checksum"; }
    FieldLVal dest;
}

class ChecksumAdd : ParserChecksumPrimitive {
    dbprint { out << "add " << source << " to checksum"; }
    PacketRVal source;
    bool isHeaderChecksum;
}

class ChecksumSubtract : ParserChecksumPrimitive {
    dbprint { out << "subtract " << source << " from checksum"; }
    PacketRVal source;
    bool isPayloadChecksum;
}

abstract ParserMatchValue { }

class ParserConstMatchValue : ParserMatchValue {
    /// The ternary expression being matched, given as a pair of bitmasks:
    /// (word0, word1). The ternary expression cares about the value of an
    /// input bit if the corresponding bit is set in exactly one of the
    /// bitmasks. If it is set in word0, then the input must have a 0 in that
    /// position. Otherwise, if it is set in word1, then the input must have a
    /// 1 in that position. More formally, the ternary expression matches when
    /// the following expression is true:
    ///     (input ^ word1) & (word0 ^ word1) == 0
    match_t value;
    dbprint { out << "const: " << value; }
}

/// One PVS is value vector that is matched against ALL select fields in that states.
class ParserPvsMatchValue : ParserMatchValue {
#emit
    using FieldSlice = std::pair<cstring, nw_bitrange>;
    using MatcherSlice = std::pair<MatchRegister, le_bitrange>;
    ordered_map<FieldSlice, MatcherSlice> mapping;
#end
    cstring name;
    int size;
    dbprint { out << "name: " << name << " " << size; }
}

/// Phase0 representation in the parser. The phase0 or port metadata can be
/// represented through a table in P4-14 or parser extract/extern in P4-16. In
/// both cases, the representation is converted to a Phase0 node for the backend.
class Phase0 {
    IR::IndexedVector<IR::StructField> fields;
    int size;
    int handle;
    cstring tableName;
    cstring actionName;
    cstring keyName;

    dbprint {
        out << "phase0: tableName: " << tableName
                << " size: " << size << " handle: 0x " << hex(handle) << std::endl;
        out << "actionName: " << actionName << " keyName: " << keyName << " fields: " << fields; }
}

/// The high-level representation of a parser state transition.
class Transition {
#emit
    Transition(match_t v)
        : value(new ParserConstMatchValue(v)), next(nullptr) { }
    Transition(match_t v, boost::optional<int> shift)
        : value(new ParserConstMatchValue(v)), shift(shift), next(nullptr) { }
    Transition(match_t v, boost::optional<int> shift, const ParserState* next)
        : value(new ParserConstMatchValue(v)), shift(shift), next(next) { }
#end
    /// The owning state's select expressions evaluate to a value which
    /// matches this...
    ParserMatchValue               value;

    /// ...then shift the input buffer by this number of bytes (or boost::none
    /// if we don't know how many bytes we need to shift by yet)...
    boost::optional<int>           shift;

    /// ...and transition to this state (or, if null, end the parser program).
    NullOK ParserState             next;

    /// The save to registers need to perform for this transition.
    optional inline Vector<SaveToRegister>  saves;
}

/// A parser selection operation. These represent a load of a value from some
/// source which will be compared against the state's Transitions to select the
/// next state to transition to.
class Select {
    Select(ParserRVal source, Expression p4Source)
        : Node(p4Source->srcInfo), source(source), p4Source(p4Source) { }

    /// The value which will be matched against.
    ParserRVal source;

    /// The register match against.
    optional std::vector<std::pair<MatchRegister, nw_bitrange>> reg_slices;

#emit
    /// The higher-level expression we were selecting against. Not visited.
    const Expression* p4Source = nullptr;
#end
}

/// A high-level parser state. Contains primitives which operate on fields and
/// field-like objects.
class ParserState : Unit {
    ParserState(IR::ParserState p4State, cstring name, gress_t gr)
        : p4State(p4State), name(name), gress(gr) { }

    int stage() const override { return -1; }
    gress_t thread() const override { return gress; }
    toString { return name; }
    visit_children {
        statements.visit_children(v);
        selects.visit_children(v);
        transitions.parallel_visit_children(v); }

#emit
    /// The original P4 state. Null if this is a generated state that doesn't
    /// correspond to anything in the P4 program. Not visited.
    const IR::ParserState* p4State = nullptr;

    /// Debugging information about the P4 state or states that were used to
    /// generate this ParserState.
    ::BFN::DebugInfo debug;
#end

    cstring name;
    gress_t gress;
    inline Vector<ParserPrimitive> statements;
    inline Vector<Select> selects;
    inline Vector<Transition> transitions;
}

/// The supertype for all BFN IR parsers.
abstract AbstractParser : Unit {
#apply
    int stage() const override { return -1; }
    gress_t thread() const override { return gress; }

    gress_t gress;
}

/// The high-level representation of a parser. This is the representation used
/// prior to PHV allocation. It contains primitives which operate on fields and
/// field-like objects; some operands may be expressions that can't yet be
/// evaluated.
class Parser : AbstractParser {
#apply
    toString { return gress ? "egress parser" : "ingress parser"; }

    ParserState start;
    optional NullOK Phase0 phase0; // only valid for ingress
    optional inline std::vector<int> portmap;  // used for multiple parser support
}

/// A list of fields which will be written into a buffer as part of a deparser
/// digest.
class DigestFieldList {
    /// Index of this field list in the digest table
    int idx;

    /// The fields to be copied into the buffer.
    inline Vector<FieldLVal> sources;

    /// Learning needs control plane name for the field list.
    optional cstring controlPlaneName;
}

/// A deparser digest. Each digest writes one of several lists of fields into a
/// special hardware buffer, with the list to be used chosen by the value of a
/// selector field.
class Digest {
    Digest(cstring name) : name(name) { }
    Digest(cstring name, FieldLVal selector) : name(name), selector(selector) { }
    Digest(cstring name, Expression selector)
        : name(name), selector(new FieldLVal(selector)) { }

    /// The name of the digest, identifying a special buffer to be filled in by
    /// the deparser hardware. The name is chosen to match the corresponding
    /// assembly directive, which in turn is named based on definitions in the
    /// CSRs.
    cstring name;

    /// The field which controls which field list will be written into the
    /// buffer. Selector is nullptr when only one field list is supported.
    /// For example, tofino2 pktgen only supports one field list.
    optional NullOK FieldLVal selector;

    /// The available field lists
    inline Vector<DigestFieldList> fieldLists;

    /// If present, the POV bit controlling whether the contents of the source
    /// location are valid. Not used on Tofino.
    NullOK FieldLVal povBit = nullptr;
}

/// Supertype for all deparser primitives - i.e., actions that can be executed
/// in a deparser control.
abstract DeparserPrimitive { }

/// Common abstract base class for all deparser emit types
abstract Emit : DeparserPrimitive {
    Emit(Expression povBit)
      : povBit(new FieldLVal(povBit)) { }
    Emit(Util::SourceInfo si, Expression povBit)
      : DeparserPrimitive(si), povBit(new FieldLVal(povBit)) { }

    /// The POV bit this emit is predicated on
    FieldLVal povBit;
}

/// A deparser emit operation, representing a copy by the deparser of the
/// contents of some location (ultimately backed by a PHV container) to the
/// output packet.
class EmitField : Emit {
    EmitField(Expression source, Expression povBit)
      : Emit(povBit), source(new FieldLVal(source)) { }
    EmitField(Util::SourceInfo si, Expression source, Expression povBit)
      : Emit(si, povBit), source(new FieldLVal(source)) { }

    dbprint {
        out << "emit " << source->field->toString()
            << " if " << povBit->field->toString();
    }

    /// The location to be copied into the output packet.
    FieldLVal source;
}

/// A deparser emit operation, representing a copy by the deparser of the
/// contents of some location (ultimately backed by a CLOT) to the
/// output packet.
class EmitClot : Emit {
    dbprint {
        out << "emit clot " << clot->tag << " if " << povBit->field->toString();
    }

#emit
    Clot* clot = nullptr;
#end
}

/// A deparser computed checksum operation. This instructs the deparser to
/// compute the checksum of a group of fields and write the result into the
/// output packet.
class EmitChecksum : Emit {
    /// The fields from which the checksum will be computed.
    inline Vector<FieldLVal> sources;

    ChecksumLVal dest;
}

/// Configures the location from which an intrinsic deparser parameter should
/// obtain its value.
class DeparserParameter {
    DeparserParameter(cstring name, Expression source)
      : name(name), source(new FieldLVal(source)), povBit(nullptr) { }
    DeparserParameter(Util::SourceInfo si, cstring name, Expression source)
      : Node(si), name(name), source(new FieldLVal(source)), povBit(nullptr) { }

    dbprint {
        out << "parameter " << name << " = " << source->field->toString();
        if (povBit) out << " if " << povBit->field->toString();
    }

    /// The deparser parameter to configure. The name is the one used in the
    /// assembly, which in turn derives from the CSR register name.
    cstring name;

    /// The location to read the parameter value from.
    FieldLVal source;

    /// If present, the POV bit controlling whether the contents of the source
    /// location are valid. Not used on Tofino.
    NullOK FieldLVal povBit = nullptr;
}

/// The supertype for all BFN IR deparsers.
abstract AbstractDeparser : Unit {
#apply
    int stage() const override { return std::numeric_limits<int>::max(); }
    gress_t thread() const override { return gress; }

    gress_t gress;
}

class Deparser : AbstractDeparser {
#noconstructor
    Deparser(gress_t gr) : AbstractDeparser(gr) {}
#apply
    toString { return gress ? "egress deparser" : "ingress deparser"; }

    inline Vector<Emit>                 emits;
    inline Vector<DeparserParameter>    params;
    inline NameMap<Digest>              digests;
}

}  // end namespace BFN
