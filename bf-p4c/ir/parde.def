#emit
#include <boost/optional.hpp>
#include "bf-p4c/ir/bitrange.h"
#end

namespace BFN {

/// An expression representing a `packet_in.lookahead()` call at the P4 level.
/// The interface is very similar to ExtractBuffer, and that's not a
/// coincidence, since the two concepts are very closely related.
class LookaheadExpression : Expression {
#noconstructor
    LookaheadExpression(Util::SourceInfo si, nw_bitrange range)
        : Expression(si), range(range) { }
    LookaheadExpression(nw_bitrange range) : range(range) { }

    dbprint {
        out << "lookahead " << bitInterval() << "(" << range.size() << "b)";
    }

    void setBitRange(nw_bitrange newRange) { range = newRange; }

    /// @return the half-open range of bits being extracted, in network order.
    nw_bitinterval bitInterval() const { return toHalfOpenRange(range); }

    /// @return the closed range of bits being extracted, in network order.
    nw_bitrange bitRange() const { return range; }

    /// The region of the input buffer which will be extracted, expressed in
    /// bits in network order.
    nw_bitrange range;
}

/// Superclass for all unresolved header stack indices.
abstract UnresolvedStackRef : Expression {
#emit
    /// The next available id.
    static size_t nextId;
#end

#noconstructor
    UnresolvedStackRef(Util::SourceInfo si) : Expression(si), id(nextId++) { }
    UnresolvedStackRef() : id(nextId++) { }

    /// @return a clone of this UnresolvedStackRef which does not compare equal
    /// to the original or to any other existing UnresolvedStackRef.
    UnresolvedStackRef makeFresh() const {
        auto* newRef = this->clone();
        newRef->id = nextId++;
        return newRef;
    }

    size_t id;
}

/// An unresolved reference to a header stack's '.next' property. This is a
/// placeholder until we can resolve it into a concrete index.
class UnresolvedStackNext : UnresolvedStackRef {
#noconstructor
    UnresolvedStackNext(Util::SourceInfo si) : UnresolvedStackRef(si) { }
    UnresolvedStackNext() { }

    dbprint { out << "(unresolved next #" << id << ")"; }
    toString { return "next"; }
}

/// An unresolved reference to a header stack's '.last' property. This is a
/// placeholder until we can resolve it into a concrete index.
class UnresolvedStackLast : UnresolvedStackRef {
#noconstructor
    UnresolvedStackLast(Util::SourceInfo si) : UnresolvedStackRef(si) { }
    UnresolvedStackLast() { }

    dbprint { out << "(unresolved last #" << id << ")"; }
    toString { return "last"; }
}

/// Supertype for all parser primitives - i.e., actions that can be executed in
/// parser states.
abstract ParserPrimitive { }

/// A parser extraction operation, representing a write by the parser into some
/// location which will be ultimately backed by a PHV container.
abstract Extract : ParserPrimitive {
    validate { CHECK_NULL(dest); }

    // XXX(seth): It'd be ideal to constrain the type of `dest` a little more.
    // It's normally a field, represented by an Member, but right now we
    // sometimes extract into TempVars, and we represent partial writes using an
    // Slice, so we need a more general type.

    /// The location to be written to. Must be backed by a PHV container.
    Expression dest;
}

/// An extraction from the input buffer.
class ExtractBuffer : Extract {
#noconstructor
    ExtractBuffer(Util::SourceInfo si, Expression dest, nw_bitrange range)
        : Extract(si, dest), range(range) { }
    ExtractBuffer(Expression dest, nw_bitrange range)
        : Extract(dest), range(range) { }

    dbprint {
        out << "extract bits " << bitInterval() << "(" << range.size()
            << "b) to " << dest;
    }

    /// @return true if some of the bits being extracted were already shifted
    /// out of the input buffer.
    bool isShiftedOut() const { return range.lo < 0; }

    /// @return the half-open range of bits being extracted, in network order.
    nw_bitinterval bitInterval() const { return toHalfOpenRange(range); }

    /// @return the closed range of bits being extracted, in network order.
    nw_bitrange extractedBits() const { return range; }

    /// The region of the input buffer which will be extracted, expressed in
    /// bits in network order.
    nw_bitrange range;
}

/// An extraction of a constant.
class ExtractConstant : Extract {
#noconstructor
    ExtractConstant(Util::SourceInfo si, Expression dest, Constant constant)
        : Extract(si, dest), constant(constant) { }
    ExtractConstant(Expression dest, Constant constant)
        : Extract(dest), constant(constant) { }

    validate { CHECK_NULL(constant); }
    dbprint { out << "extract constant " << constant << " to " << dest; }

    /// The constant to extract.
    Constant constant;
}

/// An extraction of some computed value. The source may be an arbitrary
/// expression. These can't be implemented directly on Tofino, so if the
/// compiler can't optimize them out, compilation will fail.
class ExtractComputed : Extract {
#noconstructor
    ExtractComputed(Util::SourceInfo si, Expression dest, Expression source)
        : Extract(si, dest), source(source) { }
    ExtractComputed(Expression dest, Expression source)
        : Extract(dest), source(source) { }

    validate { CHECK_NULL(source); }
    dbprint { out << "extract computed value " << source << " to " << dest; }

    /// An expression which computes the value to be extracted.
    Expression source;
}

/// A parser primitive we don't handle. This is used to propagate knowledge of
/// the failure through the compiler.
class UnhandledParserPrimitive : ParserPrimitive {
#noconstructor
    UnhandledParserPrimitive(Util::SourceInfo si, Node unhandled)
        : ParserPrimitive(si), unhandled(unhandled) { }
    UnhandledParserPrimitive(Node unhandled)
        : unhandled(unhandled) { }

    validate { CHECK_NULL(unhandled); }
    dbprint { out << "unhandled parser primitive: " << unhandled ; }

#emit
    /// The primitive we didn't recognize or couldn't handle. Not visited.
    const Node* unhandled;
#end
}

/// The high-level representation of a parser state transition. Contains
/// primitives which operate on fields and field-like objects.
class ParserMatch {
#noconstructor
    ParserMatch(match_t value, const Vector<ParserPrimitive>& statements)
        : value(value), stmts(statements), next(nullptr) {}
#emit
    ParserMatch(match_t value, boost::optional<int> shift,
                const Vector<ParserPrimitive>& statements)
        : value(value), shift(shift), stmts(statements), next(nullptr) { }
    ParserMatch(match_t value, boost::optional<int> shift, const ParserState* next)
        : value(value), shift(shift), next(next) { }
    ParserMatch(match_t value, boost::optional<int> shift, const ParserState* next,
                const Vector<ParserPrimitive>& statements)
        : value(value), shift(shift), stmts(statements), next(next) { }
#end

    match_t                        value;
    boost::optional<int>           shift;
    inline Vector<ParserPrimitive> stmts;
    NullOK ParserState             next;
}

/// Supertype for all parser transition primitives. These are operations which
/// are used by the parser to determine which state to transition to next.
abstract TransitionPrimitive { }

/// Supertype for all parser selection operations. These represent a load of a
/// value from some source which will be compared against the ParserMatch values
/// to select a transition.
abstract Select : TransitionPrimitive { }

/// A selection against a range of bits in the input buffer.
class SelectBuffer : Select {
#noconstructor
    SelectBuffer(Util::SourceInfo si, nw_bitrange range, Node source)
        : Select(si), range(range), source(source) { }
    SelectBuffer(Util::SourceInfo si, nw_bitrange range)
        : SelectBuffer(si, range, nullptr) { }
    SelectBuffer(nw_bitrange range, Node source)
        : range(range), source(source) { }
    SelectBuffer(nw_bitrange range)
        : SelectBuffer(range, nullptr) { }

    dbprint {
        out << "match bits " << bitInterval() << "(" << range.size() << "b)";
    }

    /// @return true if some of the bits being selected were already shifted
    /// out of the input buffer.
    bool isShiftedOut() const { return range.lo < 0; }

    /// @return the half-open range of bits being selected, in network order.
    nw_bitinterval bitInterval() const { return toHalfOpenRange(range); }

    /// @return the closed range of bits being selected, in network order.
    nw_bitrange selectedBits() const { return range; }

    /// The region of the input buffer which will be selected against, expressed
    /// in bits in network order.
    nw_bitrange range;

#emit
    /// The higher-level expression we were selecting against. Not visited.
    const Node* source;
#end
}

/// A selection against a computed value. The source may be an arbitrary
/// expression. These can't be implemented directly on Tofino, so if the
/// compiler can't optimize them out, compilation will fail.
class SelectComputed : Select {
#noconstructor
    SelectComputed(Util::SourceInfo si, Expression source)
        : Select(si), source(source) { }
    SelectComputed(Expression source) : source(source) { }

    validate { CHECK_NULL(source); }
    dbprint { out << "match computed value " << source; }

    /// An expression which computes the value to be matched against.
    Expression source;
}

/// A transition primitive that we don't handle. This is used to propagate
/// knowledge of the failure through the compiler.
class UnhandledTransitionPrimitive : TransitionPrimitive {
#noconstructor
    UnhandledTransitionPrimitive(Util::SourceInfo si, Node unhandled)
        : TransitionPrimitive(si), unhandled(unhandled) { }
    UnhandledTransitionPrimitive(Node unhandled)
        : unhandled(unhandled) { }

    validate { CHECK_NULL(unhandled); }
    dbprint { out << "unhandled transition primitive: " << unhandled ; }

#emit
    /// The primitive we didn't recognize or couldn't handle. Not visited.
    const Node* unhandled;
#end
}

/// A high-level parser state. Contains primitives which operate on fields and
/// field-like objects.
class ParserState : Unit {
#noconstructor
    ParserState(IR::ParserState p4State, cstring name, gress_t gr)
        : p4State(p4State), name(name), gress(gr) { }
    ParserState(cstring n, gress_t gr,
                std::initializer_list<TransitionPrimitive> sel,
                std::initializer_list<ParserMatch> m)
        : name(n), gress(gr), select(sel), match(m) { }
    int stage() const override { return -1; }
    gress_t thread() const override { return gress; }
    toString { return name; }
    visit_children {
        select.visit_children(v);
        match.parallel_visit_children(v); }

#emit
    /// The original P4 state. Null if this is a generated state that doesn't
    /// correspond to anything in the P4 program. Not visited.
    const IR::ParserState* p4State = nullptr;
#end

    cstring                            name;
    gress_t                            gress;
    inline Vector<TransitionPrimitive> select;
    inline Vector<ParserMatch>         match;
}

/// The supertype for all BFN IR parsers.
abstract AbstractParser {
#noconstructor
    AbstractParser(gress_t gr) : gress(gr) { }
#apply

    gress_t gress;
}

/// The high-level representation of a parser. This is the representation used
/// prior to PHV allocation. It contains primitives which operate on fields and
/// field-like objects; some operands may be expressions that can't yet be
/// evaluated.
class Parser : AbstractParser {
#noconstructor
    Parser(gress_t gress, ParserState start)
        : AbstractParser(gress), start(start) {}
#apply
    toString { return gress ? "egress parser" : "ingress parser"; }

    ParserState start;
}

class Digest {
    gress_t                             gress;
    cstring                             name;
    TempVar                             select;
    std::vector<Vector<Expression>>     sets;
#noconstructor
    Digest(gress_t gress, cstring name) : gress(gress), name(name),
        select(new TempVar(Type::Bits::get(3), cstring("$" + name))) {}
    visit_children {
        v.visit(select, "select");
        for (auto &s : sets)
            v.visit(s, "set"); }
}

/// Supertype for all deparser primitives - i.e., actions that can be executed
/// in a deparser control.
abstract DeparserPrimitive { }

/// A deparser emit operation, representing a copy by the deparser of the
/// contents of some location (ultimately backed by a PHV container) to the
/// output packet.
class Emit : DeparserPrimitive {
    dbprint {
        out << "emit " << source->toString() << " if " << povBit->toString();
    }

    // XXX(seth): Just like for Extracts, it'd be ideal to constrain the type of
    // `source` and `povBit` a little more, but for now we need to support
    // TempVars and Slices in addition to Members.

    /// The location to be copied into the output packet. Must be backed by a
    /// PHV container.
    Expression source;

    /// The POV bit controlling whether the copy happens. Must be backed by a
    /// PHV container.
    Expression povBit;
}

/// A deparser computed checksum operation. This instructs the deparser to
/// compute the checksum of a group of fields and write the result into the
/// output packet.
class EmitChecksum : DeparserPrimitive {
    /// The fields from which the checksum will be computed. May contain either
    /// Members or Slices. Must be backed by a PHV container.
    inline Vector<Expression> sources;

    /// The POV bit controlling whether the checksum is generated and copied to
    /// the output packet. Must be backed by a PHV container.
    Expression povBit;
}

class Deparser : Unit {
    gress_t                             gress;
    inline Vector<DeparserPrimitive>    emits;
    NullOK Expression                   egress_port;
    inline NameMap<Digest>              digests;
#noconstructor
    Deparser(gress_t gr, Parser s);
    Deparser(gress_t gr, P4Control dp);
    int stage() const override { return 999999; /* assumed larger than the number of stages */ }
    gress_t thread() const override { return gress; }
#apply
    toString { return gress ? "egress deparser" : "ingress deparser"; }
}

}  // end namespace BFN
