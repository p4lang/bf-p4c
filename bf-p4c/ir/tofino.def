#emit
#include "bf-p4c/common/debug_info.h"
#include "bf-p4c/ir/bitrange.h"
#include "bf-p4c/ir/gress.h"
#include "bf-p4c/parde/clot.h"
#include "bf-p4c/phv/phv.h"

struct StageUse {
    static constexpr int MAX_STAGES = 12;
    static constexpr int MAX_LOGICAL_IDS = 16;
    static constexpr int MAX_SRAMS = 80;
    static constexpr int MAX_TCAMS = 24;
    static constexpr int MAX_MAPRAMS = 48;
    static constexpr int MAX_IXBAR_BYTES = 128;
    static constexpr int MAX_TERNARY_GROUPS = 12;
};

namespace BFN {
struct HeaderStackInfo;
struct Phase0Info;
}  // namespace BFN
#end

#emit_impl
#include "bf-p4c/ir/thread_visitor.h"
#end

class BFN::Pipe {
    inline NameMap<HeaderOrMetadata> metadata;  // not visited
    inline std::vector<Annotation> global_pragmas;  // not visited
#noconstructor
    Pipe() = default;
    class thread_t {
        BFN::AbstractParser parser = nullptr;
        MAU::TableSeq mau = nullptr;
        BFN::AbstractDeparser deparser = nullptr;
        operator== { return parser == a.parser && mau == a.mau && deparser == a.deparser; }
        toJSON {
            json << json.indent << "\"parser\" : " << parser << "," << std::endl
                 << json.indent << "\"mau\" : " << mau << "," << std::endl
                 << json.indent << "\"deparser\" : " << deparser; }
        fromJSON {
            IR::BFN::Pipe::thread_t * thread = new IR::BFN::Pipe::thread_t();
            json.load("parser", thread->parser);
            json.load("mau", thread->mau);
            json.load("deparser", thread->deparser);
            return thread;
        }
    }
    thread_t[2] thread = {};  // INGRESS and EGRESS
    NullOK MAU::TableSeq ghost_thread = nullptr;  // GHOST -- just mau, no parser or deparser

#emit
    /// If non-null, the phase 0 metadata for this pipe.
    ::BFN::Phase0Info* phase0Info = nullptr;

    /// If non-null, information about header stack usage in this pipe.
    ::BFN::HeaderStackInfo* headerStackInfo = nullptr;
#end

#apply
    operator== { return metadata == a.metadata &&
                        phase0Info == a.phase0Info &&
                        headerStackInfo == a.headerStackInfo &&
                        thread[0] == a.thread[0] &&
                        thread[1] == a.thread[1] &&
                        ghost_thread == a.ghost_thread; }
    visit_children {
        if (auto *th = dynamic_cast<ThreadVisitor *>(&v)) {
            if (th->thread == GHOST) {
                v.visit(ghost_thread, "ghost_thread");
            } else {
                v.visit(thread[th->thread].parser, "parser");
                v.visit(thread[th->thread].mau, "mau");
                v.visit(thread[th->thread].deparser, "deparser"); }
        } else {
            for (auto &th : thread) {
                v.visit(th.parser, "parser");
                v.visit(th.mau, "mau");
                v.visit(th.deparser, "deparser"); }
            v.visit(ghost_thread, "ghost_thread"); } }
}

abstract BFN::Unit {
    /* Abstract base class for any of
       - parser state
       - mau logical table
       - deparser
       A packet running through a tofino pipe executes a sequence of Units in order;
       each Unit completes before the next executes.  All accesses of PHV containers
       are associated with a particular Unit.  */
    virtual gress_t thread() const = 0;
    virtual int stage() const = 0;
}

class InstanceRef : HeaderRef {
    ID                          name;
    NullOK HeaderOrMetadata     obj;
    inline NameMap<InstanceRef> nested;
#noconstructor
    InstanceRef(cstring prefix, ID n, Type t, bool forceMeta = false);
    InstanceRef(ID n, Type t, bool forceMeta = false) : InstanceRef(cstring(), n, t, forceMeta) {}
    InstanceRef(Type t) : HeaderRef(t) { }
    HeaderOrMetadata baseRef() const override { return obj; }
    toString { return obj ? obj->name : name; }
    dbprint { out << toString(); }
}

/** A normal InstanceRef preserves the instance structure in the name of the
 * object it constructs, eg. struct.hdr.field becomes three nested
 * InstanceRefs, with names "struct", "struct.hdr", and "struct.hdr.field".
 * This preserves the name qualifications and prevents name conflicts.
 *
 * These fully-qualified names are also exposed to the control plane in a few
 * places:
 *
 *  - In table match keys, unless a @name annotation removes the qualification.
 *  - In PHV field names, which impacts digests as well as the snapshot
 *    mechanism.
 *
 * Unfortunately, existing P4_14 control-plane code was written to assume that
 * all of the prefix up to "hdr.field" would be removed.  For now, we use
 * V1InstanceRef to preserve that behavior.
 */
class V1InstanceRef : InstanceRef {
#noconstructor
    V1InstanceRef(cstring prefix, ID n, Type t, bool forceMeta = false);
    V1InstanceRef(ID n, Type t, bool forceMeta = false) : V1InstanceRef(cstring(), n, t, forceMeta) {}
    toString { return obj ? obj->name : name; }
    dbprint { out << toString(); }
}

class MetadataInfo {
    bool forTM;
    gress_t gress;
    cstring type_name;
    cstring instance_name;
    cstring field_name;
    dbprint { out << instance_name << "." << field_name; }
}


/** An abstract class that represents values in the back end, including header
 * and struct fields, slices, temporary variables, literals, etc.
 *
 * NB: This is a work in progress, as we slowly transition from using
 * IR::Expression (which is a v1.def IR node) to IR::BFN::Value.
 * 
 * In the back end, all expressions are converted to values and instructions.
 * For example,
 *  
 *    ipv4.ttl = ipv4.ttl - 1
 *
 * becomes
 *
 *    sub(ipv4.ttl, ipv4.ttl, 1)
 *
 * where `sub` is an instruction, and `ipv4.ttl` and `1` are values.
 */
abstract BFN::Value : IR::Expression { }


/** An abstract class that represents references to values that must be stored
 * in PHV containers or other sundry types of memory in Barefoot hardware.
 *
 * This includes fields of header and metadata instances as well as temporary
 * variables.  It also includes PHV containers themselves, as some back end
 * transformations replace collections of references to field instances with
 * the PHV containers in which they reside. */
abstract BFN::Reference : BFN::Value {
#emit
    /// Debugging information about the object referred to by this reference.
    ::BFN::DebugInfo debug;
#end
}


/** A temporary variable introduced by the compiler, which must be assigned to
 * a PHV container. */
class TempVar : BFN::Reference {
    bool        POV;
    cstring     name;
    static int  uid;
#noconstructor
    TempVar(Type t, bool p = false, cstring n = cstring()) : BFN::Reference(t), POV(p), name(n) {
        if (!name) {
            std::string n("$tmp");
            n += std::to_string(++uid);
            name = n; } }
    TempVar(Type t, cstring n) : TempVar(t, false, n) {}
    toString { return name; }
    dbprint { out << name; }
}


/** A reference to a PHV container.  At the hardware level, Barefoot switches
 * operate over PHV containers, not header/metadata fields, and the back end
 * eventually lowers operations to work on PHV containers directly.
 *
 * NB: This is a work in progress; not all operations are lowered to operate on
 * containers directly.  See parde-lowered.def for examples.
 */
class BFN::ContainerRef : BFN::Reference {
#emit
    // We tag ContainerRefs with unique identifiers to structurally distinguish
    // different references to the same container.
    static size_t nextId;
#end

    PHV::Container container;
    size_t id;

#noconstructor
    ContainerRef(PHV::Container c) : BFN::Reference(), container(c), id(nextId++) { }
    ContainerRef(Util::SourceInfo si, PHV::Container c)
    : BFN::Reference(si), container(c), id(nextId++) { }

    validate {
        BUG_CHECK(bool(container), "Invalid PHV container in ContainerRef");
    }
    toString { return container.toString(); }
    dbprint { out << toString(); }

    /// @return a clone of this ContainerRef which does not compare equal
    /// to the original or to any other existing ContainerRef.
    ContainerRef makeFresh() const {
        auto* newRef = this->clone();
        newRef->id = nextId++;
        return newRef;
    }
}

/// A reference to a single bit within a PHV container. (e.g., a POV bit)
class BFN::ContainerBitRef : BFN::Reference {
    toString { return container->toString() + "(" + std::to_string(bit) + ")"; }
    dbprint { out << toString(); }

    /// The container containing the bit.
    BFN::ContainerRef container;

    unsigned bit;
}

/** When two fields are aliased, we replace one with the other during
 * compilation.  We call the one being removed the alias "source" and the one
 * being inserted in its place the "destination".
 *
 * An AliasMember node represents such a replacement.  The IR::Member part of
 * the node holds the alias destination, but the extra `source` field points to
 * the original alias source.
 */
class BFN::AliasMember : IR::Member {
    /// The original expression (i.e. the alias source) that has been replaced
    /// by this AliasMember.  Not visited in IR traversals.
    Expression source;

    dbprint {
        IR::Member::dbprint(out);
        out << "alias: " << source;
    }

    visit_children {
        IR::Member::visit_children(v);
    }

#emit
    /// A convenience method to construct an AliasMember with source info from
    /// the alias source.
    AliasMember(const IR::Member* destination, const IR::Expression* source)
    : IR::Member(source->srcInfo, destination->type, destination->expr, destination->member),
      source(source) { }
#end
}

/** When two fields are aliased, we replace one with the other during
 * compilation.  We call the one being removed the alias "source" and the one
 * being inserted in its place the "destination".
 *
 * An AliasSlice node represents such a replacement, in the case when an alias
 * source is a field, but the alias destination is a slice of another field.
 * The IR::Slice part of the node holds the alias destination, but the extra
 * `source` field points to the original alias source.
 */
class BFN::AliasSlice : IR::Slice {
    /// The original expression (i.e. the alias source) that has been replaced
    /// by this AliasSlice.  Not visited in IR traversals.
    Expression source;

    dbprint {
        IR::Slice::dbprint(out);
        out << "alias: " << source;
    }

    visit_children {
        IR::Slice::visit_children(v);
    }

#emit
    /// A convenience method to construct an AliasSlice with source info from
    /// the alias source.
    AliasSlice(const IR::Slice* dest, const IR::Expression* source)
    : IR::Slice(source->srcInfo, dest->type, dest->e0, dest->e1, dest->e2), source(source) { }
#end
}
