#emit
#include "bf-p4c/ir/gress.h"

struct StageUse {
    static constexpr int MAX_STAGES = 12;
    static constexpr int MAX_LOGICAL_IDS = 16;
    static constexpr int MAX_SRAMS = 80;
    static constexpr int MAX_TCAMS = 24;
    static constexpr int MAX_MAPRAMS = 48;
    static constexpr int MAX_IXBAR_BYTES = 128;
    static constexpr int MAX_TERNARY_GROUPS = 12;
};

namespace BFN {
struct HeaderStackInfo;
struct Phase0Info;
}  // namespace BFN
#end

#emit_impl
#include "bf-p4c/ir/thread_visitor.h"
#end

class BFN::Pipe {
    inline NameMap<Metadata> metadata;  // not visited
#noconstructor
    Pipe() = default;
    class thread_t {
        BFN::AbstractParser parser = nullptr;
        MAU::TableSeq mau = nullptr;
        BFN::Deparser deparser = nullptr;
        operator== { return parser == a.parser && mau == a.mau && deparser == a.deparser; }
        toJSON {
            json << json.indent << "\"parser\" : " << parser << "," << std::endl
                 << json.indent << "\"mau\" : " << mau << "," << std::endl
                 << json.indent << "\"deparser\" : " << deparser; }
        fromJSON {
            IR::BFN::Pipe::thread_t * thread = new IR::BFN::Pipe::thread_t();
            json.load("parser", thread->parser);
            json.load("mau", thread->mau);
            json.load("deparser", thread->deparser);
            return thread;
        }
    }
    thread_t[2] thread = {};  // INGRESS and EGRESS

#emit
    /// If non-null, the phase 0 metadata for this pipe.
    ::BFN::Phase0Info* phase0Info = nullptr;

    /// If non-null, information about header stack usage in this pipe.
    ::BFN::HeaderStackInfo* headerStackInfo = nullptr;
#end

#apply
    operator== { return metadata == a.metadata &&
                        phase0Info == a.phase0Info &&
                        headerStackInfo == a.headerStackInfo &&
                        thread[0] == a.thread[0] &&
                        thread[1] == a.thread[1]; }
    visit_children {
        if (auto *th = dynamic_cast<ThreadVisitor *>(&v)) {
            v.visit(thread[th->thread].parser, "parser");
            v.visit(thread[th->thread].mau, "mau");
            v.visit(thread[th->thread].deparser, "deparser");
        } else {
            for (auto &th : thread) {
                v.visit(th.parser, "parser");
                v.visit(th.mau, "mau");
                v.visit(th.deparser, "deparser"); } } }
}

abstract BFN::Unit {
    /* Abstract base class for any of
       - parser state
       - mau logical table
       - deparser
       A packet running through a tofino pipe executes a sequence of Units in order;
       each Unit completes before the next executes.  All accesses of PHV containers
       are associated with a particular Unit.  */
    virtual gress_t thread() const = 0;
    virtual int stage() const = 0;
}

class InstanceRef : HeaderRef {
    ID                          name;
    NullOK HeaderOrMetadata     obj;
    inline NameMap<InstanceRef> nested;
#noconstructor
    InstanceRef(cstring prefix, ID n, Type t, bool forceMeta = false);
    InstanceRef(ID n, Type t, bool forceMeta = false) : InstanceRef(cstring(), n, t, forceMeta) {}
    HeaderOrMetadata baseRef() const override { return obj; }
    toString { return obj ? obj->name : name; }
    dbprint { out << toString(); }
}

class TempVar : Expression {
    bool        POV;
    cstring     name;
    static int  uid;
#noconstructor
    TempVar(Type t, bool p = false, const char *n = 0) : Expression(t), POV(p), name(n) {
        if (!name) {
            std::string n("$tmp");
            n += std::to_string(++uid);
            name = n; } }
    TempVar(Type t, const char *n) : TempVar(t, false, n) {}
    toString { return name; }
    dbprint { out << name; }
}

class MetadataInfo {
    bool forTM;
    gress_t gress;
    cstring type_name;
    cstring instance_name;
    cstring field_name;
    dbprint { out << instance_name << "." << field_name; }
}
