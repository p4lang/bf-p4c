#emit
#include "bf-p4c/common/debug_info.h"
#include "bf-p4c/ir/bitrange.h"
#include "bf-p4c/ir/gress.h"
#include "bf-p4c/parde/clot.h"
#include "bf-p4c/phv/phv.h"

struct StageUse {
    static constexpr int MAX_STAGES = 12;
    static constexpr int MAX_LOGICAL_IDS = 16;
    static constexpr int MAX_SRAMS = 80;
    static constexpr int MAX_TCAMS = 24;
    static constexpr int MAX_MAPRAMS = 48;
    static constexpr int MAX_IXBAR_BYTES = 128;
    static constexpr int MAX_TERNARY_GROUPS = 12;
};

namespace BFN {
struct HeaderStackInfo;
struct Phase0Info;
}  // namespace BFN
#end

#emit_impl
#include "bf-p4c/ir/thread_visitor.h"
#end

class BFN::Pipe {
    inline NameMap<HeaderOrMetadata> metadata;  // not visited
    inline std::vector<Annotation> global_pragmas;  // not visited
#noconstructor
    Pipe() = default;
    class thread_t {
        BFN::AbstractParser parser = nullptr;
        MAU::TableSeq mau = nullptr;
        BFN::AbstractDeparser deparser = nullptr;
        operator== { return parser == a.parser && mau == a.mau && deparser == a.deparser; }
        toJSON {
            json << json.indent << "\"parser\" : " << parser << "," << std::endl
                 << json.indent << "\"mau\" : " << mau << "," << std::endl
                 << json.indent << "\"deparser\" : " << deparser; }
        fromJSON {
            IR::BFN::Pipe::thread_t * thread = new IR::BFN::Pipe::thread_t();
            json.load("parser", thread->parser);
            json.load("mau", thread->mau);
            json.load("deparser", thread->deparser);
            return thread;
        }
    }
    thread_t[2] thread = {};  // INGRESS and EGRESS

#emit
    /// If non-null, the phase 0 metadata for this pipe.
    ::BFN::Phase0Info* phase0Info = nullptr;

    /// If non-null, information about header stack usage in this pipe.
    ::BFN::HeaderStackInfo* headerStackInfo = nullptr;
#end

#apply
    operator== { return metadata == a.metadata &&
                        phase0Info == a.phase0Info &&
                        headerStackInfo == a.headerStackInfo &&
                        thread[0] == a.thread[0] &&
                        thread[1] == a.thread[1]; }
    visit_children {
        if (auto *th = dynamic_cast<ThreadVisitor *>(&v)) {
            v.visit(thread[th->thread].parser, "parser");
            v.visit(thread[th->thread].mau, "mau");
            v.visit(thread[th->thread].deparser, "deparser");
        } else {
            for (auto &th : thread) {
                v.visit(th.parser, "parser");
                v.visit(th.mau, "mau");
                v.visit(th.deparser, "deparser"); } } }
}

abstract BFN::Unit {
    /* Abstract base class for any of
       - parser state
       - mau logical table
       - deparser
       A packet running through a tofino pipe executes a sequence of Units in order;
       each Unit completes before the next executes.  All accesses of PHV containers
       are associated with a particular Unit.  */
    virtual gress_t thread() const = 0;
    virtual int stage() const = 0;
}

class InstanceRef : HeaderRef {
    ID                          name;
    NullOK HeaderOrMetadata     obj;
    inline NameMap<InstanceRef> nested;
#noconstructor
    InstanceRef(cstring prefix, ID n, Type t, bool forceMeta = false);
    InstanceRef(ID n, Type t, bool forceMeta = false) : InstanceRef(cstring(), n, t, forceMeta) {}
    HeaderOrMetadata baseRef() const override { return obj; }
    toString { return obj ? obj->name : name; }
    dbprint { out << toString(); }
}

class MetadataInfo {
    bool forTM;
    gress_t gress;
    cstring type_name;
    cstring instance_name;
    cstring field_name;
    dbprint { out << instance_name << "." << field_name; }
}


/** An abstract class that represents values in the back end, including header
 * and struct fields, slices, temporary variables, literals, etc.
 *
 * NB: This is a work in progress, as we slowly transition from using
 * IR::Expression (which is a v1.def IR node) to IR::BFN::Value.
 * 
 * In the back end, all expressions are converted to values and instructions.
 * For example,
 *  
 *    ipv4.ttl = ipv4.ttl - 1
 *
 * becomes
 *
 *    sub(ipv4.ttl, ipv4.ttl, 1)
 *
 * where `sub` is an instruction, and `ipv4.ttl` and `1` are values.
 */
abstract BFN::Value : IR::Expression { }


/** An abstract class that represents references to values that must be stored
 * in PHV containers or other sundry types of memory in Barefoot hardware.
 *
 * This includes fields of header and metadata instances as well as temporary
 * variables.  It also includes PHV containers themselves, as some back end
 * transformations replace collections of references to field instances with
 * the PHV containers in which they reside. */
abstract BFN::Reference : BFN::Value {
#emit
    /// Debugging information about the object referred to by this reference.
    ::BFN::DebugInfo debug;
#end
}


/** A temporary variable introduced by the compiler, which must be assigned to
 * a PHV container. */
class TempVar : BFN::Reference {
    bool        POV;
    cstring     name;
    static int  uid;
#noconstructor
    TempVar(Type t, bool p = false, const char *n = 0) : BFN::Reference(t), POV(p), name(n) {
        if (!name) {
            std::string n("$tmp");
            n += std::to_string(++uid);
            name = n; } }
    TempVar(Type t, const char *n) : TempVar(t, false, n) {}
    toString { return name; }
    dbprint { out << name; }
}


/** A slice of a reference, most commonly a BFN::Member or BFN::TempVar. */
class BFN::Slice : BFN::Reference {
    BFN::Reference base;
    le_bitrange range;

#noconstructor

    /** Slice constructors that also create a Bit<X> type of the appropriate
     * size if no type is provided.   /// Utility constructors that take hi/lo
     * bits directly.
     */
    Slice(BFN::Reference a, le_bitrange range)
    : BFN::Reference(IR::Type::Bits::get(range.size())), base(a), range(range) { }
    Slice(Util::SourceInfo si, BFN::Reference a, le_bitrange range)
    : BFN::Reference(si, IR::Type::Bits::get(range.size())), base(a), range(range) { }

    /// Utility constructors that build a bitrange from hi/lo bits.
    Slice(BFN::Reference a, int hi, int lo) : BFN::Slice(a, le_bitrange(FromTo(lo, hi))) { }
    Slice(Util::SourceInfo si, BFN::Reference a, int hi, int lo)
    : BFN::Slice(si, a, le_bitrange(FromTo(lo, hi))) { }

    Slice {
        if (type->is<Type::Unknown>())
            type = IR::Type::Bits::get(range.size()); }

    toString {
        return base->toString() + "[" + std::to_string(range.hi) + ":" + std::to_string(range.lo) + "]";
    }
    dbprint { out << toString(); }
}


/** A reference to a PHV container.  At the hardware level, Barefoot switches
 * operate over PHV containers, not header/metadata fields, and the back end
 * eventually lowers operations to work on PHV containers directly.
 *
 * NB: This is a work in progress; not all operations are lowered to operate on
 * containers directly.  See parde-lowered.def for examples.
 */
class BFN::ContainerRef : BFN::Reference {
#emit
    // We tag ContainerRefs with unique identifiers to structurally distinguish
    // different references to the same container.
    static size_t nextId;
#end

    PHV::Container container;
    size_t id;

#noconstructor
    ContainerRef(PHV::Container c) : BFN::Reference(), container(c), id(nextId++) { }
    ContainerRef(Util::SourceInfo si, PHV::Container c)
    : BFN::Reference(si), container(c), id(nextId++) { }

    validate {
        BUG_CHECK(bool(container), "Invalid PHV container in ContainerRef");
    }
    toString { return container.toString(); }
    dbprint { out << toString(); }

    /// @return a clone of this ContainerRef which does not compare equal
    /// to the original or to any other existing ContainerRef.
    ContainerRef makeFresh() const {
        auto* newRef = this->clone();
        newRef->id = nextId++;
        return newRef;
    }
}

/// A reference to a single bit within a PHV container. (e.g., a POV bit)
class BFN::ContainerBitRef : BFN::Reference {
    validate {
        BUG_CHECK(bit.size() == 1,
                  "ContainerBitRef range %1% is not a single bit?", bit);
        BUG_CHECK(le_bitrange(StartLen(0, container->container.size())).contains(bit),
                  "ContainerBitRef bit %1% does not fit within container %2%",
                  bit, container->container);
    }
    toString { return container->toString() + "(" + std::to_string(bit.lo) + ")"; }
    dbprint { out << toString(); }

    /// The container containing the bit.
    BFN::ContainerRef container;

    /// The bit itself, specified in little endian order as a range of size 1.
    /// XXX(seth): It'd be nice to specify it as an index, but we don't have a
    /// strongly typed representation of bit indices right now.
    le_bitrange bit;
}

/// A Member object that maintains aliasing information for the field it is aliased with
class BFN::AliasMember : IR::Member, IAnnotated {
    optional Annotations        annotations = Annotations::empty;
#novalidate
    Annotations getAnnotations() const override { return annotations; }
    dbprint { out << member << ", alias: " << annotations; }
}
