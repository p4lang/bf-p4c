#ifndef EXTENSIONS_BF_P4C_IR_UNIQUE_ID_H_
#define EXTENSIONS_BF_P4C_IR_UNIQUE_ID_H_

#include <iostream>
#include "ir/json_generator.h"
#include "ir/json_loader.h"

/** The purpose of this class is to provide a unique identification of an BackendAttached table
 *  per IR::MAU::Table object.  The only way to guarantee to uniqueness is both by name and
 *  by an associated type.  For example, a P4 object could in theory have multiple counters,
 *  but these counters would have to have separate names.  Also, let's say a selector and
 *  and action profile have the same name (which they do in P4-16).  The types of these
 *  BackendAttached tables would be different.
 *
 *  This id can be generated by any IR::MAU::AttachedMemory object.  Furthermore, it is used
 *  to associate per flow enable bits and meter types. 
 */
class UniqueAttachedId {
 public:
    cstring name;
    enum type_t { INVALID, TERNARY_INDIRECT, IDLETIME, COUNTER, METER, SELECTOR,
                        STATEFUL_ALU, ACTION_DATA } type = INVALID;

    bool operator==(const UniqueAttachedId &uai) const {
        return name == uai.name && type == uai.type;
    }

    bool operator!=(const UniqueAttachedId &uai) const {
        return !(*this == uai);
    }

    bool operator<(const UniqueAttachedId &uai) const {
        if (name != uai.name)
            return name < uai.name;
        if (type != uai.type)
            return type < uai.type;
        return false;
    }

    UniqueAttachedId() {}
    UniqueAttachedId(cstring n, type_t t) : name(n), type(t) {}

    void toJSON(JSONGenerator &json) const {
        json << json.indent << "\"name\": " << name << ",\n"
             << json.indent << "\"type\": " << type << ",\n";
    }

    static UniqueAttachedId fromJSON(JSONLoader &json) {
        UniqueAttachedId uai;
        if (!json.json) return uai;
        json.load("name", uai.name);
        json.load("type", uai.type);
        return uai;
    }

    bool has_meter_type() const {
        return type == METER || type == STATEFUL_ALU || type == SELECTOR;
    }
};

inline std::ostream &operator <<(std::ostream &out, const UniqueAttachedId::type_t type) {
    switch (type) {
        case UniqueAttachedId::TERNARY_INDIRECT:
            out << "TERNARY_INDIRECT"; break;
        case UniqueAttachedId::IDLETIME:
            out << "IDLETIME"; break;
        case UniqueAttachedId::COUNTER:
            out << "COUNTER"; break;
        case UniqueAttachedId::METER:
            out << "METER"; break;
        case UniqueAttachedId::SELECTOR:
            out << "SELECTOR"; break;
        case UniqueAttachedId::STATEFUL_ALU:
            out << "STATEFUL_ALU"; break;
        case UniqueAttachedId::ACTION_DATA:
            out << "ACTION_DATA"; break;
        default:
            out << "INVALID"; break;
    }
    return out;
}

inline bool operator>>(cstring s, UniqueAttachedId::type_t &type) {
    if (!s || s == "" || s == "INVALID")
        type = UniqueAttachedId::INVALID;
    else if (s == "TERNARY_INDIRECT")
        type = UniqueAttachedId::TERNARY_INDIRECT;
    else if (s == "IDLETIME")
        type = UniqueAttachedId::IDLETIME;
    else if (s == "COUNTER")
        type = UniqueAttachedId::COUNTER;
    else if (s == "METER")
        type = UniqueAttachedId::METER;
    else if (s == "SELECTOR")
        type = UniqueAttachedId::SELECTOR;
    else if (s == "STATEFUL_ALU")
        type = UniqueAttachedId::STATEFUL_ALU;
    else if (s == "ACTION_DATA")
        type = UniqueAttachedId::ACTION_DATA;
    else
        return false;
    return true;
}

inline std::ostream &operator <<(std::ostream &out, const UniqueAttachedId &uai) {
    out << uai.name << " " << uai.type;
    return out;
}

#endif /* EXTENSIONS_BF_P4C_IR_UNIQUE_ID_H_ */
