#emit
#include <set>
#include "bf-p4c/common/debug_info.h"
#include "bf-p4c/ir/bitrange.h"
#include "bf-p4c/ir/ir_enums.h"
#include "bf-p4c/parde/clot.h"
#include "bf-p4c/parde/epb_config.h"
#include "bf-p4c/parde/match_register.h"
#include "bf-p4c/phv/phv.h"

namespace BFN {
struct FieldPacking;
}  // namespace BFN
#end

namespace BFN {

/// A value that can be read from in the parser on the hardware.
abstract LoweredParserRVal { }

/// An r-value that represents a read from a range of input buffer bytes (rather
/// than bits, as in the high-level parser IR) in the input buffer. The
/// coordinate system used will depend on the specific type of
/// `LoweredBufferlikeRVal`.
abstract LoweredBufferlikeRVal : LoweredParserRVal {
    validate {
        BUG_CHECK(range.lo >= 0,
                  "Extracting from offset before the start of the input buffer");
    }

    /// @return this buffer range as a half-open range of bytes in network order.
    nw_byteinterval byteInterval() const { return toHalfOpenRange(range); }

    /// @return this buffer range as a closed range of bytes in network order.
    nw_byterange extractedBytes() const { return range; }

    /// The region represented by this `LoweredBufferlikeRVal`, expressed as a
    /// range of bytes in network order.
    nw_byterange range;
}

// An r-value originating from the input packet. Represented as a range of bytes
// in the coordinate system of some parser state. @see PacketRVal for more
// details about the coordinate system.
class LoweredPacketRVal : LoweredBufferlikeRVal {
    dbprint {
        out << "packet bytes " << byteInterval() << "(" << range.size() << "B)";
    }
}

/// An r-value representing a range of bits from the region of the input buffer
/// that's mapped onto special metadata, rather than data from the input packet.
/// @see BufferRVal for more details about the coordinate system.
class LoweredBufferRVal : LoweredBufferlikeRVal {
    dbprint {
        out << "buffer bytes " << byteInterval() << "(" << range.size() << "B)";
    }
}

/// A lowered representation of a constant used as an r-value in the parser.
class LoweredConstantRVal : LoweredParserRVal {
    dbprint { out << "constant " << constant; }

    /// The constant to extract.
    uint32_t constant;
}

abstract LoweredParserPrimitive { }

/// A lowered parser extraction operation, representing a write by the parser
/// into a PHV container.
class LoweredExtractPhv : LoweredParserPrimitive {
#emit
    /// Convenience constructors for accepting a raw PHV::Container.
    LoweredExtractPhv(PHV::Container dest, const LoweredParserRVal* source)
      : source(source), dest(new BFN::ContainerRef(dest)) { }
    LoweredExtractPhv(Util::SourceInfo si, PHV::Container dest,
                   const LoweredParserRVal* source)
      : LoweredParserPrimitive(si), source(source), dest(new BFN::ContainerRef(dest)) { }
    LoweredExtractPhv(const LoweredParserRVal* source)
      : source(source), dest(nullptr) { }
#end

    dbprint { out << "extract " << source << " to " << dest; }
    validate { BUG_CHECK(bool(dest->container), "Invalid PHV container"); }

    /// The location that will be read from.
    LoweredParserRVal source;

    /// The PHV container this extract writes to.
    BFN::ContainerRef dest;

#emit
    /// Debugging information about the high-level operations that are
    /// implemented by this low-level extract.
    ::BFN::DebugInfo debug;
#end
}

class LoweredExtractClot : LoweredParserPrimitive {
#emit
    LoweredExtractClot(Clot dest, const LoweredPacketRVal* source)
      : source(source), dest(dest) { }
    LoweredExtractClot(Util::SourceInfo si, Clot dest,
                   const LoweredPacketRVal* source)
      : LoweredParserPrimitive(si), source(source), dest(dest) { }
#end

    dbprint { out << "extract " << source << " to " << dest; }

    /// The location that will be read from.
    LoweredPacketRVal source;

    /// The clot this extract writes to.
    Clot dest;

#emit
    /// Debugging information about the high-level operations that are
    /// implemented by this low-level extract.
    ::BFN::DebugInfo debug;
#end
}

class LoweredParserChecksum : LoweredParserPrimitive {
    dbprint {
        out << "parser checksum: ";
        out << "unit = "  << unit_id << ", ";
        out << "mask = [";
        for (auto& r : masked_ranges) {
            out << r << ", "; }
        out << "] ";
        out << "swap = "  << swap << ", ";
        out << "start = " << start << ", ";
        out << "end = " << end << ", ";
        out << "type = " << type << ".";
    }

    unsigned unit_id;
    std::vector<nw_byterange> masked_ranges;
    unsigned swap;
    bool start;
    bool end;
    BFN::ChecksumMode type;

    optional NullOK BFN::ContainerBitRef csum_err;
    optional Clot clot_dest;
    optional NullOK BFN::ContainerRef phv_dest;
}

/// A lowered save operation, representing save a bits from input buffer to matchRegisters.
class LoweredSave : LoweredParserPrimitive {
    /// Convenience constructors for accepting a raw source
    LoweredSave(const MatchRegister& reg, const LoweredBufferlikeRVal* source)
      : source(source), dest(reg) { }
    LoweredSave(const MatchRegister& reg, nw_byterange source)
      : source(new LoweredBufferRVal(source)), dest(reg) { }

    dbprint { out << "save " << source << " to " << dest.name; }

    /// The location that will be read from.
    LoweredBufferlikeRVal source;

    /// The register this save writes to.
    MatchRegister dest;
#emit

    /// Debugging information about the high-level operations that are
    /// implemented by this low-level extract.
    ::BFN::DebugInfo debug;
#end
}

/// A lowered parser selection operation. These represent a vector of
/// registers that have data loaded from input buffer in previous states
/// which will be compared against in the state's LoweredParserMatch
/// entries to select the next state to transition to.
class LoweredSelect {
#emit
    explicit LoweredSelect(const std::set<MatchRegister>& regs)
        : regs(regs) { }

    /// The register match against.
    /// XXX(yumin): The order of registers is sorted by MatchRegister::operator<.
    /// We use this order to adjust the match value in AdjustMatchValue pass.
    std::set<MatchRegister> regs;

    /// Debugging information about the high-level operations that are
    /// implemented by this low-level select operation.
    ::BFN::DebugInfo debug;
#end
}

/// The root class for values that a state match against.
abstract LoweredMatchValue { }

/// A static value that is defined in the p4, i.e. not PVS.
class LoweredConstMatchValue : LoweredMatchValue {
    dbprint { out << "const: " << value; }
    match_t value;
}

/// Parser value set(PVS) value.
/// The value_set which will be populated at runtime and matched against
/// the value in the select expression.
class LoweredPvsMatchValue : LoweredMatchValue {
#emit
    using FieldSlice = std::pair<cstring, nw_bitrange>;
    using MatcherSlice = std::pair<MatchRegister, nw_bitrange>;
    std::map<FieldSlice, MatcherSlice> mapping;

    LoweredPvsMatchValue(cstring name, int size, const std::map<FieldSlice, MatcherSlice>& m)
        : mapping(m), name(name), size(size) {}
#end
    dbprint { out << "name: " << name << " " << size; }
    cstring name;
    int size;
}

/// This class represents the operations to perform on a match at
/// the current parser state. Each LoweredParserMatch uses a single
/// TCAM row in the parser for constant matches, and multiple TCAM rows
/// for value sets. Operations use a row in their associated action RAMs
/// (Early Action RAM and Checksum Control RAM).
class LoweredParserMatch {
#emit
    LoweredParserMatch(match_t value, unsigned shift, const LoweredParserState* next)
        : value(new IR::BFN::LoweredConstMatchValue(value)),
          shift(shift), bufferRequired(0), next(next) { }
#end
    /// The match value: constant or a value set
    LoweredMatchValue value;

    /// Number of bytes to shift out of input buffer at current state  
    unsigned shift;

    /// Extractions to perform
    inline Vector<LoweredParserPrimitive> statements;

    /// Save match word to registers
    inline Vector<LoweredSave> saves;

    /// Checksum calculations
    inline Vector<LoweredParserChecksum> checksums;

    /// Priority set
    NullOK ParserPrioritySet priority;

    /// The number of packet bytes which must be available in the input buffer
    /// for the extractions to be performed successfully. If `boost::none`,
    /// there is no particular requirement; the assembler will choose a default.
    optional boost::optional<unsigned> bufferRequired;

    /// Next state to transition to (null means terminal state)
    NullOK LoweredParserState next;

#emit
    /// Debugging information about the high-level parser states that were used
    /// to generate this low-level match construct.
    ::BFN::DebugInfo debug;
#end
}

/// A lowered parser state, representing a group of related parser TCAM rows.
/// We do not maintain a 1-to-1 mapping between LoweredParserStates and parser
/// states in the original P4 program.
class LoweredParserState : Unit {
#noconstructor
    LoweredParserState(cstring name, gress_t gress)
        : name(name), gress(gress),
          select(new LoweredSelect(std::set<MatchRegister>())) { }
    int stage() const override { return -1; }
    gress_t thread() const override { return gress; }
    toString { return name; }
    visit_children {
        v.visit(select);
        match.parallel_visit_children(v); }

    /// The name of this state. This does not necessarily correspond to any
    /// state name in the P4 program.
    cstring name;

    /// The thread to which this state is assigned.
    gress_t gress;

    /// The bytes from the input buffer which will be loaded into the match
    /// registers and used to select a LoweredParserMatch transition to take.
    LoweredSelect select;

    /// The possible transitions out of this state.
    inline Vector<LoweredParserMatch> match;

#emit
    /// Debugging information about the high-level parser states that were used
    /// to generate this low-level parser state.
    ::BFN::DebugInfo debug;
#end
}


/// The lowered representation of a parser. This is the representation used
/// after PHV allocation. It contains primitives which operate on PHV containers
/// and numeric constants.
class LoweredParser : AbstractParser {
#noconstructor
    LoweredParser(gress_t gress, LoweredParserState start)
        : AbstractParser(gress), start(start) {}
#apply

    toString {
        return gress ? "lowered egress parser" : "lowered ingress parser";
    }

    /// The entry point to the parser.
    LoweredParserState start;

    /// parser error
    optional NullOK BFN::ContainerRef parserError;

    /// The set of PHV containers which may legally be written more than once by
    /// this parser.
    inline Vector<BFN::ContainerRef> multiwriteContainers;

    /// The set of PHV containers which has uninitialized metadata field so that
    /// set $validity bits is required in this parser.
    inline Vector<BFN::ContainerRef> initZeroContainers;

    /// The amount of data, in bytes, which this parser program expects to be
    /// prepended to the packet by the hardware or by compiler-generated code,
    /// but which is not part of the packet itself.
    unsigned prePacketDataLengthBytes = 0;

#emit
    /// If present, an EPB configuration for this parser. (This is an
    /// egress-specific feature, so we expect this to never be present on
    /// ingress.) The interpretation of the configuration is device-specific; use
    /// the utility methods on PardeSpec to interact with it.
    boost::optional<EgressParserBufferConfig> epbConfig;
#end
}

/// Supertype for all lowered deparser emit primitives - i.e., actions that
/// write data to the output packet.
abstract LoweredEmit {}

/// A primitive that writes the contents of a PHV container to the output
/// packet.
class LoweredEmitPhv : LoweredEmit {
    dbprint { out << "emit " << source << " if " << povBit; }

    /// The POV bit controlling whether the data is written.
    BFN::ContainerBitRef povBit;

    /// The container whose contents will be written to the packet.
    BFN::ContainerRef source;
}

/// A primitive that writes the result of a checksum unit to the output packet.
class LoweredEmitChecksum : LoweredEmit {
    dbprint { out << "emit checksum " << unit << " if " << povBit; }

    /// The POV bit controlling whether the data is written.
    BFN::ContainerBitRef povBit;

    /// The checksum unit whose result will be written to the packet.
    unsigned unit;
}

/// A primitive that writes the contents of a CLOT to the output packet.
class LoweredEmitClot : LoweredEmit {
    EmitClot clot;
}

/// Configures the container whose value will be used to set an intrinsic
/// deparser parameter.
class LoweredDeparserParameter {
    dbprint {
        out << "parameter " << name << " = " << source->toString();
    }

    /// The deparser parameter to configure. The name is the one used in the
    /// assembly, which in turn derives from the CSR register name.
    cstring name;

    /// The container whose contents will be used for the parameter.
    BFN::ContainerRef source;

    /// On JBay, each deparser parameter has a POV bit which determines whether
    /// the container's contents are valid (and often implicitly enables or
    /// disables the corresponding feature). On Tofino, the hidden per-container
    /// validity bits serve the same role.
    optional NullOK BFN::ContainerBitRef povBit;
}

/// An entry in a digest table, consisting of a sequence of containers.
class DigestTableEntry {
    /// The PHV containers in the entry.
    inline Vector<BFN::ContainerRef> sources;
}

/// An entry in the learning digest table.
class LearningTableEntry : DigestTableEntry {
#noconstructor
#emit
    LearningTableEntry(const IR::Vector<IR::BFN::ContainerRef>& sources,
                       cstring controlPlaneName,
                       const ::BFN::FieldPacking* controlPlaneFormat)
      : DigestTableEntry(sources), controlPlaneName(controlPlaneName),
        controlPlaneFormat(controlPlaneFormat) { }
#end

    validate { CHECK_NULL(controlPlaneFormat); }

    /// The control plane name for this type of learn quanta.
    cstring controlPlaneName;

#emit
    /// The packing format for this type of learn quanta; this describes to the
    /// driver how the fields included in the learn quantum are laid out.
    const ::BFN::FieldPacking* controlPlaneFormat;
#end
}

/// A lowered deparser digest. Each kind of digest has a set of table entries
/// which identify containers to be written into a specific buffer. The table
/// entry is chosen based on the value in the selector container.
class LoweredDigest {
    /// The name of the digest, identifying a special buffer to be filled in by
    /// the deparser hardware. The name is chosen to match the corresponding
    /// assembly directive, which in turn is named based on definitions in the
    /// CSRs.
    cstring name;

    /// The container which selects a digest table entry.
    BFN::ContainerRef selector;

    /// The available table entries; the index of each entry in the vector
    /// corresponds to the selector value which chooses it.
    optional inline Vector<DigestTableEntry> entries;

    optional NullOK BFN::ContainerBitRef povBit;
}

/// An input to a checksum unit.
class ChecksumPhvInput {
    /// A container whose contents will be included in the checksum.
    BFN::ContainerRef source;

    /// On JBay, each checksum input has an independent POV bit, which makes it
    /// easier to safely compute a checksum involving headers which may be
    /// present in different combinations. On Tofino, this is always null.
    optional NullOK BFN::ContainerBitRef povBit;

    optional bool swap = false;
}

class ChecksumClotInput {
    Clot clot;
    BFN::ContainerBitRef povBit;
}

/// A configuration for a checksum unit.
class ChecksumUnitConfig {
    /// The unit number to configure; this is referenced by LoweredEmitChecksum
    /// to actually write the checksum unit's output to the packet. On Tofino,
    /// these unit numbers exist in a separate namespace for ingress and egress;
    /// on JBay, both threads share the same checksum units.
    unsigned unit;

    /// The phv inputs to this checksum unit
    optional inline Vector<ChecksumPhvInput> phvs;

    /// clot inputs
    optional inline Vector<ChecksumClotInput> clots;
}

/// The lowered representation of the deparser. This representation is
/// constructed after PHV allocation and refers only to PHV containers;
/// references to high level objects like fields have all been eliminated.
class LoweredDeparser : AbstractDeparser {
#noconstructor
    LoweredDeparser(gress_t gress) : AbstractDeparser(gress) { }
#apply
    toString { return gress ? "lowered egress deparser" : "lowered ingress deparser"; }

    inline Vector<LoweredEmit> emits;
    inline Vector<LoweredDeparserParameter> params;
    inline Vector<LoweredDigest> digests;
    inline Vector<ChecksumUnitConfig> checksums;
}

}  // end namespace BFN
