#emit
#include <set>
#include "bf-p4c/common/debug_info.h"
#include "bf-p4c/ir/bitrange.h"
#include "bf-p4c/parde/clot.h"
#include "bf-p4c/parde/epb_config.h"
#include "bf-p4c/phv/phv.h"

namespace BFN {
struct FieldPacking;
}  // namespace BFN
#end

namespace BFN {

/// A value that can be read from in the parser on the hardware.
abstract LoweredParserRVal { }

/// An r-value that represents a read from a range of input buffer bytes (rather
/// than bits, as in the high-level parser IR) in the input buffer. The
/// coordinate system used will depend on the specific type of
/// `LoweredBufferlikeRVal`.
abstract LoweredBufferlikeRVal : LoweredParserRVal {
    validate {
        BUG_CHECK(range.lo >= 0,
                  "Extracting from offset before the start of the input buffer");
    }

    /// @return this buffer range as a half-open range of bytes in network order.
    nw_byteinterval byteInterval() const { return toHalfOpenRange(range); }

    /// @return this buffer range as a closed range of bytes in network order.
    nw_byterange extractedBytes() const { return range; }

    /// The region represented by this `LoweredBufferlikeRVal`, expressed as a
    /// range of bytes in network order.
    nw_byterange range;
}

// An r-value originating from the input packet. Represented as a range of bytes
// in the coordinate system of some parser state. @see PacketRVal for more
// details about the coordinate system.
class LoweredPacketRVal : LoweredBufferlikeRVal {
    dbprint {
        out << "packet bytes " << byteInterval() << "(" << range.size() << "B)";
    }
}

/// An r-value representing a range of bits from the region of the input buffer
/// that's mapped onto special metadata, rather than data from the input packet.
/// @see BufferRVal for more details about the coordinate system.
class LoweredBufferRVal : LoweredBufferlikeRVal {
    dbprint {
        out << "buffer bytes " << byteInterval() << "(" << range.size() << "B)";
    }
}

/// A lowered representation of a constant used as an r-value in the parser.
class LoweredConstantRVal : LoweredParserRVal {
    dbprint { out << "constant " << constant; }

    /// The constant to extract.
    int constant;
}

abstract LoweredParserPrimitive { }

/// A lowered parser extraction operation, representing a write by the parser
/// into a PHV container.
class LoweredExtractPhv : LoweredParserPrimitive {
#emit
    /// Convenience constructors for accepting a raw PHV::Container.
    LoweredExtractPhv(PHV::Container dest, const LoweredParserRVal* source)
      : source(source), dest(new BFN::ContainerRef(dest)) { }
    LoweredExtractPhv(Util::SourceInfo si, PHV::Container dest,
                   const LoweredParserRVal* source)
      : LoweredParserPrimitive(si), source(source), dest(new BFN::ContainerRef(dest)) { }
#end

    dbprint { out << "extract " << source << " to " << dest; }
    validate { BUG_CHECK(bool(dest->container), "Invalid PHV container"); }

    /// The location that will be read from.
    LoweredParserRVal source;

    /// The PHV container this extract writes to.
    BFN::ContainerRef dest;

#emit
    /// Debugging information about the high-level operations that are
    /// implemented by this low-level extract.
    ::BFN::DebugInfo debug;
#end
}

class LoweredExtractClot : LoweredParserPrimitive {
#emit
    LoweredExtractClot(Clot dest, const LoweredPacketRVal* source)
      : source(source), dest(dest) { }
    LoweredExtractClot(Util::SourceInfo si, Clot dest,
                   const LoweredPacketRVal* source)
      : LoweredParserPrimitive(si), source(source), dest(dest) { }
#end

    dbprint { out << "extract " << source << " to " << dest; }

    /// The location that will be read from.
    LoweredPacketRVal source;

    /// The clot this extract writes to.
    Clot dest;

#emit
    /// Debugging information about the high-level operations that are
    /// implemented by this low-level extract.
    ::BFN::DebugInfo debug;
#end
}

/// A lowered parser selection operation. These represent a load of a range of
/// bytes from the input buffer which will be compared against the state's
/// LoweredParserMatch entries to select the next state to transition to.
class LoweredSelect {
    dbprint { out << "match " << range; }

    /// The region of the input buffer which will be loaded and matched against.
    nw_byterange range;

#emit
    /// Debugging information about the high-level operations that are
    /// implemented by this low-level select operation.
    ::BFN::DebugInfo debug;
#end
}

/// A lowered parser match construct. Each LoweredParserMatch logically
/// represents a single row in the parser TCAM.
class LoweredParserMatch {
#emit
    LoweredParserMatch(match_t value, unsigned shift,
                       const LoweredParserState* next)
        : value(value), shift(shift), bufferRequired(0), next(next) { }
#end

    /// The mask which will be matched against the value the containing state
    /// selects against.
    match_t value;

    /// If the match is successful, the number of bytes to shift out before
    /// transitioning to the next state.
    unsigned shift;

    /// If the match is successful, the extractions to perform.
    inline Vector<LoweredParserPrimitive> statements;

    /// The number of packet bytes which must be available in the input buffer
    /// for the extractions to be performed successfully. If `boost::none`,
    /// there is no particular requirement; the assembler will choose a default.
    optional boost::optional<unsigned> bufferRequired;

    /// If the match is successful, the next state to transition to, or null if
    /// this is a terminal state in the parser program.
    NullOK LoweredParserState next;

#emit
    /// Debugging information about the high-level parser states that were used
    /// to generate this low-level match construct.
    ::BFN::DebugInfo debug;
#end
}

/// A lowered parser state, representing a group of related parser TCAM rows.
/// We do not maintain a 1-to-1 mapping between LoweredParserStates and parser
/// states in the original P4 program.
class LoweredParserState : Unit {
#noconstructor
    LoweredParserState(cstring name, gress_t gress) : name(name), gress(gress) { }
    int stage() const override { return -1; }
    gress_t thread() const override { return gress; }
    toString { return name; }
    visit_children {
        select.visit_children(v);
        match.parallel_visit_children(v); }

    /// The name of this state. This does not necessarily correspond to any
    /// state name in the P4 program.
    cstring name;

    /// The thread to which this state is assigned.
    gress_t gress;

    /// The bytes from the input buffer which will be loaded into the match
    /// registers and used to select a LoweredParserMatch transition to take.
    inline Vector<LoweredSelect> select;

    /// The possible transitions out of this state.
    inline Vector<LoweredParserMatch> match;

#emit
    /// Debugging information about the high-level parser states that were used
    /// to generate this low-level parser state.
    ::BFN::DebugInfo debug;
#end
}


/// The lowered representation of a parser. This is the representation used
/// after PHV allocation. It contains primitives which operate on PHV containers
/// and numeric constants.
class LoweredParser : AbstractParser {
#noconstructor
    LoweredParser(gress_t gress, LoweredParserState start)
        : AbstractParser(gress), start(start) {}
#apply

    toString {
        return gress ? "lowered egress parser" : "lowered ingress parser";
    }

    /// The entry point to the parser.
    LoweredParserState start;

    /// The set of PHV containers which may legally be written more than once by
    /// this parser.
    inline Vector<BFN::ContainerRef> multiwriteContainers;

    /// The amount of data, in bytes, which this parser program expects to be
    /// prepended to the packet by the hardware or by compiler-generated code,
    /// but which is not part of the packet itself.
    unsigned prePacketDataLengthBytes = 0;

#emit
    /// If present, an EPB configuration for this parser. (This is an
    /// egress-specific feature, so we expect this to never be present on
    /// ingress.) The interpretation of the configuration is device-specific; use
    /// the utility methods on PardeSpec to interact with it.
    boost::optional<EgressParserBufferConfig> epbConfig;
#end
}

/// Supertype for all lowered deparser emit primitives - i.e., actions that
/// write data to the output packet.
abstract LoweredEmit {}

/// A primitive that writes the contents of a PHV container to the output
/// packet.
class LoweredEmitPhv : LoweredEmit {
    dbprint { out << "emit " << source << " if " << povBit; }

    /// The POV bit controlling whether the data is written.
    BFN::ContainerBitRef povBit;

    /// The container whose contents will be written to the packet.
    BFN::ContainerRef source;
}

/// A primitive that writes the result of a checksum unit to the output packet.
class LoweredEmitChecksum : LoweredEmit {
    dbprint { out << "emit checksum " << unit << " if " << povBit; }

    /// The POV bit controlling whether the data is written.
    BFN::ContainerBitRef povBit;

    /// The checksum unit whose result will be written to the packet.
    unsigned unit;
}

/// A primitive that writes the contents of a CLOT to the output packet.
class LoweredEmitClot : LoweredEmit {
    EmitClot clot;
}

/// Configures the container whose value will be used to set an intrinsic
/// deparser parameter.
class LoweredDeparserParameter {
    dbprint {
        out << "parameter " << name << " = " << source->toString();
    }

    /// The deparser parameter to configure. The name is the one used in the
    /// assembly, which in turn derives from the CSR register name.
    cstring name;

    /// The container whose contents will be used for the parameter.
    BFN::ContainerRef source;

    /// On JBay, each deparser parameter has a POV bit which determines whether
    /// the container's contents are valid (and often implicitly enables or
    /// disables the corresponding feature). On Tofino, the hidden per-container
    /// validity bits serve the same role.
    optional NullOK BFN::ContainerBitRef povBit;
}

/// An entry in a digest table, consisting of a sequence of containers.
class DigestTableEntry {
    /// The PHV containers in the entry.
    inline Vector<BFN::ContainerRef> sources;
}

/// An entry in the learning digest table.
class LearningTableEntry : DigestTableEntry {
#noconstructor
#emit
    LearningTableEntry(const IR::Vector<IR::BFN::ContainerRef>& sources,
                       cstring controlPlaneName,
                       const ::BFN::FieldPacking* controlPlaneFormat)
      : DigestTableEntry(sources), controlPlaneName(controlPlaneName),
        controlPlaneFormat(controlPlaneFormat) { }
#end

    validate { CHECK_NULL(controlPlaneFormat); }

    /// The control plane name for this type of learn quanta.
    cstring controlPlaneName;

#emit
    /// The packing format for this type of learn quanta; this describes to the
    /// driver how the fields included in the learn quantum are laid out.
    const ::BFN::FieldPacking* controlPlaneFormat;
#end
}

/// A lowered deparser digest. Each kind of digest has a set of table entries
/// which identify containers to be written into a specific buffer. The table
/// entry is chosen based on the value in the selector container.
class LoweredDigest {
    /// The name of the digest, identifying a special buffer to be filled in by
    /// the deparser hardware. The name is chosen to match the corresponding
    /// assembly directive, which in turn is named based on definitions in the
    /// CSRs.
    cstring name;

    /// The container which selects a digest table entry.
    BFN::ContainerRef selector;

    /// The available table entries; the index of each entry in the vector
    /// corresponds to the selector value which chooses it.
    optional inline Vector<DigestTableEntry> entries;

    optional NullOK BFN::ContainerBitRef povBit;
}

/// An input to a checksum unit.
class ChecksumInput {
    /// A container whose contents will be included in the checksum.
    BFN::ContainerRef source;

    /// On JBay, each checksum input has an independent POV bit, which makes it
    /// easier to safely compute a checksum involving headers which may be
    /// present in different combinations. On Tofino, this is always null.
    optional NullOK BFN::ContainerBitRef povBit;
}

/// A configuration for a checksum unit.
class ChecksumUnitConfig {
    /// The unit number to configure; this is referenced by LoweredEmitChecksum
    /// to actually write the checksum unit's output to the packet. On Tofino,
    /// these unit numbers exist in a separate namespace for ingress and egress;
    /// on JBay, both threads share the same checksum units.
    unsigned unit;

    /// The inputs to this checksum unit.
    optional inline Vector<ChecksumInput> inputs;
}

/// The lowered representation of the deparser. This representation is
/// constructed after PHV allocation and refers only to PHV containers;
/// references to high level objects like fields have all been eliminated.
class LoweredDeparser : AbstractDeparser {
#noconstructor
    LoweredDeparser(gress_t gress) : AbstractDeparser(gress) { }
#apply
    toString { return gress ? "lowered egress deparser" : "lowered ingress deparser"; }

    inline Vector<LoweredEmit> emits;
    inline Vector<LoweredDeparserParameter> params;
    inline Vector<LoweredDigest> digests;
    inline Vector<ChecksumUnitConfig> checksums;
}

}  // end namespace BFN
