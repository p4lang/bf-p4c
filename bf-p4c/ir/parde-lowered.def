#emit
#include <set>
#include "bf-p4c/common/debug_info.h"
#include "bf-p4c/ir/bitrange.h"
#include "bf-p4c/parde/epb_config.h"
#include "bf-p4c/phv/phv.h"
#end

namespace BFN {

/// A value that can be read from in the parser on the hardware.
abstract LoweredParserRVal { }

/// An r-value that represents a read from a range of input buffer bytes (rather
/// than bits, as in the high-level parser IR) in the input buffer. The
/// coordinate system used will depend on the specific type of
/// `LoweredBufferlikeRVal`.
abstract LoweredBufferlikeRVal : LoweredParserRVal {
    validate {
        BUG_CHECK(range.lo >= 0,
                  "Extracting from offset before the start of the input buffer");
    }

    /// @return this buffer range as a half-open range of bytes in network order.
    nw_byteinterval byteInterval() const { return toHalfOpenRange(range); }

    /// @return this buffer range as a closed range of bytes in network order.
    nw_byterange extractedBytes() const { return range; }

    /// The region represented by this `LoweredBufferlikeRVal`, expressed as a
    /// range of bytes in network order.
    nw_byterange range;
}

// An r-value originating from the input packet. Represented as a range of bytes
// in the coordinate system of some parser state. @see PacketRVal for more
// details about the coordinate system.
class LoweredPacketRVal : LoweredBufferlikeRVal {
    dbprint {
        out << "packet bytes " << byteInterval() << "(" << range.size() << "B)";
    }
}

/// An r-value representing a range of bits from the region of the input buffer
/// that's mapped onto special metadata, rather than data from the input packet.
/// @see BufferRVal for more details about the coordinate system.
class LoweredBufferRVal : LoweredBufferlikeRVal {
    dbprint {
        out << "buffer bytes " << byteInterval() << "(" << range.size() << "B)";
    }
}

/// A lowered representation of a constant used as an r-value in the parser.
class LoweredConstantRVal : LoweredParserRVal {
    dbprint { out << "constant " << constant; }

    /// The constant to extract.
    int constant;
}

/// A lowered parser extraction operation, representing a write by the parser
/// into a PHV container.
class LoweredExtract {
#emit
    /// Convenience constructors for accepting a raw PHV::Container.
    LoweredExtract(PHV::Container dest, const LoweredParserRVal* source)
      : source(source), dest(new BFN::ContainerRef(dest)) { }
    LoweredExtract(Util::SourceInfo si, PHV::Container dest,
                   const LoweredParserRVal* source)
      : IR::Node(si), source(source), dest(new BFN::ContainerRef(dest)) { }
#end

    dbprint { out << "extract " << source << " to " << dest; }
    validate { BUG_CHECK(bool(dest->container), "Invalid PHV container"); }

    /// The location that will be read from.
    LoweredParserRVal source;

    /// The PHV container this extract writes to.
    BFN::ContainerRef dest;

#emit
    /// Debugging information about the high-level operations that are
    /// implemented by this low-level extract.
    ::BFN::DebugInfo debug;
#end
}

/// A lowered parser selection operation. These represent a load of a range of
/// bytes from the input buffer which will be compared against the state's
/// LoweredParserMatch entries to select the next state to transition to.
class LoweredSelect {
    dbprint { out << "match " << range; }

    /// The region of the input buffer which will be loaded and matched against.
    nw_byterange range;

#emit
    /// Debugging information about the high-level operations that are
    /// implemented by this low-level select operation.
    ::BFN::DebugInfo debug;
#end
}

/// A lowered parser match construct. Each LoweredParserMatch logically
/// represents a single row in the parser TCAM.
class LoweredParserMatch {
#emit
    LoweredParserMatch(match_t value, unsigned shift,
                       const LoweredParserState* next)
        : value(value), shift(shift), next(next) { }
#end

    /// The mask which will be matched against the value the containing state
    /// selects against.
    match_t value;

    /// If the match is successful, the number of bytes to shift out before
    /// transitioning to the next state.
    unsigned shift;

    /// If the match is successful, the extractions to perform.
    inline Vector<LoweredExtract> statements;

    /// If the match is successful, the next state to transition to, or null if
    /// this is a terminal state in the parser program.
    NullOK LoweredParserState next;

#emit
    /// Debugging information about the high-level parser states that were used
    /// to generate this low-level match construct.
    ::BFN::DebugInfo debug;
#end
}

/// A lowered parser state, representing a group of related parser TCAM rows.
/// We do not maintain a 1-to-1 mapping between LoweredParserStates and parser
/// states in the original P4 program.
class LoweredParserState : Unit {
#noconstructor
    LoweredParserState(cstring name, gress_t gress) : name(name), gress(gress) { }
    int stage() const override { return -1; }
    gress_t thread() const override { return gress; }
    toString { return name; }
    visit_children {
        select.visit_children(v);
        match.parallel_visit_children(v); }

    /// The name of this state. This does not necessarily correspond to any
    /// state name in the P4 program.
    cstring name;

    /// The thread to which this state is assigned.
    gress_t gress;

    /// The bytes from the input buffer which will be loaded into the match
    /// registers and used to select a LoweredParserMatch transition to take.
    inline Vector<LoweredSelect> select;

    /// The possible transitions out of this state.
    inline Vector<LoweredParserMatch> match;

#emit
    /// Debugging information about the high-level parser states that were used
    /// to generate this low-level parser state.
    ::BFN::DebugInfo debug;
#end
}


/// The lowered representation of a parser. This is the representation used
/// after PHV allocation. It contains primitives which operate on PHV containers
/// and numeric constants.
class LoweredParser : AbstractParser {
#noconstructor
    LoweredParser(gress_t gress, LoweredParserState start)
        : AbstractParser(gress), start(start) {}
#apply

    toString {
        return gress ? "lowered egress parser" : "lowered ingress parser";
    }

    /// The entry point to the parser.
    LoweredParserState start;

    /// The set of PHV containers which may legally be written more than once by
    /// this parser.
    inline Vector<BFN::ContainerRef> multiwriteContainers;

    /// The amount of data, in bytes, which this parser program expects to be
    /// prepended to the packet by the hardware or by compiler-generated code,
    /// but which is not part of the packet itself.
    unsigned prePacketDataLengthBytes = 0;

#emit
    /// If present, an EPB configuration for this parser. (This is an
    /// egress-specific feature, so we expect this to never be present on
    /// ingress.) The interpretation of the configuration is device-specific; use
    /// the utility methods on PardeSpec to interact with it.
    boost::optional<EgressParserBufferConfig> epbConfig;
#end
}

}  // end namespace BFN
