#ifndef EXTENSIONS_BF_P4C_COMMON_BRIDGED_METADATA_PACKING_H_
#define EXTENSIONS_BF_P4C_COMMON_BRIDGED_METADATA_PACKING_H_

#include "ir/ir.h"
#include "lib/symbitmatrix.h"
#include "bf-p4c/mau/action_mutex.h"
#include "bf-p4c/mau/table_dependency_graph.h"
#include "bf-p4c/mau/table_mutex.h"
#include "bf-p4c/phv/action_phv_constraints.h"
#include "bf-p4c/phv/phv_fields.h"
#include "bf-p4c/common/bridged_metadata_replacement.h"

/// This class gathers all the bridged metadata fields also used as deparser parameters. The
/// CollectPhvInfo pass sets the deparsed_bottom_bits() property for all deparser parameters to
/// true. Therefore, this alignment constraint needs to be recognized and respected during bridged
/// metadata packing.
class GatherDeparserParameters : public Inspector {
 private:
    const PhvInfo& phv;
    /// Set of detected deparser parameters.
    ordered_set<const PHV::Field*>& params;

    profile_t init_apply(const IR::Node* root) override {
        params.clear();
        return Inspector::init_apply(root);
    }

    bool preorder(const IR::BFN::DeparserParameter* p) override;

 public:
    explicit GatherDeparserParameters(const PhvInfo& p, ordered_set<const PHV::Field*>& f)
        : phv(p), params(f) { }
};

/// This class identifies all fields initialized in the parser during Phase 0. The output of this
/// pass is used later by PackBridgedMetadata as follows: If a bridged field is also initialized in
/// Phase 0, then that field is not packed with any other field.
class GatherPhase0Fields : public Inspector {
 private:
     const PhvInfo& phv;
     /// Set of all fields initialized in phase 0.
     ordered_set<const PHV::Field*>& phase0Fields;
     static constexpr char const *PHASE0_PARSER_STATE_NAME = "ingress::$phase0";

     profile_t init_apply(const IR::Node* root) override {
         phase0Fields.clear();
         return Inspector::init_apply(root);
     }

     bool preorder(const IR::BFN::ParserState* p) override;

 public:
     explicit GatherPhase0Fields(
             const PhvInfo& p,
             ordered_set<const PHV::Field*>& f)
         : phv(p), phase0Fields(f) { }
};

/// This class identifies all metadata fields that have alignment constraints due to initialization
/// by ComputedRVals in the parser.
class GatherParserExtracts : public Inspector {
 private:
    const PhvInfo& phv;
    /// Map of all fields with alignment constraints due to initialization in the parser with values
    /// being the field they are initialized to.
    ordered_map<const PHV::Field*, const PHV::Field*>& parserAlignedFields;
    static constexpr char const *FIELD_PREFIX = "ingress::^bridged_metadata";

    profile_t init_apply(const IR::Node* root) override {
        parserAlignedFields.clear();
        return Inspector::init_apply(root);
    }

    bool preorder(const IR::BFN::Extract* e) override;

 public:
    explicit GatherParserExtracts(
            const PhvInfo& p,
            ordered_map<const PHV::Field*, const PHV::Field*>& f)
        : phv(p), parserAlignedFields(f) { }
};

/// This class analyzes all bridged metadata headers, which until this point, insert padding to byte
/// alignment after every nonbyte aligned bridged metadata field. This pass takes into account
/// action-related as well as some alignment related constraints (such as deparser_bottom_bits() set
/// for DeparserParameters) and creates new bridged metadata headers that potentially have fewer
/// padding bits. The new header generated by PackBridgedMetadata always has the byte-aligned fields
/// at the beginning followed by the nonbyte-aligned fields with appropriate padding.
/// XXX(Deep): Right now, we do not pack bridged fields that have alignment constraints with any
/// other bridged field. In future, we could relax this requirement to achieve tighter packing of
/// bridged metadata fields.
class PackBridgedMetadata : public Transform, public TofinoWriteContext {
 public:
    static constexpr char const *EGRESS_BRIDGED_PARSER_STATE_NAME = "egress::$bridged_metadata";
    static constexpr char const *INGRESS_FIELD_PREFIX = "ingress::";
    static constexpr char const *EGRESS_FIELD_PREFIX = "egress::";
    static constexpr char const *BRIDGED_FIELD_PREFIX = "^bridged_metadata";
    static constexpr char const *BRIDGED_INIT_ACTION_NAME = "act";

 private:
    const PhvInfo& phv;
    /// Reference to mapping of original P4 field to the bridged field.
    const CollectBridgedFields& fields;
    /// Reference to object used to query action-related constraints.
    const ActionPhvConstraints& actionConstraints;
    /// doNotPack(x, y) = true implies that a bridged field with id x cannot be packed with another
    /// bridged field with id y.
    SymBitMatrix& doNotPack;
    /// Set of all fields initialized in phase 0.
    const ordered_set<const PHV::Field*>& phase0Fields;
    /// Set of all fields used as deparser parameters.
    const ordered_set<const PHV::Field*>& deparserParams;
    /// Set of all fields with alignment constraints induced by the parser.
    const ordered_map<const PHV::Field*, const PHV::Field*>& parserAlignedFields;

    /// Map of original egress field name to the field name in the egress bridged metadata header.
    /// E.g. egress::ingress_metadata.ingress_port is the original backend name for a field, and
    /// egress::^bridged_metadata.md_ingress_metadata_ingress_port is the name of the field
    /// generated as part of egress bridged header. This map maintains the correspondence between
    /// the two.
    ordered_map<cstring, cstring> egressBridgedMap;

    /// Map of original field to a related field from which this field will derive its alignment
    /// constraints from.
    /// XXX(Deep): Use this for more efficient bridged field packing.
    ordered_map<const PHV::Field*, const PHV::Field*> fieldAlignmentMap;

    /// Ingress bridged metadata header created by this pass.
    IR::Header* ingressBridgedHeader = nullptr;
    /// Egress bridged metadata header created by this pass.
    IR::Header* egressBridgedHeader = nullptr;

    /// Clears state. Also, initializes the egressBridgedMap.
    IR::Node* preorder(IR::Header* h) override;

    profile_t init_apply(const IR::Node* root) override;

    /// Action analysis for the set of @nonByteAlignedFields in header @h. It populates the
    /// doNotPack matrix based on results of this analysis.
    void bridgedActionAnalysis(
            const IR::Header* h,
            std::vector<const IR::StructField*>& nonByteAlignedFields);

    /// Pretty print a no-pack constraint determined by bridgedActionAnalysis.
    void printNoPackConstraint(
            cstring errorMessage,
            const PHV::Field* f1,
            const PHV::Field* f2) const;

    /// Returns a map of field to starting position within the nearest byte aligned chunk for fields
    /// that can be packed in the bridged metadata header @h with field @f in the same byte.
    /// @alignment is the number of bits available for packing.
    /// @candidates are the candidate fields for bridged metadata packing.
    /// @alreadyPackedFields are the list of bridged fields that have already been packed.
    /// @alignmentConstraints refers to the alignment constarints on bridged fields.
    /// @conflictingAlignmentConstraints refers to the set of fields that may have mutually
    /// conflicting alignment constraints, and hence may never be packed together.
    ordered_map<const IR::StructField*, int> packWithField(
            const int alignment,
            const IR::Header* h,
            const IR::StructField* f,
            const std::vector<const IR::StructField*>& candidates,
            const ordered_set<const PHV::Field*>& alreadyPackedFields,
            const ordered_map<const IR::StructField*, le_bitrange>& alignmentConstraints,
            const ordered_set<const IR::StructField*>& conflictingAlignmentConstraints) const;

    /// Given the map of alignment constraints for fields @alignmentConstraints, a set of
    /// potentially packable fields @potentiallyPackableFields and the base field @f, @return the
    /// list of fields that must be eliminated from consideration to avoid alignment conflicts. E.g.
    /// if field A (2b) must be packed in bits 2-3, and field B (3b) must be packed in bits 1-3,
    /// then field B is added to the set to the be returned (always pick the smaller sized fields as
    /// the reason for alignment conflict).
    ordered_set<const IR::StructField*> checkPotentialPackAlignmentReqs(
            const ordered_map<const IR::StructField*, le_bitrange>& alignmentConstraints,
            ordered_set<const IR::StructField*>& potentiallyPackableFields,
            const IR::StructField* f) const;

    /// Determine alignment constraints associated with the set of @nonByteAlignedFields in header
    /// @h. The result is stored in the @alignmentConstraints map.
    void determineAlignmentConstraints(
            const IR::Header* h,
            const std::vector<const IR::StructField*>& nonByteAlignedFields,
            ordered_map<const IR::StructField*, le_bitrange>& alignmentConstraints,
            ordered_set<const IR::StructField*>& conflictingAlignmentConstraints);

    /// @returns true if @field1 and @field2 are written in the same action, where the map
    /// @acts contains mapping of fields to the actions in which they are written.
    bool fieldsWrittenSameAction(
            const PHV::Field* field1,
            const PHV::Field* field2,
            const ordered_map<const PHV::Field*, ordered_set<const IR::MAU::Action*>>& acts) const;

 public:
    explicit PackBridgedMetadata(
            const PhvInfo& p,
            const CollectBridgedFields& f,
            const ActionPhvConstraints& a,
            SymBitMatrix& s,
            const ordered_set<const PHV::Field*>& z,
            const ordered_set<const PHV::Field*>& d,
            const ordered_map<const PHV::Field*, const PHV::Field*>& pa)
        : phv(p), fields(f), actionConstraints(a), doNotPack(s), phase0Fields(z), deparserParams(d),
          parserAlignedFields(pa) { }

    /// @returns the backend name of the field, given the @header and the the @field.
    /// This performs a simple string concatenation.
    cstring getFieldName(const IR::Header* hdr, const IR::StructField* field) const;

    /// @returns the egress version of a field name when the @ingressName is specified.
    cstring getEgressFieldName(cstring ingressName) const;

    /// @returns the ingress bridged metadata header created by this pass.
    const IR::Header* getIngressBridgedHeader() const {
        return ingressBridgedHeader;
    }

    /// @returns the egress bridged metadata header created by this pass.
    const IR::Header* getEgressBridgedHeader() const {
        return egressBridgedHeader;
    }

    /// @returns a reference to the structure that maps the original egress field name to the field
    /// name in the egress bridged metadata header.
    const ordered_map<cstring, cstring>& getEgressBridgedMap() const {
        return egressBridgedMap;
    }

    /// @returns the non-bridged egress header version of an ingress field with name @ingressName.
    cstring getNonBridgedEgressFieldName(cstring ingressName) const;

    /// @returns the size of the header in bytes.
    int getHeaderBytes(const IR::Header* h) const;

    /// @returns true if there are any common actions in the two sets @set1 and @set2.  Analysis
    /// does not consider the action 'act' added specifically for bridged metadata initialization.
    bool hasCommonAction(
            ordered_set<const IR::MAU::Action*>& set1,
            ordered_set<const IR::MAU::Action*>& set2) const;
};

/// This class takes the results of PackBridgedMetadata and for all bridged metadata fields, changes
/// all Emits in the ingress deparser and all Extracts in the egress parser to use the newly
/// generate bridged header type.
class ReplaceBridgedMetadataUses : public Transform {
 private:
    const PhvInfo& phv;
    const PackBridgedMetadata& pack;
    const CollectBridgedFields& collectBridgedFields;

    /// Map: Bridged field name to IR::Type*.
    ordered_map<cstring, const IR::Type*> bridgedFields;
    /// Map: Bridged field name to offset within the header.
    ordered_map<cstring, unsigned> bridgedOffsets;
    /// Map: Bridged field name to new emit, reflecting the revised bridged header packing.
    ordered_map<cstring, IR::BFN::Emit*> newEmits;

    profile_t init_apply(const IR::Node* root) override;
    IR::Node* preorder(IR::BFN::Pipe* pipe) override;
    IR::Node* preorder(IR::BFN::Extract* e) override;
    IR::Node* preorder(IR::BFN::Emit* e) override;

    /// Add emits for the revised bridged metadata packing to the deparser.
    IR::Node* postorder(IR::BFN::Deparser* d) override;

    /// Adjusts the shift of each transition out of the egress bridged metadata header, after taking
    /// into account the new structure of the bridged metadata header.
    IR::Node* postorder(IR::BFN::ParserState* p) override;

    /// Replaces the extract corresponding to the originally packed egress bridged field with a new
    /// extract that reflects the packing output by PackBridgedMetadata.
    IR::BFN::Extract* replaceExtract(const IR::BFN::Extract* e, const PHV::Field* dest);

    /// Replaces the emit corresponding to the originally packed ingress bridged field with a new
    /// emit that reflects the packing output by PackBridgedMetadata.
    void replaceEmit(const IR::BFN::Emit* e);

    /// Builds up a list of all bridged metadata fields, with separate entries for ingress and
    /// egress versions. Note that this list is created by walking through the fields in the
    /// bridged_metadata headers.
    void addBridgedFields(const IR::Header* header);

 public:
    explicit ReplaceBridgedMetadataUses(
            const PhvInfo& p,
            const PackBridgedMetadata& pm,
            const CollectBridgedFields& f)
        : phv(p), pack(pm), collectBridgedFields(f) { }
};

/** To ensure that BridgedMetadataPacking works even when dead code elimination is disabled, we need
  * to remove all the Extract nodes that refer to the egress version of bridged metadata fields.
  * This pass performs that removal.
  */
class RemoveUnusedExtracts : public Transform {
 private:
    const PhvInfo& phv;
    static constexpr char const *BM_INDICATOR = "^bridged_metadata.^bridged_metadata_indicator";

    IR::Node* preorder(IR::BFN::Extract* e) override;

 public:
    explicit RemoveUnusedExtracts(const PhvInfo& p) : phv(p) { }
};

class BridgedMetadataPacking : public PassManager {
 private:
    CollectBridgedFields&                               bridgedFields;
    PackConflicts                                       packConflicts;
    ActionPhvConstraints                                actionConstraints;
    PackBridgedMetadata                                 packMetadata;
    SymBitMatrix                                        doNotPack;
    TablesMutuallyExclusive                             tMutex;
    ActionMutuallyExclusive                             aMutex;
    ordered_set<const PHV::Field*>                      phase0Fields;
    ordered_set<const PHV::Field*>                      deparserParams;
    ordered_map<const PHV::Field*, const PHV::Field*>   parserAlignedFields;

 public:
    explicit BridgedMetadataPacking(
            const PhvInfo& p,
            DependencyGraph& dg,
            CollectBridgedFields& b,
            const MauBacktracker& alloc);
};

#endif  /* EXTENSIONS_BF_P4C_COMMON_BRIDGED_METADATA_PACKING_H_ */
