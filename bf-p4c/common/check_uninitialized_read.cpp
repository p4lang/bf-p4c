#include "check_uninitialized_read.h"

bool CheckUninitializedRead::printed = false;

void CheckUninitializedRead::end_apply() {
    if (printed) return;
    set_printed();
    for (const auto &kv : phv.get_all_fields()) {
        const auto &field = kv.second;
        LOG3("checking " << field);
        for (const auto &use : defuse.getAllUses(field.id)) {
            const auto & defs_of_use = defuse.getDefs(use);
            bool uninit = defs_of_use.empty();
            if (!uninit) {
                for (const auto &def : defs_of_use) {
                    if (def.second->is<ImplicitParserInit>() &&
                        pragmas.pa_no_init().getFields().count(&field)) {
                        LOG3("Use: (" << DBPrint::Brief << use.first << ", " << use.second <<
                             ") has a ImplicitParserInit def but pa_no_init is on");
                        uninit = true;
                        break;
                    }
                }
            } else {
                // metadata in INGRESS and non bridged metadata in EGRESS will have at least a
                // ImplicitParserInit def.
                BUG_CHECK(!field.metadata ||
                          (field.metadata && field.bridged && field.gress == EGRESS),
                          "metadata cannot reach here");
                if (field.pov) {
                    // pov is always initialized.
                    uninit = false;
                    LOG3("Ignore pov bits");
                } else if (field.is_padding()) {
                    // padding fields that are generated by the compiler should be ignored.
                    uninit = false;
                    LOG3("Ignore padding field");
                } else {
                    LOG3("Use: (" << DBPrint::Brief << use.first << ", " << use.second <<
                        ") does not have defs");
                }
            }
            if (uninit) {
                ::warning(
                    "%s is read in %s, but it is totally or partially uninitialized",
                    field.name,
                    use.first);
            }
        }
    }
}
