# -*- Python -*-
#
# Copyright (c) 2015-2017 Barefoot Networks, Inc.

# All Rights Reserved.

# NOTICE: All information contained herein is, and remains the property of
# Barefoot Networks, Inc. and its suppliers, if any. The intellectual and
# technical concepts contained herein are proprietary to Barefoot Networks, Inc.
# and its suppliers and may be covered by U.S. and Foreign Patents, patents in
# process, and are protected by trade secret or copyright law. Dissemination of
# this information or reproduction of this material is strictly forbidden unless
# prior written permission is obtained from Barefoot Networks, Inc.

# No warranty, explicit or implicit is provided, unless granted under a written
# agreement with Barefoot Networks, Inc.
#

import os
import os.path
import sys

def find_file(directory, filename, binary=True):
    '''
    Searches up the directory hierarchy for filename with prefix directory
    starting from the current working directory.
    If directory is an absolute path, just check for the file.
    If binary == true, then check permissions that the file is executable
    '''
    def check_file(f):
        if os.path.isfile(f):
            if binary:
                if os.access(f, os.X_OK): return True
            else:
                return True
        return False

    executable = ""
    if directory.startswith('/'):
        executable = os.path.normpath(os.path.join(directory, filename))
        if check_file(executable): return executable

    # find the file up the hierarchy
    dir	= os.path.abspath(os.getcwd())
    if os.path.basename(filename) != filename:
        directory = os.path.join(directory, os.path.dirname(filename))
        filename = os.path.basename(filename)
    while dir != "/":
        path_to_file = os.path.join(dir, directory)
        if os.path.isdir(path_to_file):
	    files = os.listdir(path_to_file)
            if filename in files:
                executable = os.path.join(path_to_file, filename)
                if check_file(executable): return executable

	dir = os.path.dirname(dir)
    print 'File', filename, 'Not found'
    sys.exit(1)

# Search the environment for assets
if os.environ['P4C_BUILD_TYPE'] == "DEVELOPER":
    walle = find_file('bf-asm', 'walle/walle')
    bfas = find_file('bf-asm', 'bfas')
    bflink = find_file('bf-asm', 'bflink')
else:
    walle = find_file(os.environ['P4C_BIN_DIR'], 'walle')
    bfas = find_file(os.environ['P4C_BIN_DIR'], 'bfas')
    bflink = find_file(os.environ['P4C_BIN_DIR'], 'bflink')

def config_preprocessor(jbay_target):
    config.add_preprocessor_option(jbay_target, "-E -x c")
    config.add_preprocessor_option(jbay_target, "-D__TARGET_JBAY__")
    if source_basename is not None:
        config.add_preprocessor_option(jbay_target, "-o")
        config.add_preprocessor_option(jbay_target, "{}/{}.p4i".format(output_dir, source_basename))
        config.add_preprocessor_option(jbay_target, source_fullname)

def config_compiler(jbay_target):
    config.add_compiler_option(jbay_target, "--nocpp")
    config.add_compiler_option(jbay_target, "--target jbay-v1model-barefoot")
    config.add_compiler_option(jbay_target, "-D__TARGET_JBAY__")
    if source_basename is not None:
        config.add_compiler_option(jbay_target, "-o")
        config.add_compiler_option(jbay_target, "{}/{}.bfa".format(output_dir, source_basename))
        config.add_compiler_option(jbay_target, "{}/{}.p4i".format(output_dir, source_basename))

def config_assembler(jbay_target):
    if source_basename is not None:
        config.add_assembler_option(jbay_target, "--target jbay")
        if (os.environ['P4C_BUILD_TYPE'] == "DEVELOPER"):
            config.add_assembler_option(jbay_target, "-vvvvl {}/bfas.config.log".format(output_dir))
        config.add_assembler_option(jbay_target, "-o {}".format(output_dir))
        config.add_assembler_option(jbay_target, "{}/{}.bfa".format(output_dir, source_basename))

def config_linker(jbay_target):
    config.add_linker_option(jbay_target, "--walle " + walle)
    config.add_linker_option(jbay_target, "--target jbay")
    if source_basename is not None:
        config.add_linker_option(jbay_target, "-o {}/jbay.bin".format(output_dir))
        config.add_linker_option(jbay_target, "{}/*.cfg.json".format(output_dir))
        config.add_linker_option(jbay_target, "-b {}".format(source_basename))

# JBay Native Architecture
jbay_native_target = 'jbay-native-barefoot'
config_preprocessor(jbay_native_target)
config_compiler(jbay_native_target)
config_assembler(jbay_native_target)
config_linker(jbay_native_target)

config.add_toolchain(jbay_native_target, {
    'preprocessor': 'cc',
    'compiler': os.path.join(os.environ['P4C_BIN_DIR'], 'p4c-tofino'),
    'assembler': bfas,
    'linker': bflink})
config.add_compilation_steps(jbay_native_target,
      ['preprocessor', 'compiler', 'assembler', 'linker'])
config.target.append(jbay_native_target)

# JBay V1model architecture -- still need to support for P4_14
jbay_v1model_target = 'jbay-v1model-barefoot'
config_preprocessor(jbay_v1model_target)
config_compiler(jbay_v1model_target)
config_assembler(jbay_v1model_target)
config_linker(jbay_v1model_target)

config.add_toolchain(jbay_v1model_target, {
    'preprocessor': 'cc',
    'compiler': os.path.join(os.environ['P4C_BIN_DIR'], 'p4c-tofino'),
    'assembler': bfas,
    'linker': bflink})
config.add_compilation_steps(jbay_v1model_target,
      ['preprocessor', 'compiler', 'assembler', 'linker'])
config.target.append(jbay_v1model_target)

# PSA implementation on JBay
psa_target = 'jbay-psa-barefoot'
config.add_linker_option(psa_target, "")
config.add_toolchain(psa_target, {
    'linker': 'echo "target ' + psa_target + ' not yet implemented"'
})
config.add_compilation_steps(psa_target, ['linker'])
config.target.append(psa_target)
