#ifndef _EXTENSIONS_BF_P4C_LOGGING_RESOURCES_H_
#define _EXTENSIONS_BF_P4C_LOGGING_RESOURCES_H_

#include <set>
#include <string>
#include <utility>
#include <vector>

#include "ir/ir.h"
#include "ir/gress.h"
#include "lib/cstring.h"
#include "lib/ordered_map.h"
#include "resources_schema.h"

using Logging::Resources_Schema_Logger;
class ClotInfo;  // Forward declaration

namespace BFN {

/**
 *  \brief Class for generating resources.json logfile
 *
 *  It uses API autogenerated from resources_schema.py, you can find it by running make
 *  and then searching for resources_schema.h in the build dir. The classes have the same
 *  names as in schema and they have the same nested structure. Dictionaries also become
 *  classes.
 *
 *  All properties that are not an array must be initialized in the constructor and parameters
 *  are always sorted alphabetically.
 *
 *  Enums will become strings/ints and optional ints/optional int enums will be int pointers
 *  (int pointer with nullptr value will not be emitted).
 */
class ResourcesLogging : public Inspector {
 public:
    using ActionDataResourceUsage = Resources_Schema_Logger::ActionDataResourceUsage;
    using ClotResourceUsage = Resources_Schema_Logger::ClotResourceUsage;
    using ElementUsage = Resources_Schema_Logger::ElementUsage;
    using ExactMatchResultBusResourceUsage =
                                        Resources_Schema_Logger::ExactMatchResultBusResourceUsage;
    using ExactMatchSearchBusResourceUsage =
                                        Resources_Schema_Logger::ExactMatchSearchBusResourceUsage;
    using HashBitsResourceUsage = Resources_Schema_Logger::HashBitsResourceUsage;
    using HashDistResourceUsage = Resources_Schema_Logger::HashDistributionResourceUsage;
    using LogicalTableResourceUsage = Resources_Schema_Logger::LogicalTableResourceUsage;
    using MapRamResourceUsage = Resources_Schema_Logger::MapRamResourceUsage;
    using MauStageResourceUsage = Resources_Schema_Logger::MauStageResourceUsage;
    using MeterAluResourceUsage = Resources_Schema_Logger::MeterAluResourceUsage;
    using ParserResources = Resources_Schema_Logger::ParserResources;
    using PhvResourceUsage = Resources_Schema_Logger::PhvResourceUsage;
    using RamResourceUsage = Resources_Schema_Logger::RamResourceUsage;
    using ResourceUsage = Resources_Schema_Logger::ResourceUsage;
    using GatewayResourceUsage = Resources_Schema_Logger::GatewayResourceUsage;
    using StashResourceUsage = Resources_Schema_Logger::StashResourceUsage;
    using StatisticAluResourceUsage = Resources_Schema_Logger::StatisticAluResourceUsage;
    using TcamResourceUsage = Resources_Schema_Logger::TcamResourceUsage;
    using TindResultBusResourceUsage = Resources_Schema_Logger::TindResultBusResourceUsage;
    using VliwResourceUsage = Resources_Schema_Logger::VliwResourceUsage;
    using XbarResourceUsage = Resources_Schema_Logger::XbarResourceUsage;

    // Cross bar bytes can be shared by multiple tables for different purposes, and
    // the detail can be different due to possible overlay of bytes
    struct XbarByteResource {
        std::set<std::string> usedBy;
        std::set<std::string> usedFor;
        std::set<std::string> detail;

        void append(const std::string &ub, const std::string &uf, const std::string &d);
    };

    // Each hash bit is reserved to a single table or side effect.  However, because the
    // same bit can be the select bits/RAM line bit for two different ways in the same
    // table, then they can be shared
    struct HashBitResource {
        std::string usedBy;
        std::set<std::string> usedFor;
        std::set<std::string> detail;

        void append(std::string ub, const std::string &uf, const std::string &d);
    };

    // This represents the 48 bits of hash distribution before the hash distribution units
    // are expanded, masked and shifted
    // Hash Distribution units can be used for multiple purposes (i.e. two wide addresses
    // between tables
    struct HashDistResource {
        std::set<std::string> usedBy;
        std::set<std::string> usedFor;

        void append(const std::string &ub, const std::string &uf);
    };

    struct ActionBusByteResource {
        std::set<std::string> usedBy;

        void append(const std::string &ub);
    };

    struct MemoriesResource {
        std::string              tableName;
        const TableResourceAlloc *use;

        MemoriesResource(cstring name, const TableResourceAlloc *use) :
            tableName(name), use(use) {}
    };

    struct IMemColorResource {
        unsigned int color = 0;
        gress_t gress = INGRESS;
        std::set<std::string> usedBy;
        std::set<std::string> detail;

        void append(const std::string &ub, const std::string &d);
    };

 protected:
    struct StageResources {
        ordered_map<int, cstring> logicalIds;  // Map table logical ids to table names
        ordered_map<int, XbarByteResource> xbarBytes;
        ordered_map<std::pair<int, int>, HashBitResource>  hashBits;
        ordered_map<std::pair<int, int>, HashDistResource> hashDist;
        ordered_map<int, ActionBusByteResource>            actionBusBytes;
        ordered_map<int, std::vector<IMemColorResource>>   imemColor;
        std::vector<MemoriesResource>                      memories;
    };

    const ClotInfo &clotInfo;  // ClotInfo reference is only passed to CLOT resource logger
    std::string filePath;  // path to logged file
    std::string manifestPath;  // path from manifest to logged file
    std::vector<StageResources> stageResources;  // Data for logging are collected here
    const ParserResources *parserResources;  // Logged data for parser
    std::vector<ClotResourceUsage*> clotResources;  // Logged data for clots

    /**
     *  Prepares the object and collects data for parser and clot usage.
     */
    bool preorder(const IR::BFN::Pipe *p) override;

    /**
     *  Collects data for this particular table resource usage and
     *  stores it into stageResources.
     */
    bool preorder(const IR::MAU::Table *tbl) override;

    /**
     *  Performs actual logging - aggregates all collected data and
     *  stores them in the json file. Also updates manifest so it knows where
     *  to find that file.
     */
    void end_apply(const IR::Node *root) override;

    void collectTableUsage(cstring name, const IR::MAU::Table *table);

    void collectXbarBytesUsage(unsigned int stage, const IXBar::Use &alloc);

    void collectHashDistUsage(unsigned int stage, const IXBar::HashDistUse &hd_use);

    void collectActionBusBytesUsage(unsigned int stage, const ActionDataBus::Use &alloc,
                                        cstring tableName);

    void collectVliwUsage(unsigned int stage, const InstructionMemory::Use &alloc,
                            gress_t gress, cstring tableName);

    XbarResourceUsage *logXbarBytes(unsigned stageNo) const;

    HashBitsResourceUsage *logHashBits(unsigned stageNo) const;

    HashDistResourceUsage *logHashDist(unsigned stageNo) const;

    void logMemories(unsigned int stage, RamResourceUsage *ramsRes,
                    MapRamResourceUsage *mapRamsRes, GatewayResourceUsage *gatewaysRes,
                    StashResourceUsage *stashesRes, MeterAluResourceUsage *meterRes,
                    StatisticAluResourceUsage *statisticsRes, TcamResourceUsage *tcamsRes) const;

    LogicalTableResourceUsage *logLogicalTables(int stageNo) const;

    ActionDataResourceUsage *logActionBusBytes(unsigned int stageNo) const;

    void logActionSlots(MauStageResourceUsage *msru) const;

    VliwResourceUsage *logVliw(unsigned int stageNo) const;

    ExactMatchSearchBusResourceUsage *logExactMemSearchBuses(unsigned int stageNo) const;

    ExactMatchResultBusResourceUsage *logExactMemResultBuses(unsigned int stageNo) const;

    TindResultBusResourceUsage *logTindResultBuses(unsigned int stageNo) const;

    MauStageResourceUsage *logStage(int stageNo);

 public:
    // Only need this for public interface, rest is done in preorder and end_apply
    ResourcesLogging(const ClotInfo &clotInfo,
                     const std::string &filename,
                     const std::string &outdir) : clotInfo(clotInfo), filePath(filename) {
        manifestPath = filename.substr(outdir.size() + 1);
    }
};

}  // namespace BFN

#endif /* _EXTENSIONS_BF_P4C_LOGGING_RESOURCES_H_ */
