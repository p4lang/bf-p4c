#ifndef EXTENSIONS_BF_P4C_PHV_ANALYSIS_DOMINATOR_TREE_H_
#define EXTENSIONS_BF_P4C_PHV_ANALYSIS_DOMINATOR_TREE_H_

#include "ir/ir.h"
#include "bf-p4c/mau/table_flow_graph.h"

/** This class builds an immediate dominator tree using separate table flow graphs for ingress and
  * egress. This class uses the Lengauer-Tarjan dominator tree algorithm offered by boost.
  * This class maintains a map of table pointers, so must be rerun every time new table objects are
  * created (e.g. through gateway merge) and the associated flow graphs must be re-computed
  * accordingly.
  */
class BuildDominatorTree : public Inspector {
 public:
    /// map[x] = y, means that table y is the immediate dominator for table x.
    using ImmediateDominatorMap = ordered_map<const IR::MAU::Table*, const IR::MAU::Table*>;
    using G = FlowGraph::Graph;
    using Vertex = boost::graph_traits<G>::vertex_descriptor;
    using IndexMap = boost::property_map<G, boost::vertex_index_t>::type;
    using PredMap = boost::iterator_property_map<std::vector<Vertex>::iterator, IndexMap>;

 private:
    /// References to FlowGraph references for every gress.
    std::vector<FlowGraph*>&              flowGraph;
    /// Immediate dominator map for each gress.
    std::vector<ImmediateDominatorMap*>  iDominator;

    profile_t init_apply(const IR::Node* root) override;
    bool preorder(const IR::BFN::Pipe* pipe) override;

    /** Generates a map of indexes to a table pointer. Used as a helper function for building the
      * dominator tree.
      */
    void generateIndexToTableMap(
            const FlowGraph& fg,
            ordered_map<int, const IR::MAU::Table*>& indexMap) const;

    /** Generates a dominator tree based on a table flow graph @fg. Internally uses @indexToTableMap
      * generated by a call to generateIndexToTableMap() method to identify various tables. The
      * results are accessed via the @iDom map.
      */
    void generateDominatorTree(
            const FlowGraph& fg,
            const ordered_map<int, const IR::MAU::Table*>& indexToTableMap,
            ImmediateDominatorMap& iDom);

    /** Prints the immediate dominator for each table in @idom.
      */
    void printDominatorTree(const ImmediateDominatorMap& idom) const;

 public:
    /** @returns the immediate dominator table for @t with @gress. @returns boost::none if there is
     * no immediate dominator. If @t is nullptr, then it indicates the deparser, in which case the
     * gress needs to be specified.
     */
    boost::optional<const IR::MAU::Table*>
        getImmediateDominator(const IR::MAU::Table* t, gress_t gress) const;

    /** @returns the non gateway immediate dominator for @t belonging to @gress. @returns
      * boost::none if there is no non-gateway immediate dominator. If @t is nullptr, then it
      * indicates the deparser, in which case the gress needs to be specified.
      */
    boost::optional<const IR::MAU::Table*>
        getNonGatewayImmediateDominator(const IR::MAU::Table* t, gress_t gress) const;

    /** @returns true if the unit @u1 strictly dominates unit @u2.
      */
    bool strictlyDominates(const IR::BFN::Unit* u1, const IR::BFN::Unit* u2) const;

    /** @returns true if the table @t1 strictly dominates table @t2.
      */
    bool strictlyDominates(const IR::MAU::Table* t1, const IR::MAU::Table* t2) const;

    /** @returns the lowest common ancestor (group dominator) for the group of tables in @tables.
      */
    const IR::MAU::Table*
        getNonGatewayGroupDominator(ordered_set<const IR::MAU::Table*>& tables) const;

    /** @returns a vector of tables that strictly dominate the give table @t.
      */
    const std::vector<const IR::MAU::Table*>
        getAllDominators(const IR::MAU::Table* t, gress_t gress) const;

    explicit BuildDominatorTree(std::vector<FlowGraph*>& fg) : flowGraph(fg) { }

    /// GTest methods.

    /** Used exclusively for gtests. Returns the immediate dominator of the table with name @t and
     * gress @g. Returns empty string if no dominator present.
     */
    cstring hasImmediateDominator(gress_t g, cstring t) const;

    /** Used exclusively for gtests. Returns true if the table with name @t1 strictly dominates the
      * table with name @t2 for @gress.
      */
    bool strictlyDominates(cstring t1, cstring t2, gress_t gress) const;

    /** Used exclusively for gtests. Return true if the table with name @t2 and @gress is a
      * dominator of table with name @t1.
      */
    bool isDominator(cstring t1, gress_t gress, cstring t2) const;
};

#endif  /* EXTENSIONS_BF_P4C_PHV_ANALYSIS_DOMINATOR_TREE_H_ */
