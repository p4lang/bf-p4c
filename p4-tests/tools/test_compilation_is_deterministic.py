#!/usr/bin/env python3

# This script can be used to test determinism of compilation of P4 programs.
# Normally it would be executed through a .test wrapper generated by CMake (using the
# `bfn_add_determinism_test_with_args` macro). The wrapper can be also executed separatelly to add
# extra options to it:
#   --repeats N        the number of compilations to run (default: 10)
#   --keep-different   if the test fails, produce a folder with compilation results for further
#                      manual inspection
#   bf-p4c options     additional bf-p4c options can be specified, useful options include --top4
#                      and -T options to enrich the logs
#
# Normally the script compares PHV, CLOT and table allocation as well as the overall backend log
# that shows state of backend data structures after different passes. If --top4 option is used to
# specify front-/mid-end passes after which the P4 program should be dumped, the dumped programs
# are also compared.

from __future__ import annotations
import os
import os.path
import filecmp
import re
import shutil
import subprocess
import sys
import tempfile
from itertools import islice
from typing import List, Dict, Optional, NoReturn, Literal

RE_PTR = re.compile(r"0x[0-9a-f]+")
# use lookbehind & lookahead to replace just the ID itself but check that it is surrounded by
# square brackets and space. It is imortant to distinguish between strings like
# - `      [12345] BFN::ChecksumEntry offset=400` (should match)
# - `[12345] BFN::ChecksumEntry offset=400`       (should match)
# and
# - `|           |       |[4]              |egress::vlan_tag[0].etherType_v0.$valid`
# that should not match as the numberss in square brackets are indices from the P4 source.
RE_ID = re.compile("((?<=\s\[)|(?<=^\[))[0-9]+(?=\]\s)")  # TODO: should this really be stripped
RE_PASS = re.compile(r"P[aA][sS][sS]:")

class Test:
    def __init__(self, p4c: str, program: str, args: List[str],
                 keep_different: bool) -> None:
        self.p4c = p4c
        self.program = program
        self.program_id = os.path.splitext(os.path.basename(self.program))[0]
        self.args = args
        self.tmpdir : Optional[tempfile.TemporaryDirectory] = None
        self.keep_different = keep_different

    def __enter__(self) -> Test:
        self.tmpdir = tempfile.TemporaryDirectory(prefix=f"{self.program_id}.")
        self.tmpdir.__enter__()
        return self

    def __exit__(self, exception_type, exception_value, traceback) -> None:
        assert self.tmpdir is not None
        self.tmpdir.__exit__(exception_type, exception_value, traceback)
        self.tmpdir = None
    
    def _compile(self, out_num: int) -> str:
        assert self.tmpdir
        out = os.path.join(self.tmpdir.name, f"{out_num:04}")
        dump = os.path.join(out, "dump")
        os.makedirs(dump)
        print(f"compiling {self.program_id}... ", end="", flush=True, file=sys.stderr)
        rc = subprocess.run([self.p4c, self.program] + self.args
                            + ["--verbose", "1",   # basic logs
                               "-Tbackend.cpp:5",  # backend passes
                               "-o", out,          # output dir
                               "--dump", dump],    # dir for --top4 (if enabled)
                            encoding="utf8",
                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if rc.returncode != 0:
            print("Compilation failed: ", file=sys.stderr)
            print(rc.stdout, file=sys.stdout)
            sys.exit(2)
        print("OK", file=sys.stderr)
        return out

    def _die(self, msg: str) -> NoReturn:
        print("\nError:", msg, file=sys.stderr)
        print("Comparison failed", file=sys.stderr)
        sys.exit(1)

    def _log_name(self, a: str) -> str:
        assert self.tmpdir
        log_name = os.path.relpath(a, self.tmpdir.name)
        return log_name[log_name.find('/') + 1:]

    def _diff(self, a: str, b: str, hierarchical_log: bool = False) -> bool:
        banner_printed = False
        last_pass : Optional[str] = None
        context : Dict[int, str] = {}
        printed_context : Dict[int, str] = {}
        line = 0
        out_lines = 0

        def add_context(val: str) -> None:
            if not hierarchical_log:
                return
                
            nonlocal last_pass
            nonlocal context
            val = val.rstrip()
            if RE_PASS.search(val) is not None:
                last_pass = f"{line}:   {val}"
            indent = len(val) - len(val.lstrip())
            context[indent] = f"{line}:   {val}"
            context = {i: v for i, v in context.items() if i <= indent}

        def dump_context(val_a: str = None, val_b: str = None) -> None:
            nonlocal last_pass
            nonlocal printed_context
            max_indent = max((len(x) - len(x.lstrip())
                              for x in [val_a, val_b] if x is not None), default=1000)
            if last_pass is not None:
                print(last_pass, file=sys.stderr)
                last_pass = None  # avoid repeated printing of the same pass
            for i, v in sorted(context.items()):
                if printed_context.get(i) != v and i < max_indent:
                    print(v, file=sys.stderr)
            printed_context = context.copy()

        def err(msg) -> Literal[False]:
            print(msg, file=sys.stderr)
            dump_context()
            return False

        def treat_ptr(line: Optional[str]) -> Optional[str]:
            if not hierarchical_log:
                return line

            if line is None:
                return None
            return RE_ID.sub("<<ID>>", RE_PTR.sub("<<pointer>>", line))

        with open(a, encoding="utf-8-sig", errors="ignore") as fa:
            with open(b, encoding="utf-8-sig", errors="ignore") as fb:
                while True:
                    it_a = treat_ptr(next(fa, None))
                    it_b = treat_ptr(next(fb, None))
                    line += 1

                    if it_a is None and it_b is None:
                        return True
                    if it_a is None or it_b is None:
                        ended = a if it_a is None else b
                        return err(f"File {ended} ended first (line {line})")

                    if it_a != it_b:
                        if not banner_printed:
                            banner_printed = True
                            print(f"Mismatches in {self._log_name(a)}:", file=sys.stderr)
                        dump_context(it_a, it_b)
                        print(f"{line}: - {it_a}", file=sys.stderr, end="")
                        print(f"{line}: + {it_b}", file=sys.stderr, end="")
                        out_lines += 1
                        if out_lines >= 10:
                            return err("Too many differences");

                    add_context(it_a)

    def _compare_logs(self, path_a: str, path_b: str) -> None:
        assert self.tmpdir
        logs = []
        for entry in os.scandir(path_a):
            if not entry.is_file():
                continue
            if entry.name.startswith("phv_allocation_summary_") \
                    or entry.name in ["clot_allocation.log", "table_summary.log"] \
                    or entry.name.endswith("_passes.log") \
                    or entry.name.endswith(".p4pp"):
                logs.append(entry.name)

        if not logs and os.path.basename(path_a) != "dump":
            self._die(f"No logs found in log dir {path_a}")

        mismatch = []
        for log in logs:
            a = os.path.join(path_a, log)
            b = os.path.join(path_b, log)
            if not os.path.isfile(b):
                self._die(f"Log file {b} not found")
            if not self._diff(a, b, hierarchical_log=log.endswith("_passes.log")):
                mismatch.append((a, b))

        if mismatch:
            if self.keep_different:
                out = f"{self.program_id}.diff"
                shutil.rmtree(out, ignore_errors=True)
                shutil.copytree(self.tmpdir.name, out)
            for a, b in mismatch:
                if self.keep_different:
                    a_copy = os.path.abspath(a.replace(self.tmpdir.name, out))
                    b_copy = os.path.abspath(b.replace(self.tmpdir.name, out))
                    print(f"The different logs are in: {a_copy} {b_copy}", file=sys.stderr)
                else:
                    print(f"Allocation changed: mismatch for log {self._log_name(a)}", file=sys.stderr)
            self._die(f"Allocation changed: There were {len(mismatch)} mismatching files")

    def _compare(self, path_a: str, path_b: str) -> None:
        for d in [path_a, path_b]:
            if not os.path.isdir(d):
                self._die(f"Not a directory: {d}")

        subdirs = sorted(f.name for f in os.scandir(path_a) if f.is_dir()
                         and f.name not in ["debug", "graphs"])
        if not subdirs:
            self._die(f"No output produced in {path_a}")
        for sub in subdirs:
            if sub == "logs" or sub == "dump":
                self._compare_logs(os.path.join(path_a, sub),
                                   os.path.join(path_b, sub))
            else:
                self._compare(os.path.join(path_a, sub),
                              os.path.join(path_b, sub))


    def execute(self, num_repeats: int) -> None:
        out_paths = []
        for i in range(num_repeats):
            out_paths.append(self._compile(i));
            if i != 0:
                self._compare(out_paths[0], out_paths[i])

if __name__ == '__main__':
    def usage():
        print(f"usage: {sys.argv[0]} PATH_TO_BF_P4C [COMPILATION ARGS...] [--repeats N] P4_PROGRAM",
              file=sys.stderr)
        sys.exit(3)

    # print("Running with ", *sys.argv, file=sys.stderr)
    repeats = 10
    if len(sys.argv) < 3:
        print("Error: too few arguments", file=sys.stderr)
        usage()
    p4c = sys.argv[1]
    if os.path.isdir(p4c):
        p4c = "./bf-p4c"
    
    p4prog = sys.argv[-1]
    if not os.path.isfile(p4prog):
        print(f"Error: the P4 program is not a file: {p4prog}", file=sys.stderr)
        usage()

    args = []
    is_repeats = False
    keep_different = False
    for arg in islice(sys.argv, 2, len(sys.argv) - 1):
        if is_repeats:
            repeats = int(arg)
            is_repeats = False
        elif arg == "--repeats":
            is_repeats = True
        elif arg == "--keep-different":
            keep_different = True
        else:
            args.append(arg)

    print(f"Compiling with {p4c} {p4prog} {' '.join(args)}", file=sys.stderr)
    with Test(p4c, p4prog, args, keep_different) as t:
        t.execute(repeats)
    print(f"No differences found after {repeats} repeats", file=sys.stderr)
