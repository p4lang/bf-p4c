#! /usr/bin/env python
# -----------------------------------------------------------------------------
# stf2ptf_pd

# generate a PTF-PD test script out of an STF file
# -----------------------------------------------------------------------------
import abc
from string import maketrans

def encodePacket(packet):
    if len(packet) % 2 == 0:
        return ''.join('\\x' + x.encode('hex') for x in packet.decode('hex'))
    else:
        packet += '0'
        s = ''.join('\\x' + x.encode('hex') for x in packet.decode('hex'))
        return s[:len(s)-1]


class STF2PTF:
    __metaclass__ = abc.ABCMeta

    def __init__(self, ast, testname):
        testNameEscapeChars = "-.[]"
        testNameEscapes = "_"*len(testNameEscapeChars)
        self._transTable = maketrans(testNameEscapeChars,testNameEscapes)
        self._ast = ast
        self._testname = testname.translate(self._transTable)
        self._indent = ''
        self._indentSize = 0
        self._indentTabSize = '  '

    def genPtfAPI(self, ptf):
        self.genHeader(ptf)
        self.genTestClass(ptf)

    def genTestClass(self, ptf):
        self.genRunTestPreamble(ptf)

        ptf.write(self._indent + 'try:\n')
        self.incrementIndent()
        ptf.write('\n')

        self.genProcessSTF(ptf)

        self.decrementIndent()
        ptf.write('\n')
        ptf.write(self._indent + 'finally:\n')
        self.incrementIndent()

        self.genRunTestPost(ptf)
        self.decrementIndent();
        ptf.write('\n')

    @abc.abstractmethod
    def genRunTestPreamble(self, ptf):
        return

    def genProcessSTF(self, ptf):
        pkt_expects = []  # ptf buffers packets and they can be retrieved after a corresponding send, at wait statements, or at the end. They get delivered in order
        pkt_pair = [None, None]
        tbl_op = False
        for s in self._ast:
            # print s
            if s[0] == 'packet':
                if pkt_pair[0] is not None:
                     # we've already seen another packet without a pairing
                     # expect. Send the pair packet, and replace the pair with
                     # the new one
                    if tbl_op:
                        self.genWaitStmt (ptf)
                        tbl_op = False
                    self.genSendPacket(ptf, pkt_pair[0])
                    pkt_pair[0] = s
                else:
                    pkt_pair[0] = s
            elif s[0] == 'expect':
                if pkt_pair[1] is not None:
                    pkt_expects.append(s)
                else:
                    pkt_pair[1] = s
            elif s[0] == 'add':
                self.genAddTableEntry(ptf, s)
                tbl_op = True
            elif s[0] == 'wait':
                for e in pkt_expects:
                    if tbl_op:
                        self.genWaitStmt(ptf)
                        tbl_op = False
                    self.genExpectPacket(ptf, e, pkt_pair[0])
                pkt_expects = []
                self.genWaitStmt(ptf)
                tbl_op = False
            elif s[0] == 'setdefault':
                self.genAddDefaultAction(ptf, s)
                tbl_op = True
            elif s[0] == 'check_counter':
                self.genCheckCounter(ptf, s)
            elif s[0] == 'remove':
                self.genRemoveTableEntries(ptf)
            elif s[0] == 'tcam_2bit_mode':
                # ignored for now
                pass

            else:
                assert False, "Unknown statement %s" % s[0]

            if pkt_pair[0] is not None and pkt_pair[1] is not None:
                if tbl_op:
                    self.genWaitStmt(ptf)
                    tbl_op = False
                self.genProcessPacket(ptf, pkt_pair)
                pkt_pair = [None, None]

        # and the implicit wait at the end of the script
        self.genWaitStmt(ptf)

    @abc.abstractmethod
    def genRunTestPost(self, ptf):
        return

    @abc.abstractmethod
    def genAddTableEntry(self, ptf, entry):
        """
            Generate a P4Runtime call to add a table entry

            Entry is stored in the self._entries map, keyed by the table name
            such that they can be deleted at the end of the test
        """
        return

    @abc.abstractmethod
    def genMatchKey(self, ptf, table, match_list):
        """
            Generate the match_spec
        """
        return

    @abc.abstractmethod
    def genAddDefaultAction(self, ptf, set_default):
        """
            Generate a default entry
        """
        return

    @abc.abstractmethod
    def genActionParamList(self, ptf, table, action, action_params):
        """
            generate action_spec_t with values for action params
        """
        return

    @abc.abstractmethod
    def genSendPacket(self, ptf, packet):
        """
            Generate a send_packet statement
        """
        return

    @abc.abstractmethod
    def genExpectPacket(self, ptf, expect, orig_packet):
        """
            Generate a check_packet statement
        """
        return

    def genProcessPacket(self, ptf, pkt_pair):
        """
            Generate a send_packet/check_packet pair.
        """
        ptf.write('\n')
        self.genSendPacket(ptf, pkt_pair[0])
        self.genExpectPacket(ptf, pkt_pair[1], pkt_pair[0])

    @abc.abstractmethod
    def genCheckCounter(self, ptf, chk):
        return

    @abc.abstractmethod
    def genRemoveTableEntries(self, ptf):
        """
            Remove table entries
        """
        return

    @abc.abstractmethod
    def genWaitStmt(self, ptf):
        return

    def incrementIndent(self):
        self._indentSize += 1
        self._indent = self._indentTabSize * self._indentSize

    def decrementIndent(self):
        self._indentSize -= 1
        self._indent = self._indentTabSize * self._indentSize

    def setExpectTern(self, expect, packet):
        """
            Set the expect packet don't care to packet data since
            the packet comparison looks byte-by-byte
        """
        val = ''
        for e, p in zip(expect, packet):
            if e == '*': val += p
            else: val += e
        return val

    def match2spec(self, match_name, match):
        """
            Turns a match into (escaped name, value, mask)
            Returning a mask of None means there were no don't care symbols in the value
        """
        name = match_name.translate(self._transTable)
        hasMask = False
        isBinary = False
        lpmLen = -1
        if isinstance(match, tuple): # an LPM expression (match/len)
            # we don't care about the mask, so we'll return the length in it at the end
            key = match[0]
            lpmLen = int(match[1])
        else:
            key = match
        if key.startswith('0x') or key.startswith('0b'):
            val = key[0:2]
            mask = key[0:2]
            keyPtr = key[2:]
            if key.startswith('0b'):
                isBinary = True
        else:
            val = ''
            mask = '0x'
            keyPtr = key[0:]

        for c in keyPtr:
            if c == '*':
                val += '0'
                mask += '0'
                hasMask = True
            else:
                val += c
                if isBinary: mask += '1'
                else: mask += 'f'
        # print name, ',', val, ',', mask
        if not hasMask: mask = None
        return name, val, mask

    def genHeader(self, ptf):
        """
            Generate the preamble for importing all ptf and protobug classes
        """
        ptf.write('# ' + '-' * 76 + '\n')
        ptf.write('# Autogenerated PTF test -- please modify the corresponding STF file:\n')
        ptf.write('# ' + self._testfile + '\n')
        ptf.write('# ' + '-' * 76 + '\n')
        ptf.write('\n')

        ptf.write('import logging\n')
        ptf.write('import unittest\n')
        ptf.write('import random\n')
        ptf.write('from ptf import config\n')
        ptf.write('from ptf.testutils import *\n')

        ptf.write('\n')
        ptf.write('def match_ternary(expected, received):\n')
        ptf.write('    if len(expected) > len(received):\n')
        ptf.write('        logging.debug("Received packet length %d shorter than expected %d", len(received), len(expected))\n')
        ptf.write('        return False;\n')
        ptf.write('    for (e, r) in zip(expected, str(received)):\n')
        ptf.write('        if e != \'*\' and e != r:\n')
        ptf.write('            return False\n')
        ptf.write('    return True\n')
        ptf.write('\n')
        ptf.write('def check_packet(test, pkt, port_id):\n')
        ptf.write('    """                                                                                                                \n')
        ptf.write('        Check that an expected packet is received                                                                          \n')
        ptf.write('        port_id can either be a single integer (port_number on default device 0)                                           \n')
        ptf.write('        or a tuple of 2 integers (device_number, port_number)  \n')
        ptf.write('        The packet matching is customized to compare against ternaries\n')
        ptf.write('    """\n')
        ptf.write('    device, port = port_to_tuple(port_id)\n')
        ptf.write('    logging.debug("Checking for pkt on device %d, port %d", device, port)\n')
        ptf.write('    (rcv_device, rcv_port, rcv_pkt, pkt_time) = dp_poll(\n')
        ptf.write('        test, device_number=device, port_number=port, timeout=2, exp_pkt=None)\n')
        ptf.write('    if pkt is not None and rcv_pkt is not None and not match_ternary(pkt, rcv_pkt):\n')
        ptf.write('        rcv_pkt = None\n')
        ptf.write('    test.assertTrue(rcv_pkt != None, "Did not receive expected pkt on device %d, port %r" % (device, port))\n')
        ptf.write('\n')


class STF2PD (STF2PTF):
    def __init__(self, ast, testname):
        super(STF2PD, self).__init__(ast, testname)
        self._namedEntries = {}

    def genRunTestPreamble(self, ptf):
        ptf.write(self._indent + '@group(\'' + self._testname + '\')\n')
        ptf.write(self._indent + 'class Test'+self._testname.capitalize()+'(pd_base_tests.ThriftInterfaceDataPlane):\n')
        self.incrementIndent()
        ptf.write(self._indent + '"""testing ' + self._testname + '"""\n')
        ptf.write('\n')

        ptf.write(self._indent + 'def __init__(self):\n')
        self.incrementIndent()
        ptf.write(self._indent + 'pd_base_tests.ThriftInterfaceDataPlane.__init__(self, ["' + self._testname +'"])\n')
        ptf.write(self._indent + 'self._entries = []\n')
        self.decrementIndent()
        ptf.write('\n')

        ptf.write(self._indent + 'def runTest(self):\n')
        self.incrementIndent()
        ptf.write(self._indent + 'logging.info("\\n" + self.__doc__)\n')
        ptf.write(self._indent + 'self.sess_hdl = self.conn_mgr.client_init()\n')
        ptf.write(self._indent + 'self.dev_id   = 0\n')
        ptf.write(self._indent + 'self.dev_tgt  = DevTarget_t(self.dev_id, hex_to_i16(0xFFFF))\n')
        ptf.write('\n')


    def genAddTableEntry(self, ptf, entry):
        """
            Generate a PD call to add a table entry

            Entry is stored in the self._entries map, keyed by the table name
            such that they can be deleted at the end of the test
        """
        table = entry[1].translate(self._transTable)
        priority = entry[2]
        match_list = entry[3]
        action = entry[4][0].translate(self._transTable)
        action_params = entry[4][1]

        ptf.write(self._indent + 'e = self.client.' + table + '_table_add_with_' + action + '(self.sess_hdl,')
        ptf.write('self.dev_tgt, \\\n')
        self.incrementIndent()     # multiline stmt
        self.genMatchKey(ptf, table, match_list)

        self.genActionParamList(ptf, table, action, action_params)

        ptf.write(')\n')
        self.decrementIndent()     # end multiline stmt
        ptf.write(self._indent + 'self._entries.append(("' + table + '", e))\n')
        if entry[5] is not None:
            match_name, match, mask = self.match2spec(match_list[0][0], match_list[0][1])
            self._namedEntries[entry[5]] = match

    def genAddDefaultAction(self, ptf, set_default):
        """
            Generate a default entry
        """
        table = set_default[1].translate(self._transTable)
        action = set_default[2][0].translate(self._transTable)
        action_params = set_default[2][1]
        ptf.write(self._indent + 'self.client.' + table + '_set_default_action_' + action + '(self.sess_hdl, self.dev_tgt')
        self.genActionParamList(ptf, table, action, action_params)
        ptf.write(')\n')

    def genMatchKey(self, ptf, table, match_list):
        ptf.write(self._indent + self._testname + '_'+ table + '_match_spec_t(')
        first = True
        for match_spec in match_list:
            match_name, match, mask = self.match2spec(match_spec[0], match_spec[1])
            if not first: ptf.write(', ')
            else: first = False
            ptf.write(match_name + '=' + match)
            # if there were no ternary symbols then there is no mask defined I
            # would like a more reliable way to detect when the generated PD
            # code defines a mask for the field or not. It is based on ternary
            # lookups, but STF doesn't know
            if mask is not None:
                ptf.write(', ' + match_name + '_mask' + '=' + mask)
        ptf.write(')')


    def genActionParamList(self, ptf, table, action, action_params):
        """
            generate action_spec_t with values for action params
        """
        if len(action_params) == 0:
            return

        ptf.write(', \\\n' + self._indent + self._testname + "_" + table + '_' + action + "_action_spec_t(")
        first = True
        for ap in action_params:
            if not first: ptf.write(', ')
            else: first = False
            name, val, mask = self.match2spec(ap[0], ap[1])
            ptf.write(name + '=' + val)
        ptf.write(') \\\n' + self._indent)

    def genSendPacket(self, ptf, packet):
        """
            Generate a send_packet statement
        """
        ptf.write('\n')
        ptf.write(self._indent + 'logging.info("Sending packet on port ' + packet[1] + '")\n')
        ptf.write(self._indent + 'send_packet(self, ' + packet[1] + ', \"' + encodePacket(packet[2]) + '\")\n')

    def genExpectPacket(self, ptf, expect, orig_packet):
        """
            Generate a check_packet statement
        """
        if expect[1] is None:
            # check there are no packets
            ptf.write(self._indent + 'testsuite.verify_no_other_packets(self)\n')
            return

        ptf.write('\n')
        ptf.write(self._indent + 'logging.info("Expecting packet on port ' + expect[1] + '")\n')
        if expect[2] is not None:
            expected = "\"" + encodePacket(self.setExpectTern(expect[2], orig_packet[2])) + "\""
        else:
            expected = "None"
        ptf.write(self._indent + 'check_packet(self, ' + expected + ', ' + expect[1] + ')\n')


    def genCheckCounter(self, ptf, chk):
        if str(chk[2]).startswith('$'):
            varName = chk[2][1:]
            assert varName in self._namedEntries, "Invalid named entry " + chk[2]
            counterIndex = self._namedEntries[varName]
        else:
            counterIndex = chk[2]
        ptf.write(self._indent + '# check_counter ' + chk[1] + '(' + counterIndex + ')\n')
        ptf.write(self._indent + 'counters = self.client.' + chk[1] + '_get(self.dev_id)\n')
        if chk[3][0] is not None:
            count_type = chk[3][0]
            compare = chk[3][1]
            val = chk[3][2]
            ptf.write(self._indent + 'self.assertTrue(counters[' + counterIndex + '] ' + \
                      compare + ' ' + val + ', "Wrong count of ' + count_type + '")\n')

    def genRemoveTableEntries(self, ptf):
        """
            Remove table entries
            Walk the entries added by addTableEntries in self._entries and call table_delete
        """
        ptf.write(self._indent + '# remove entries\n')
        unique_tables = set()
        for s in self._ast:
            if s[0] == 'add': unique_tables.add(s[1].translate(self._transTable))
        if len(unique_tables) > 0:
            ptf.write(self._indent + 'for t, e in self._entries:\n')
            self.incrementIndent() # for stmt
            for table in unique_tables:
                ptf.write(self._indent + 'if t == "' + table + '":\n')
                self.incrementIndent() # if stmt
                ptf.write(self._indent + 'self.client.' + table + '_table_delete(self.sess_hdl, self.dev_id, e)\n')
                self.decrementIndent() # end if
            self.decrementIndent() # end for
            ptf.write(self._indent + 'self._entries = []')

    def genRunTestPost(self, ptf):
        self.genRemoveTableEntries(ptf)
        ptf.write(self._indent + '# \\TODO: remove default entries\n')
        ptf.write(self._indent + 'self.conn_mgr.client_cleanup(self.sess_hdl)\n')

    def genWaitStmt(self, ptf):
        ptf.write('\n')
        ptf.write(self._indent + '# -------- WAIT -------\n')
        ptf.write(self._indent + 'self.conn_mgr.complete_operations(self.sess_hdl)\n\n')

    def genHeader(self, ptf):
        """
            Generate the preamble for importing all ptf and pd classes
        """
        super(STF2PD, self).genHeader(ptf)

        ptf.write('import time\n')
        ptf.write('import sys\n')
        ptf.write('import pd_base_tests\n')
        ptf.write('from ptf.thriftutils import *\n')
        ptf.write('import os\n')
        ptf.write('\n')
        ptf.write('from res_pd_rpc.ttypes import *\n')
        ptf.write('from ' + self._testname + '.p4_pd_rpc.ttypes import *\n')
        ptf.write('\n')
        ptf.write('\n')


import argparse
import sys, os, os.path
from stf_parser import STFParser

def get_arg_parser():
    parser = argparse.ArgumentParser(description='Generates a PTF test from the specified input file')
    parser.add_argument('--output', help='name of output file (default <testname>_ptf.py)',
                        type=str, action='store', default=None)
    parser.add_argument('stftest', help='name of STF input file',
                        type=str, action='store')
    return parser


def main():
    args = get_arg_parser().parse_args()
    parser = STFParser()
    stf, errs = parser.parse(filename=args.stftest)
    if errs != 0:
        sys.exit(1)
    testname, ext = os.path.splitext(os.path.basename(args.stftest))
    stf2ptf = STF2PD(stf, testname)
    stf2ptf._testfile = args.stftest

    outFileName = args.output
    if args.output is None:
        outFileName = testname + "_ptf.py"
    else:
        dirname = os.path.dirname(outFileName)
        if not os.path.exists(dirname):
            print "Creating directory", dirname
            os.makedirs(dirname)
    ptffile = open(outFileName, 'w')

    stf2ptf.genPtfAPI(ptffile)


if __name__ == '__main__':
    main()
