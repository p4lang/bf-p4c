#!/bin/bash

set -o pipefail

# On macOS, 'timeout' is not installed by default, and 'brew install coreutils'
# prefixes all of the standard GNU utilities with 'g', so 'timeout' is
# 'gtimeout' on that plaform. 'readlink' also needs this treatment because the
# BSD version accepts different options.
TIMEOUT_COMMAND=$(which gtimeout || which timeout)
READLINK_COMMAND=$(which greadlink || which readlink)

# set the debugger based on platform: lldb on MacOS, gdb everywhere else
if [ $(uname -s) == 'Darwin' ]; then
    DEBUGGER_COMMAND="lldb --"
else
    DEBUGGER_COMMAND="gdb --args"
fi

# Setting this timeout (590) to be lower than the ctest timeout (600)
# to capture known failures due to test timeout for XFAIL
TIMEOUT=${P4C_TIMEOUT:-590}
TIME_COMMAND="" # don't time commands
verbose=false
debug=false
debug_bfas=false
debug_p4c=false
run_stf=true
run_stf2ptf=false
run_ptf=false
run_pd=false
ptftestdir=""
device="tofino"
p4info=true

die() {
    if [ $# -gt 0 ]; then
        echo >&2 "$@"
    fi
    exit 1
}

run() {
    if $verbose; then
        echo "$TIME_COMMAND $TIMEOUT_COMMAND $TIMEOUT $@"
    fi

    # `timeout` can't be killed by ctrl^c when run inside a bash script, so we
    # need to run it in the background, record the pid, then kill it on INT.
    trap 'kill -INT -$pid' INT
    $TIME_COMMAND $TIMEOUT_COMMAND $TIMEOUT "$@" &
    pid=$!
    wait $pid
    status=$?

    # Clear the trap for the INT signal.
    trap - INT

    if [ $status -eq 124 ]; then
        echo >&2 $1 TIMEOUT
    elif [ $status -gt 128 ]; then
        echo >&2 $1 CRASH with signal $(expr $status - 128)
    elif [ $status -gt 0 ]; then
        echo >&2 $1 FAILED
    fi
    return $status
}

srcdir=${1%/}
if [ ! -d "$srcdir" ]; then
    die "Usage: $0 <srcdir> <test-source>"
fi
shift

# Find the root of the cmake build directory, where the cache is located
findcmakecache() {
    dir=$(pwd -P)
    while [ "$dir" != "/" ]; do
        if [ -f "$dir/CMakeCache.txt" ]; then
            echo $dir
            return
        fi
        dir=$(dirname $dir)
    done
    echo >&2 "Cmake cache not found"
    exit 1
}

findbin() {
    bin=$(cmake -L -N $(findcmakecache) | grep "^$1:" | cut -d "=" -f 2)
    if [ "$bin" = "" ]; then
        echo >&2 "Could not find $1 in cmake cache"
        exit 1
    fi
    echo $bin
}

P4C=./p4c
testdir=tofino
filter_P4C_ARGS=""
for p4c_arg in $P4C_ARGS; do
    if [ "$p4c_arg" = "-norun" ]; then
        run_stf=false
    elif [ "$p4c_arg" = "-ptf" ]; then
        run_ptf=true
    elif [ "$p4c_arg" = "-pd" ]; then
        run_pd=true
    elif [ "$p4c_arg" = "-time" ]; then
        TIME_COMMAND="time"
    elif [ "$p4c_arg" = "-v" ]; then
        if $verbose; then
            filter_P4C_ARGS="$filter_P4C_ARGS $p4c_arg"
        fi
        verbose=true
    else
        filter_P4C_ARGS="$filter_P4C_ARGS $p4c_arg"
    fi
done
P4C_ARGS="$filter_P4C_ARGS"
P4PPFLAGS=""
out_ext=""

while [ $# -gt 1 ]; do
    case $1 in
    -h|-help|--help)
        echo >&2 "p4c test runner options"
        echo >&2 "   -v             verbose -- print commands before running them"
        echo >&2 "   -gdb           run p4c-barefoot under gdb"
        echo >&2 "   -dbas          run bfas under gdb"
        echo >&2 "   -time          time commands as they run"
        echo >&2 "   -to <sec>      timeout programs after <sec> seconds (default $TIMEOUT)"
        echo >&2 "   -ptf           run PTF tests if available"
        echo >&2 "   -pd            run PTF PD tests if available"
        echo >&2 "   -nop4info      not generate p4info"
        echo >&2 "   -ptfdir <dir>  directory containing PTF tests"
        echo >&2 "   -tofino        target tofino (default)"
        echo >&2 "   -jbay          target jbay"
        echo >&2 "other arguments passed to p4c-barefoot:"
        $P4C --help
        exit 0
        ;;
    -db|-gdb)
        debug=true
        debug_p4c=true
        ;;
    -dbas)
        debug=true
        debug_bfas=true
        ;;
    -to)
        TIMEOUT=$2
        shift
        ;;
    -time)
        TIME_COMMAND="time"
        ;;
    -norun)
        run_stf=false
        ;;
    -ptf)
        run_ptf=true
        ;;
    -pd)
        run_pd=true
        ;;
    -nop4info)
        p4info=false
        ;;
    -ptfdir)
        ptftestdir=$2
        shift
        ;;
    -tofino)
        device="tofino"
        testdir=tofino
        ;;
    -jbay)
        device="jbay"
        testdir=jbay
        ;;
    -stf2ptf)
        run_stf2ptf=true
        run_ptf=true
        run_stf=false
        ;;
    -v) if $verbose; then
            P4C_ARGS="$P4C_ARGS $1"
        fi
        verbose=true
        ;;
    --*)
        if [ -d $testdir${1#-} ]; then
            testdir="$testdir${1#-}"
        fi
        P4C_ARGS="$P4C_ARGS $1"
        ;;
    -D*)
        out_ext=$out_ext$1
        P4C_ARGS="$P4C_ARGS $1"
        P4PPFLAGS="$P4PPFLAGS $1"
        ;;
    *)  P4C_ARGS="$P4C_ARGS $1"
        ;;
    esac
    shift
done

if [ ! -r $1 ]; then
    die "Can't read $1"
fi
file=$1

if [[ "$file" =~ ^"$srcdir/" || "$srcdir" == "." ]]; then
    testdir=$testdir/$(dirname ${file#$srcdir/})
elif [[ "$file" =~ ^/ ]]; then
    testdir=$(dirname $file)
else
    die "$file is not under $srcdir"
fi

name=$(basename $file .p4)

# turn on compiler debug info, regardless
P4C_ARGS="$P4C_ARGS -g"

if [ $(expr "$file" : ".*v1_2") -gt 0 -o $(expr "$file" : ".*p4_16") -gt 0 ]; then
    # XXX(cole): This is a hack.  There are some P4_16 tests written against the
    # v1model architecture; in the future, this will be deprecated, and only
    # translated P4_14 programs will use the v1model architecture.  Even better,
    # eventually architecture files might include enough information to uniquely
    # identify the target, making the "--target" flag obsolete.  For the time
    # being, we grep for "v1model.p4" to determine whether a test uses the v1model
    # or TNA architecture.
    # XXX(zma) assuming tofino and jbay have same arch for now
    if grep -q "tofino.p4\|tna.p4" "$file"; then
        P4C_ARGS="$P4C_ARGS --target ${device} --arch tna"
    elif grep -q "jbay.p4\|jna.p4" "$file"; then
        P4C_ARGS="$P4C_ARGS --target ${device} --arch tna"
    elif grep -q "psa.p4" "$file"; then
        P4C_ARGS="$P4C_ARGS --target ${device} --arch psa"
    else
        P4C_ARGS="$P4C_ARGS --target ${device} --arch v1model"
    fi
    P4C_ARGS="$P4C_ARGS -x p4-16"
else
    P4C_ARGS="$P4C_ARGS --target ${device} --arch v1model"
    P4C_ARGS="$P4C_ARGS -x p4-14"
fi

if [ "$ptftestdir" != "" ] && [ ! -d ${ptftestdir} ]; then
    die "Invalid -ptfdir: $ptftestdir does not exist"
fi
if [ "$ptftestdir" = "" ]; then
    ptftestdir=${file%.p4}.ptf
    if [ ! -d ${ptftestdir} ] && ! $run_stf2ptf; then
        # no ptf to run
        run_ptf=false
    fi
fi

has_stf=false
if $run_stf && [ -r ${file%.p4}.stf ]; then
    has_stf=true
fi

if $p4info; then
    p4runtime_out=$testdir/${name}${out_ext}.out/p4info.proto.txt
    P4C_ARGS="$P4C_ARGS --p4runtime-file $p4runtime_out --p4runtime-format text"
fi

if $run_ptf || $run_stf2ptf; then
    P4C_ARGS="$P4C_ARGS -DCPU_PORT=320 -Xassembler='--pipe0'"
    NUM_IFACES=8
    for ifaceIdx in $(seq 0 $(($NUM_IFACES-1))); do
        PORT_NAME="FP_PORT_${ifaceIdx}"
        P4C_ARGS="$P4C_ARGS -D${PORT_NAME}=${ifaceIdx}"
    done
fi

if [ ! -x $P4C ]; then
    die "Can't find $P4C"
fi

# if we don't have PTF or STF tests to run, we can skip the linking step
# to save time
if ! $run_ptf && ! $has_stf ; then
    P4C_ARGS="$P4C_ARGS --no-link"
fi

if $debug; then
    $P4C -# $P4C_ARGS $file -o $testdir/${name}${out_ext}.out | while read cmd rest; do
        if [[ -z $rest && $cmd =~ :$ ]]; then
            continue # skip the label
        elif $debug_p4c && [[ $cmd =~ p4c-barefoot ]]; then
            db="$DEBUGGER_COMMAND"
        elif $debug_bfas && [[ $cmd =~ bfas ]]; then
            db="$DEBUGGER_COMMAND"
        else
            db=""
        fi
        if $verbose; then
            echo $db $cmd $rest
        fi
        </dev/tty $db $cmd $rest
    done
    exit
fi

if [ $(expr "$file" : ".*_errors") -gt 0 ]; then
    if run $P4C $P4C_ARGS $file -o $testdir/${name}${out_ext}.out; then
        echo >&2 "$P4C did not give an error when expected"
        exit 1
    fi
    exit 0
fi

# delete old outputs so we don't get confused if they're not overwritten
rm -f $testdir/$name${out_ext}.bfa
rm -f $testdir/$name${out_ext}.out/$name${out_ext}.bfa
rm -f $testdir/$name${out_ext}.out/${device}.bin
rm -f $testdir/$name${out_ext}.out/${device}.bin.gz
rm -f $testdir/$name${out_ext}.out/*.cfg.json $testdir/$name${out_ext}.out/*.cfg.json.gz
# PD runs the compiler as part of the p4-build make, so we skip running it here
if ! $run_pd; then
    run $P4C $P4C_ARGS $file -o $testdir/${name}${out_ext}.out || die
fi
# compress cfg.json files if they exist
gzip -f $testdir/$name${out_ext}.out/*.cfg.json &>/dev/null
if [ -r $testdir/$name${out_ext}.out/${device}.bin ]; then
    if $run_ptf || $run_pd; then
        true # ptf requires uncompressed binary
    elif $run_stf; then
        # stf can run compressed binaries with recent updates
        gzip -f $testdir/$name${out_ext}.out/${device}.bin
    else
        #binary not needed
        rm $testdir/$name${out_ext}.out/${device}.bin
    fi
fi
for f in $testdir/$name${out_ext}.out/*.log; do
    if [ -r $f ]; then
        gzip -f $f
    fi
done

if ! $run_pd && [ ! -r $testdir/$name${out_ext}.out/$name.bfa ]; then
    echo >&2 "$P4C did not give an error but did not generate output either"
    exit 1
fi

if $run_stf && [ -r ${file%.p4}.stf ]; then
    STF=$(findbin HARLYN_STF_${device})

    if [[ "$file" =~ ^/ ]]; then
        test=${file%.p4}.stf
    else
        test=`pwd`/${file%.p4}.stf
    fi
    cd $testdir
    mkdir -p $name${out_ext}.out
    obsLog=$name.p4.obs

    run $STF -l $name${out_ext}.out --observation-log $obsLog $test | \
        grep -v 'WARN MAU::[a-z_]* Time gone backwards!' \
        || die
fi

PTF_EXTRA_ARGS="--default-negative-timeout=0.2 $PTF_TEST_SPECS"

clean_process() {
    process_name=$1
    # Check if process exists
    if $verbose ; then
        echo "Checking if $process_name is still running:"
    fi
    process_running=`ps -ef | grep $process_name | grep -v grep | awk '{print $2}'`
    if $verbose ; then
        echo "Is $process_name running: $process_running"
    fi
    if [ "$process_running" != "no process found" ]; then
        # Try to kill the process
        sudo -n killall $process_name
    fi
}

# Extract the tools install directory based on the install path of bf_switchd
# and set the exec and python paths to pick the locally installed paths first
if $run_pd || $run_ptf ; then
    bf_switchd=$(findbin BF_SWITCHD_${device})
    tools_dir=$( dirname $( dirname $bf_switchd ) )

    export PATH=${tools_dir}/bin:${PATH}

    if [ -z "$PYTHONPATH" ]; then
        export PYTHONPATH=${tools_dir}/lib/python2.7/site-packages
    else
        export PYTHONPATH=${tools_dir}/lib/python2.7/site-packages:${PYTHONPATH}
    fi
fi

if $run_pd ; then
    testout=$(realpath $testdir/$name${out_ext}.out)

    if [ ! -d $testout ]; then
        mkdir -p $testout
    fi
    p4c=$(realpath $P4C)
    export MAKEFLAGS="-j $(nproc)"
    export P4C=$p4c
    pushd $testout > /dev/null
    echo "Configuring $name in $testout"
    if [ $name == switch ]; then
       switchdir="$(dirname $0)/p4_14/switch"
       if [ ! -r $switchdir/configure ] ; then
          pushd $switchdir > /dev/null
          echo "Reconfiguring switch"
          run ./autogen.sh > /dev/null || die
          popd > /dev/null
       fi
       export P4CV6=yes
       run $switchdir/configure --enable-thrift --disable-static --with-${device} \
	                --with-switchsai --with-cpu-veth --prefix $testout --with-p4c-v6 \
	                P4_PREFIX=dc P4_NAME=$name P4_PATH=$file P4PPFLAGS="$P4PPFLAGS" \
	                > $testout/$name-conf.log || die
       run make install > ${testout}/switch-make.log || die
    else
       p4builddir="$(dirname $0)/p4_14/p4-tests/p4-build"
       if [ ! -r $p4builddir/configure ] ; then
          pushd $p4builddir > /dev/null
          echo "Reconfiguring p4-build"
          run ./autogen.sh > /dev/null || die
          popd > /dev/null
       fi
       run $p4builddir/configure --with-${device} --with-p4c=$P4C --enable-thrift \
                    --prefix=$testout LDFLAGS="-L${tools_dir}/lib" CPPFLAGS="-I${tools_dir}/include" \
                    --bindir=${tools_dir}/bin P4_NAME=$name P4_PATH=$file PDFLAGS='$PDFLAGS' \
                    > ${testout}/p4-build-conf.log || die
       if $verbose ; then
          tail -n 10 ${testout}/p4-build-conf.log
       fi
       run make install > ${testout}/p4-build-make.log || die
    fi
    popd > /dev/null  # $testout
    # generate the conf file. FIXME: This should really be part of p4-build!!
    conf_args="--name $name --device $device --testdir $testout"
    if [ $name == switch ]; then
        conf_args="$conf_args --switch-api switchapi"
    fi
    run $(dirname $0)/gen_pd_conf.py $conf_args
    PTF_RUNNER=$(findbin HARLYN_PTF_DRIVER_WRAPPER)
    echo "Test dir: ${ptftestdir}"
    if [ -d ${ptftestdir} ]; then
        PTF_CMD="$PTF_RUNNER --testdir $testout \
                             --name $name \
                             --ptfdir ${ptftestdir} \
                             --top-builddir $(findcmakecache) \
                             --pdtest $testout/$name.conf \
                             --device ${device} \
                             $PTF_EXTRA_ARGS"
        run $PTF_CMD || die
        clean_process "ptf_runner"
        clean_process "bf_switchd"
        clean_process "tofino-model"
        exit 0
    fi
fi

if $run_ptf ; then
    PTF_RUNNER=$(findbin HARLYN_PTF_DRIVER_WRAPPER)
    # Extract the tools install directory based on the install path of bf_switchd
    bf_switchd=$(findbin BF_SWITCHD_${device})
    tools_dir=$( dirname $( dirname $bf_switchd ) )
    if [ -d ${ptftestdir} ]; then
        PTF_CMD="$PTF_RUNNER --testdir $testdir/$name${out_ext}.out --name $name \
                --ptfdir ${ptftestdir} --top-builddir $(findcmakecache) \
                --device ${device} $PTF_EXTRA_ARGS"
    elif $run_stf2ptf && [ -r ${file%.p4}.stf ]; then
        mydir=$(dirname $0)
        export PYTHONPATH=${PYTHONPATH}:${mydir}/tools/stf
        if [[ "$file" =~ ^/ ]]; then
            stftest=${file%.p4}.stf
        else
            stftest=`pwd`/${file%.p4}.stf
        fi
        PTF_CMD="$PTF_RUNNER --testdir $testdir/$name${out_ext}.out --name $name \
                --stftest ${stftest} \
                --ptfdir ${mydir}/tools/stf --top-builddir $(findcmakecache) \
                --device ${device} \
                $PTF_EXTRA_ARGS"
    fi
    if [ -n "$PTF_CMD" ]; then
        run $PTF_CMD || die
    fi
fi

if [[ " $IFAIL_TESTS " =~ " $testdir/$name.p4.test " ]]; then
    echo "intermittent test PASSED"
    exit 1
fi
