#!/bin/bash

set -o pipefail
shopt -s nullglob

# On macOS, 'timeout' is not installed by default, and 'brew install coreutils'
# prefixes all of the standard GNU utilities with 'g', so 'timeout' is
# 'gtimeout' on that plaform. 'readlink' also needs this treatment because the
# BSD version accepts different options.
TIMEOUT_COMMAND=$(which gtimeout || which timeout)
READLINK_COMMAND=$(which greadlink || which readlink)

# set the debugger based on platform: lldb on MacOS, gdb everywhere else
if [ $(uname -s) == 'Darwin' ]; then
    DEBUGGER_COMMAND="lldb --"
    nproc=$(sysctl -n hw.physicalcpu)
else
    DEBUGGER_COMMAND="gdb --args"
    nproc=$(nproc)
fi

# -----------------------------------------------
#                     supported option
# p4-14 w. stf       -stf, -stf2ptf
# p4-14 w. ptf       -ptf
# p4-14 w/o test     -ptf
# p4-16 v1 w.stf     -stf, -stf2ptf
# p4-16 v1 w.ptf     -ptf
# p4-16 v1 w/o test  -ptf
# p4-16 tna w.stf    -stf -bfrt, -stf2ptf -bfrt
# p4-16 tna w.ptf    -ptf -bfrt
# p4-16 tna w/o test -ptf -bfrt
# p4-16 tna w/o test -bfrt -force-link (pre-compile for batch testing)

# option matrix for various tests
# -------------------------------------------------------
#              -stf     -stf2ptf   -ptf    -pd     -bfrt
# run_stf      true     false      false   false   false
# run_stf2ptf  false    true       false   false   false
# run_ptf      false    true       true    false   false
# run_pd       false    false      false   true    false
# run_bfrt     false    false      false   false   true
# ------------------------------------------------------
# -stf         any p4-14 or p4-16 test with *.stf
# -stf2pdf     any p4-14 or p4-16 test with *.stf, running ptf with pi,
#              use --stftest with ptf_runner.py
# -ptf         any p4-16 test with ptf dir, run ptf with pi,
#              use --pdtest with ptf_runner.py
# -pd          any p4-14 test with ptf dir, run ptf with pd,
#              use --pdtest with ptf_runner.py
# -bfrt        any p4-16 test with ptf dir (with bfrt tests), run ptf with bfrt
# -profile     any p4-16 switch profile

# Setting this timeout (590) to be lower than the ctest timeout (600)
# to capture known failures due to test timeout for XFAIL
TIMEOUT=${P4C_TIMEOUT:-590}
TIME_COMMAND="" # don't time commands
verbose=false
debug=false
debug_bfas=false
debug_p4c=false
run_stf=true
run_stf2ptf=false
run_ptf=false
run_pd=false
run_bfrt=false
ptftestdir=""
device="tofino"
# suffix for harlyn and bfswitchd -- until those get renamed or merged into a single exec
toolsdevice="tofino"
arch="v1model"
target="tofino"
p4info=true
stf_bin=false

force_link=false

die() {
    if [ $# -gt 0 ]; then
        echo >&2 "$@"
    fi
    exit 1
}

run() {
    if $verbose; then
        echo >&2 $TIME_COMMAND $TIMEOUT_COMMAND $TIMEOUT "$@"
    fi

    # `timeout` can't be killed by ctrl^c when run inside a bash script, so we
    # need to run it in the background, record the pid, then kill it on INT.
    trap 'kill -INT -$pid' INT
    $TIME_COMMAND $TIMEOUT_COMMAND $TIMEOUT "$@" &
    pid=$!
    wait $pid
    status=$?

    # Clear the trap for the INT signal.
    trap - INT

    if [ $status -eq 124 ]; then
        echo >&2 $1 TIMEOUT
    elif [ $status -gt 128 ]; then
        echo >&2 $1 CRASH with signal $(expr $status - 128)
    elif [ $status -gt 0 ]; then
        echo >&2 $1 FAILED
    fi
    return $status
}

srcdir=${1%/}
if [ ! -d "$srcdir" ]; then
    die "Usage: $0 <srcdir> <test-source>"
fi
shift

# Find the root of the cmake build directory, where the cache is located
findcmakecache() {
    dir=$(pwd -P)
    while [ "$dir" != "/" ]; do
        if [ -f "$dir/CMakeCache.txt" ]; then
            echo $dir
            return
        fi
        dir=$(dirname $dir)
    done
    echo >&2 "Cmake cache not found"
    exit 1
}

findbin() {
    bin=$(cmake -L -N $(findcmakecache) | grep "^$1:" | cut -d "=" -f 2)
    if [ "$bin" = "" ]; then
        echo >&2 "Could not find $1 in cmake cache"
        exit 1
    fi
    echo $bin
}

# Set P4C to ./p4c by default unless set by the environment
P4C="${P4C:-./p4c}"
P4C_pd=""
testdir=tofino
filter_P4C_ARGS=()
keep_PTF_LOGS=""
for p4c_arg in ${P4C_ARGS[@]}; do
    if [ "$p4c_arg" = "-norun" ]; then
        run_stf=false
    elif [ "$p4c_arg" = "-ptf" ]; then
        run_ptf=true
    elif [ "$p4c_arg" = "-pd" ]; then
        run_pd=true
    elif [ "$p4c_arg" = "-bfrt" ]; then
        run_bfrt=true
    elif [ "$p4c_arg" = "-time" ]; then
        TIME_COMMAND="time"
    elif [ "$p4c_arg" = "-v" ]; then
        if $verbose; then
            filter_P4C_ARGS+=($p4c_arg)
        fi
        verbose=true
    elif [ -n "$p4c_arg" ]; then
        filter_P4C_ARGS+=($p4c_arg)
    fi
done
P4C_ARGS=("${filter_P4C_ARGS[@]}")
# add support to add more arguments through env variables
# this should allow us to add arguments in cmake after we add the test.
if [ ! -z "${CTEST_P4C_ARGS}" ]; then
    P4C_ARGS+=($CTEST_P4C_ARGS)
fi
if [ ! -z "${P4FLAGS}" ]; then
    P4C_ARGS+=($P4FLAGS)
fi
P4PPFLAGS=""
out_ext=""

while [ $# -gt 1 ]; do
    case $1 in
    -h|-help|--help)
        echo >&2 "p4c test runner options"
        echo >&2 "   -dbas          run bfas under gdb"
        echo >&2 "   -gdb           run p4c-barefoot under gdb"
        echo >&2 "   -tofino2       target tofino2 -- deprecate"
        echo >&2 "   -tofino3       target tofino3 -- deprecate"
        echo >&2 "   -nop4info      not generate p4info"
        echo >&2 "   -bfrt          generate the BF-RT JSON"
        echo >&2 "   -profile       switch-16 profile"
        echo >&2 "   -norun         don't run tests, just the compiler"
        echo >&2 "   -force-link    force linking a binary even if no tests specified"
        echo >&2 "   -pd            run PTF PD tests if available"
        echo >&2 "   -ptf           run PTF tests if available"
        echo >&2 "   -ptfdir <dir>  directory containing PTF tests"
        echo >&2 "   -p4c <p4cpath> p4c compiler path for PD tests (glass/brig)"
        echo >&2 "   -stfbin        use .bin instead of .conf in STF"
        echo >&2 "   -keep-logs     if specified, keep PTF logs"
        echo >&2 "   -time          time commands as they run"
        echo >&2 "   -tofino        target tofino (default) -- deprecate"
        echo >&2 "   -arch <arch>   p4 architecture (default v1model)"
        echo >&2 "   -target <target> target (default tofino)"
        echo >&2 "   -to <sec>      timeout programs after <sec> seconds (default $TIMEOUT)"
        echo >&2 "   -v             verbose -- print commands before running them"
        echo >&2 "other arguments passed to p4c-barefoot:"
        $P4C --help
        exit 0
        ;;
    -db|-gdb)
        debug=true
        debug_p4c=true
        ;;
    -dbas)
        debug=true
        debug_bfas=true
        ;;
    -to)
        TIMEOUT=$2
        shift
        ;;
    -time)
        TIME_COMMAND="time"
        ;;
    -norun)
        run_stf=false
        ;;
    -force-link)
        force_link=true
        ;;
    -ptf)
        run_ptf=true
        ;;
    -pd)
        run_pd=true
        ;;
    -nop4info)
        p4info=false
        ;;
    -bfrt)
        run_bfrt=true
        ;;
    -profile)
        profile=$2
        shift
        ;;
    -ptfdir)
        ptftestdir=$2
        shift
        ;;
    -p4c)
        P4C_pd=$2
        shift
        ;;
    -keep-logs)
        keep_PTF_LOGS="--keep-logs"
        ;;
    -target)
        target=$2
        if [[ $target = "tofino" ]]; then
            toolsdevice="tofino"
        elif [[ $target =~ "tofino2" ]]; then
            toolsdevice="jbay"
        elif [[ $target =~ "tofino3" ]]; then
            toolsdevice="cb"
        else
            echo "Unknown target $target"
            exit 1
        fi
        device=$target
        testdir=$target
        shift
        ;;
    -tofino)
        target="tofino"
        device="tofino"
        toolsdevice="tofino"
        testdir=tofino
        ;;
    -tofino2)
        target="tofino2${TOFINO2_VARIANT}"
        device="tofino2${TOFINO2_VARIANT}"
        toolsdevice="jbay"
        testdir="tofino2${TOFINO2_VARIANT}"
        ;;
    -tofino3)
        target="tofino3${TOFINO3_VARIANT}"
        device="tofino3${TOFINO3_VARIANT}"
        toolsdevice="cb"
        testdir="tofino3${TOFINO3_VARIANT}"
        ;;
    -arch)
        arch=$2
        shift
        ;;
    -stf2ptf)
        run_stf2ptf=true
        run_ptf=true
        run_stf=false
        ;;
    -stfbin)
        stf_bin=true
        ;;
    -v) if $verbose; then
            P4C_ARGS+=("$1")
        fi
        verbose=true
        ;;
    --*)
        if [ -d $testdir${1#-} ]; then
            testdir="$testdir${1#-}"
        fi
        P4C_ARGS+=("$1")
        ;;
    -D*)
        out_ext=$out_ext$1
        P4C_ARGS+=("$1")
        P4PPFLAGS="$P4PPFLAGS $1"
        ;;
    *)  P4C_ARGS+=("$1")
        ;;
    esac
    shift
done

if [ ! -r $1 ]; then
    die "Can't read $1"
fi
file=$1

if [[ "$file" =~ ^"$srcdir/" || "$srcdir" == "." ]]; then
    testdir=$testdir/$(dirname ${file#$srcdir/})
elif [[ "$file" =~ ^/ ]]; then
    testdir=$(dirname $file)
else
    die "$file is not under $srcdir"
fi

name=$(basename $file .p4)

if [[ ! -x $P4C  &&  ! -x $P4C_pd ]]; then
    die "Can't find $P4C"
fi

# turn on compiler debug info and context json validation, regardless
P4C_ARGS+=("-g")

p4_version=""
p4c_args_concat="${P4C_ARGS[@]}"
if [ $(expr "$p4c_args_concat" : ".*--std") -gt 0 ]; then
    offset=$(expr "$p4c_args_concat" : ".*--std ")
    p4_version=${p4c_args_concat:$offset:5}
else
    # guess the version based on the file name
    if [ $(expr "$file" : ".*v1_2") -gt 0 -o $(expr "$file" : ".*p4_16") -gt 0 ]; then
        p4_version="p4-16"
    else
        p4_version="p4-14"
    fi
    P4C_ARGS+=(--std $p4_version)
fi

if [ $(expr "$p4c_args_concat" : ".*--arch") -eq 0 ]; then
    P4C_ARGS+=(--arch ${arch})
fi

if [ $(expr "$p4c_args_concat" : ".*--target") -eq 0 ]; then
    P4C_ARGS+=(--target ${target})
fi

has_stf=false
if $run_stf && [ -r ${file%.p4}.stf ]; then
    has_stf=true
fi


if [ "$ptftestdir" != "" ] && [ ! -d ${ptftestdir} ]; then
    die "Invalid -ptfdir: $ptftestdir does not exist"
fi
if [ "$ptftestdir" = "" ]; then
    ptftestdir=${file%.p4}.ptf
    if [ ! -d ${ptftestdir} ] && ! $run_stf2ptf; then
        # no ptf to run
        run_ptf=false
    elif [ -d ${ptftestdir} ] && ! $has_stf; then
        # has ptf and no stf, so run the ptf
        run_ptf=true
    fi
fi

if $run_ptf && ! $run_bfrt && ! $run_pd && [ -d ${ptftestdir} ]; then
    for test_script in ${ptftestdir}/*.py; do
        if grep -q pd_base ${test_script}; then
            # test requires pd
            run_pd=true
            break
        fi
    done
fi

if $p4info; then
    p4runtime_out=$testdir/${name}${out_ext}.out/p4info.proto.txt
    P4C_ARGS+=(--p4runtime-files $p4runtime_out)
fi

if $run_bfrt; then
    bfrt_out=$testdir/${name}${out_ext}.out/bf-rt.json
    P4C_ARGS+=(--bf-rt-schema $bfrt_out)
fi

if $run_ptf || $run_stf2ptf; then
    # --p4runtime-force-std is required for TNA programs for which we run PTF
    # tests
    if [ $arch = "tna" ] || [ $arch = "t2na" ] || [ $arch = "t3na" ]; then
        P4C_ARGS+=(--p4runtime-force-std)
    fi
    P4C_ARGS+=(-Xassembler='--pipe0')
fi

# if we don't have PTF or STF tests to run, we can skip the linking step
# to save time
if ! $run_ptf && ! $has_stf && ! $force_link; then
    P4C_ARGS+=(--no-link)
fi

if $debug; then
    if $verbose; then
        echo $P4C -# "${P4C_ARGS[@]}" $file -o $testdir/${name}${out_ext}.out
    fi
    $P4C -# "${P4C_ARGS[@]}" $file -o $testdir/${name}${out_ext}.out | while read cmd rest; do
        if [[ -z $rest && $cmd =~ :$ ]]; then
            continue # skip the label
        elif [[ $cmd = parse ]]; then
            continue # skip the parse manifest: message
        elif $debug_p4c && [[ $cmd =~ p4c-barefoot ]]; then
            db="$DEBUGGER_COMMAND"
        elif $debug_bfas && [[ $cmd =~ bfas ]]; then
            db="$DEBUGGER_COMMAND"
        else
            db=""
        fi
        set -o noglob
        # don't try to expand wildcards in -T as files...
        if $verbose; then
            echo $db $cmd $rest
        fi
        </dev/tty $db $cmd $rest
        set +o noglob
    done
    exit
fi

# Not sure why the below lines are required, commenting for now.
# TODO: Remove if not required. Else, enable.
#if [ $(expr "$file" : ".*_errors") -gt 0 ]; then
#    if run $P4C ${P4C_ARGS[@]} $file -o $testdir/${name}${out_ext}.out; then
#        echo >&2 "$P4C did not give an error when expected"
#        exit 1
#    fi
#    exit 0
#fi

manifest=$testdir/${name}${out_ext}.out/manifest.json
if $run_pd ; then
    manifest=$testdir/${name}${out_ext}.out/${device}/${name}/manifest.json
fi

MANIFEST_CONFIG=$(findbin MANIFEST_CONFIG)
if [[ x$MANIFEST_CONFIG == x"" ]]; then
    echo >&2 "manifest-config not found"
    exit 1
fi

remove_old_files() {
    local pipes=( $2 )
    for p in "${pipes[@]}"; do
        output_dir=$name${out_ext}.out
        if [ -e $testdir/$output_dir ]; then
            if [ $1 == "p4-16" ]; then
                output_dir=$output_dir/$p
            fi
            rm -f $testdir/$name${out_ext}.bfa
            rm -f $testdir/$output_dir/$name${out_ext}.bfa
            rm -f $testdir/$output_dir/*.bin
            rm -f $testdir/$output_dir/*.bin.gz
            rm -f $testdir/$output_dir/*.cfg.json
            rm -f $testdir/$output_dir/*.cfg.json.gz
        fi
    done
}

if [ -r $manifest ]; then
    # find all pipe names from previous compilation
    pipes=$(${MANIFEST_CONFIG} --pipe ${manifest})
    # delete old outputs so we don't get confused if they're not overwritten
    remove_old_files $p4_version "$pipes"
fi

# Run P4C and extract pipes
native_compile() {
    echo "p4c: $P4C $@"
    run $P4C "$@" || die
    # find all pipe names from manifest.json in current compilation
    pipes=$(${MANIFEST_CONFIG} --pipe ${manifest})
}

compress_cfg_json() {
    local pipes=( $2 )
    for p in "${pipes[@]}"; do
        output_dir=$name${out_ext}.out
        if [ $1 == "p4-16" ]; then
            output_dir=$output_dir/$p
        fi
        for f in $testdir/$output_dir/*.cfg.json; do gzip -f $f; done
        if [ -r $testdir/$output_dir/${device}.bin ]; then
            if $run_ptf || $run_pd || $run_bfrt ; then
                true # ptf requires uncompressed binary
                if [ ${device} = "tofino2" ]; then
                    # backwards compatibility with old model/driver
                    ln -sf tofino2.bin $testdir/$output_dir/jbay.bin
                fi
            elif $run_stf; then
                # stf can run compressed binaries with recent updates
                gzip -f $testdir/$output_dir/${device}.bin
                if [ ${device} = "tofino2" ]; then
                    # backwards compatibility with old model/driver
                    ln -sf tofino2.bin.gz $testdir/$output_dir/jbay.bin.gz
                fi
            else
                #binary not needed
                rm $testdir/$output_dir/${device}.bin
            fi
        fi
        for f in $testdir/$output_dir/*.log; do gzip -f $f; done
    done
}

check_bfa() {
    local pipes=( $2 )
    for p in "${pipes[@]}"; do
        output_dir=$name${out_ext}.out
        if [ $1 == "p4-16" ]; then
            output_dir=$output_dir/$p
        fi
        if ! $run_pd && [ ! -r $testdir/$output_dir/$name.bfa ]; then
            echo >&2 "$P4C did not give an error but did not generate output either"
            exit 1
        fi
    done
}

# PD or BFRT runs the compiler as part of the p4-build make, so we skip running it here
# However, BFRT tests are PTF tests, and bfrt is used to generate the API.
if ! $run_pd && ! $run_ptf && ! $run_bfrt ; then
    native_compile "${P4C_ARGS[@]}" $file -o $testdir/${name}${out_ext}.out

    # compress cfg.json files if they exist
    compress_cfg_json $p4_version "$pipes"

    # sanity check
    check_bfa $p4_version "$pipes"
fi

if $run_stf && [ -r ${file%.p4}.stf ]; then
    STF=$(findbin HARLYN_STF_${toolsdevice})

    testout=$(realpath $testdir/$name${out_ext}.out)
    if [ ! -d $testout ]; then
        mkdir -p $testout
    fi

    if [[ "$file" =~ ^/ ]]; then
        test=${file%.p4}.stf
    else
        test=`pwd`/${file%.p4}.stf
    fi

    #obsLog=$name.p4.obs

    if $stf_bin ; then
        output_dir=$testout/${pipes[0]}/${device}.bin.gz
    else
        conf_args="--name $name --device $device --testdir $testout --pipe ${pipes}"
        run ./p4c-gen-bfrt-conf $conf_args

        output_dir=$testout
        if [ $p4_version == "p4-16" ]; then
            output_dir=$output_dir/${name}.conf
        fi
    fi

    run $STF -l $output_dir $test | \
        grep -v 'WARN MAU::[a-z_]* Time gone backwards!' \
        || die
fi

PTF_EXTRA_ARGS="$keep_PTF_LOGS --default-negative-timeout=0.2 $PTF_TEST_SPECS"

clean_process() {
    process_name="$1"
    echo "Checking if $process_name is running (it should not)..."
    pids=$(ps -ef | grep $process_name | grep -v grep | awk '{print $2}')
    for pid in $pids; do
        echo "Killing $pid..."
        sudo -n kill -s SIGTERM $pid
    done
}

if ${SKIP_PTFPD:=false}; then
    if ${P4TEST_CLEAN_PASSING:-false}; then
        rm -rf $testdir/${name}${out_ext}.out
    fi
    exit
fi

# Extract the tools install directory based on the install path of bf_switchd
# and set the exec and python paths to pick the locally installed paths first
# Picking the locally installed paths does not work for python3 which is installed
# by the driver, however, none of the pip packages are available there.
if $run_pd || $run_ptf || $run_bfrt ; then
    bf_switchd=$(findbin BF_SWITCHD)
    tools_dir=$( dirname $( dirname $bf_switchd ) )

    # add the tools at the end of the path because of python3.
    export PATH=${PATH}:${tools_dir}/bin

    # python paths should be set only for python2!! We should actually follow:
    # https://stackoverflow.com/questions/34066261/how-to-set-different-pythonpath-variables-for-python3-and-python2-respectively
    # if [ -z "$PYTHONPATH" ]; then
    #     export PYTHONPATH=${tools_dir}/lib/python2.7/site-packages
    # else
    #     export PYTHONPATH=${tools_dir}/lib/python2.7/site-packages:${PYTHONPATH}
    # fi
fi

# For ports.json file
if [ ! -z $PORTS_JSON_FILE ]; then
    ports_json_file="--port-map $PORTS_JSON_FILE"
fi

# Run autogen, configure, make and make install
configure_and_build() {
    local p4builddir=$1
    local config_args=$2
    local testout=$3
    local profile_opts=$4

    echo "Configuring $name in $testout"
    export MAKEFLAGS="-j $nproc"

    # set the path to the p4c-manifest-config for p4-build
    export PATH=${PATH}:$(dirname $MANIFEST_CONFIG)

    if [ ! -r $p4builddir/configure ] ; then
        pushd $p4builddir > /dev/null
        echo "Reconfiguring p4-build"
        run ./autogen.sh > /dev/null || die
        popd > /dev/null
    fi

    # force rebuilds if p4c or p4c-barefoot binary is newer than the build timestamp
    for f in $(find . -name p4c.ts); do
        if [ $P4C -nt $f -o ${P4C}-barefoot -nt $f ]; then
            rm $f
        fi
    done

    echo "Configure command: $p4builddir/configure $config_args P4FLAGS="$P4FLAGS" P4PPFLAGS="$P4PPFLAGS" PDFLAGS="$PDFLAGS""
    run $p4builddir/configure $config_args P4FLAGS="$P4FLAGS" P4PPFLAGS="$P4PPFLAGS" PDFLAGS="$PDFLAGS" >$testout/p4-build-conf.log || die

    if $verbose ; then
        tail -n 10 $testout/p4-build-conf.log
    fi
    echo "make command: make $profile_opts > $testout/p4-build-make.log"
    run make $profile_opts > $testout/p4-build-make.log || die
    # make install fails for bf-switch for subsequent test sets
    # TODO: fix this when switch team updates their make configuration/settings
    run make install > $testout/p4-build-make_install.log
}

set_env() {
    PTF_RUNNER=$(findbin HARLYN_PTF_DRIVER_WRAPPER)
    # Extract the tools install directory based on the install path of bf_switchd
    bf_switchd=$(findbin BF_SWITCHD)
    tools_dir=$( dirname $( dirname $bf_switchd ) )
    testout=$(realpath $testdir/$name${out_ext}.out)
    if [ ! -d $testout ]; then
        mkdir -p $testout
    fi

    # get the full path for P4C
    p4c=$(realpath $P4C)
    export P4C=$p4c
}

clean_env() {
    clean_process "$(findbin HARLYN_PTF_DRIVER_WRAPPER)"  # ptf_runner_wrapper
    clean_process "$(findbin HARLYN_PTF_DRIVER)"          # ptf_runner.py
    clean_process "$(findbin PTF)"                        # ptf
    clean_process "$(findbin BF_SWITCHD)"                 # bf_switchd
    clean_process "$(findbin HARLYN_MODEL)"               # tofino-model
}

# For p4_14 programs and switch PTF tests using PD API
if $run_pd ; then
    # If P4C_pd specified and running a pd test, apply the path based on the
    # compiler choice. Needs to be before setting the environment.
    if [ ! -z "$P4C_pd" ]; then
        P4C=$P4C_pd
    fi

    set_env

    name=$(echo $name | tr -d '.-')  # strip out illegal C identifier chars

    # generate the conf file. FIXME: This should really be part of p4-build!!
    gen_conf_args="--name $name --device $device --testdir $testout"

    if [ $name == switch ]; then
        if [ $device == tofino2 ]; then
            p4builddir="$(dirname $0)/p4_14/switch-jbay"
        elif [ $device == tofino3 ]; then
            # will we need a different switch for cloudbreak?  for now use switch-jbay
            p4builddir="$(dirname $0)/p4_14/switch-jbay"
        else
            if [[ "$file" == *8.7* ]]; then
                p4builddir="$(dirname $0)/p4_14/switch-8.7"
            else
                p4builddir="$(dirname $0)/p4_14/switch"
            fi
        fi
        config_args="--enable-thrift --disable-static --with-${device} \
                    --with-switchsai --with-cpu-veth --prefix $testout --with-p4c=$P4C \
                        --bindir=$(dirname $P4C):${tools_dir}/bin \
                    P4_PREFIX=dc P4_NAME=$name P4_PATH=$file \
                    P4_ARCHITECTURE=$arch P4_VERSION=$p4_version"
        if [[ "$ptftestdir" == *sai* ]]; then
            gen_conf_args="$gen_conf_args --switch-api switchsai"
            port_map_file="--port_map_file $PORT_MAP_FILE"
            if [ ! -z "$TEST_PORT" ]; then
                test_port="--test_port $TEST_PORT"
            fi
        else
            gen_conf_args="$gen_conf_args --switch-api switchapi"
        fi
    else
        p4builddir="$(dirname $0)/p4_14/switch/p4-build"
        config_args="--with-${device} --with-p4c=$P4C --enable-thrift \
                    --prefix=$testout LDFLAGS="-L${tools_dir}/lib" CPPFLAGS="-I${tools_dir}/include" \
                    --bindir=$(dirname $P4C):${tools_dir}/bin P4_NAME=$name P4_PATH=$file \
                    P4_ARCHITECTURE=$arch P4_VERSION=$p4_version"
    fi

    pushd $testout > /dev/null
    configure_and_build $p4builddir "$config_args" $testout
    popd > /dev/null  # $testout

    run $(dirname $0)/gen_pd_conf.py $gen_conf_args

    PTF_RUNNER=$(findbin HARLYN_PTF_DRIVER_WRAPPER)
    echo "Test dir: ${ptftestdir}"
    if [ -d ${ptftestdir} ]; then
        PTF_CMD="$PTF_RUNNER --testdir $testout \
                             --name $name \
                             --ptfdir ${ptftestdir} \
                             --top-builddir $(findcmakecache) \
                             --pdtest $testout/${name}.conf \
                             --device ${device} \
                             $ports_json_file \
                             $port_map_file \
                             $test_port \
                             $PTF_EXTRA_ARGS"
        clean_env
        echo $PTF_CMD
        run $PTF_CMD
        ptf_test_status=$?
        clean_env
        if ${P4TEST_CLEAN_PASSING:-false} && [ $ptf_test_status -eq 0 ]; then
            rm -rf $testdir/${name}${out_ext}.out
        fi
        exit $ptf_test_status
    fi
fi

# For p4_14 and p4_16 PI PTF tests
# (need to add !run_bfrt check as run_ptf is enabled for all p4s with ptfs specified)
if $run_ptf && ! $run_bfrt ; then
    set_env

    native_compile "${P4C_ARGS[@]}" $file -o $testout

    if [ $p4_version == "p4-16" ]; then
        conf_args="--name $name --device $device --testdir $testout $installdiropt --pipe ${pipes}"
        run ./p4c-gen-bfrt-conf $conf_args
        PTF_EXTRA_ARGS="$PTF_EXTRA_ARGS --run-bfrt-as-pi ${pipes}"
    fi

    if [ -d ${ptftestdir} ]; then
        PTF_CMD="$PTF_RUNNER --testdir $testout --name $name \
                --ptfdir ${ptftestdir} --top-builddir $(findcmakecache) \
                --device ${device} \
                $ports_json_file \
                $PTF_EXTRA_ARGS"
    elif $run_stf2ptf && [ -r ${file%.p4}.stf ]; then
        mydir=$(dirname $0)
        export PYTHONPATH=${PYTHONPATH}:${mydir}/tools/stf
        if [[ "$file" =~ ^/ ]]; then
            stftest=${file%.p4}.stf
        else
            stftest=`pwd`/${file%.p4}.stf
        fi
        PTF_CMD="$PTF_RUNNER --testdir $testout --name $name \
                --stftest ${stftest} \
                --ptfdir ${mydir}/tools/stf --top-builddir $(findcmakecache) \
                --device ${device} \
                $PTF_EXTRA_ARGS"
    fi

    if [ -n "$PTF_CMD" ]; then
        clean_env
        echo $PTF_CMD
        run $PTF_CMD
        ptf_test_status=$?
        clean_env
        if ${P4TEST_CLEAN_PASSING:-false} && [ $ptf_test_status -eq 0 ]; then
            rm -rf $testdir/${name}${out_ext}.out
        fi
        exit $ptf_test_status
    fi
fi

# For p4_16_programs
if $run_bfrt; then
    if [[ $name != *"switch_tofino"* ]]; then
        set_env

        result_file="$testout/build_result.txt"
        if [ -d "$ptftestdir" ] && [ -r "$result_file" ] && [ "$(cat "$result_file")" = "0" ]; then
            echo "Using existing P4 build in $testout/build/." \
                 "Remove $result_file and rerun to recompile the program."
        else
            echo "Building $file in $testout/build/"
            rm -f "$result_file"
            P4C_ARGS+=(--bf-rt-schema "$testout/build/bf-rt.json")
            native_compile "${P4C_ARGS[@]}" "$file" -o "$testout/build"
            echo $? > "$result_file"
        fi

        manifest="$testout/build/manifest.json"
        if [ -f "$manifest" ]; then
            pipes=$("$MANIFEST_CONFIG" --pipe "$manifest")
        fi

        if [ "$p4_version" == "p4-16" ]; then
            conf_args="--name $name --device $device --testdir $testout --installdir $testout/build --pipe ${pipes}"
            model_logs_option=""
            echo "gen_config_opts: ./p4c-gen-bfrt-conf $conf_args"
            run ./p4c-gen-bfrt-conf $conf_args
            PTF_EXTRA_ARGS="$PTF_EXTRA_ARGS --bfrt-test $testout/${name}.conf $model_logs_option"
        fi

        if [ -d ${ptftestdir} ]; then
            PTF_CMD="$PTF_RUNNER --testdir $testout --name $name \
                    --ptfdir ${ptftestdir} --top-builddir $(findcmakecache) \
                    --device ${device} \
                    $ports_json_file \
                    $PTF_EXTRA_ARGS"
        fi

        if [ -n "$PTF_CMD" ]; then
            clean_env
            echo $PTF_CMD
            run $PTF_CMD
            ptf_test_status=$?
            clean_env
            if ${P4TEST_CLEAN_PASSING:-false} && [ $ptf_test_status -eq 0 ]; then
                rm -rf $testdir/${name}${out_ext}.out
            fi
            exit $ptf_test_status
        fi
    # For switch_16 BFRT tests
    else
        set_env

        p4Builddir="$(dirname $0)/p4_16/switch_16"
        switchBuild="$p4Builddir/${name}${out_ext}.out"
        if [ ! -d $switchBuild ]; then
            mkdir -p $switchBuild
        fi

        cmakeConfigure="cmake .. -DCMAKE_MODULE_PATH=/p4factory/cmake -DCMAKE_INSTALL_PREFIX=$switchBuild -DSTANDALONE=on"
        echo "Configure command: $cmakeConfigure"
        pushd $switchBuild > /dev/null
        # cmake looks for ${CMAKE_INSTALL_PREFIX}/bin/bf-p4c, i.e. ${switchBuild}/bin/bf-p4c
        rm -rf "bin/bf-p4c" && mkdir -p "bin" && ln -s "$P4C" "bin/bf-p4c"
        run $cmakeConfigure
        popd > /dev/null  # $switchBuild

        makeCmd="make -j $nproc $profile"
        echo "make command: $makeCmd > $switchBuild/p4-build-make.log"
        pushd $switchBuild > /dev/null
        touch $switchBuild/p4-build-make.log
        run $makeCmd > $switchBuild/p4-build-make.log || die
        makeInstallCmd="make -j $nproc install"
        echo "make install command: $makeInstallCmd > $switchBuild/p4-build-make_install.log"
        touch $switchBuild/p4-build-make_install.log
        run $makeInstallCmd > $switchBuild/p4-build-make_install.log || die
        popd > /dev/null  # $switchBuild
        if $verbose ; then
            tail -n 10 $switchBuild/p4-build-make.log
        fi

        # Generate config file
        manifest="$switchBuild/p4src/switch/manifest.json"
        if [ -f "$manifest" ]; then
            pipes=$("$MANIFEST_CONFIG" --pipe "$manifest")
        fi
        conf_args="--name switch --device $device --testdir $switchBuild --pipe $pipes"
        echo "gen_config_opts: ./p4c-gen-bfrt-conf $conf_args"
        run ./p4c-gen-bfrt-conf $conf_args

        if [ -d ${ptftestdir} ]; then
            PTF_RUNNER=$(findbin HARLYN_PTF_DRIVER_WRAPPER)
            PTF_EXTRA_ARGS="$PTF_EXTRA_ARGS --bfrt-test $switchBuild/switch.conf --enable-model-logging"
            PTF_CMD="$PTF_RUNNER --testdir $switchBuild --name switch \
                        --ptfdir ${ptftestdir} --top-builddir $(findcmakecache) \
                        --device ${device} \
                        $ports_json_file \
                        $PTF_EXTRA_ARGS"
            echo $PTF_CMD
        fi

        if [ -n "$PTF_CMD" ]; then
            clean_env
            run $PTF_CMD
            ptf_test_status=$?
            clean_env
            if ${P4TEST_CLEAN_PASSING:-false} && [ $ptf_test_status -eq 0 ]; then
                rm -rf $switchBuild
            fi
            exit $ptf_test_status
        fi
    fi
fi

if ${P4TEST_CLEAN_PASSING:-false}; then
    rm -rf $testdir/${name}${out_ext}.out
fi

if [[ " $IFAIL_TESTS " =~ " $testdir/$name.p4.test " ]]; then
    echo "intermittent test PASSED"
    exit 1
fi
