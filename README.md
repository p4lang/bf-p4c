# Tofino back-end details

The backend is where most of the resource allocation decisions take
place.  Resource allocation passes should take extra ‘hints’ inputs to
drive decisions based on previous failed attempts that triggered
backtracking.  This is a potential exponential blowup, so care needs
to be taken to avoid attempts that are probably unprofitable -- tuning
will be needed.

To the extent that it does not complicate the code too much, it should
be parameterized based on architecture details.  The intent is
that the code should be reusable for multiple architecture families.

Passes that will be needed include (in rough order, though things can
be done in different orders):

* Analyze control flow conditions to see which ones can be encoded as
  gateways; split conditions that are too complex into smaller
  conditions.

* Parser state splitting -- states that do too much (write too many
  output bytes) need to be split into multiple states

* Parser state combining -- small consecutive states can be combined.

* Collect P4 tables into logical table groups -- each consists of a
  single match table or control flow condition and all the associated
  action (profile) data, selection, counter, meter, etc tables.
  Associated tables may be associated with more that one match table?

* Find the use-def chains for all header and metadata fields.
  Consider something like SSA form?  This is an auxiliary data table
  (not in the IR directly) indexed by field name, and other passes
  will want to create additional information that is similarly indexed
  (to indicate additional constraints), so we may want to copy this to
  support backtracking.

* Find the dependencies between logical tables -- match, action,
  control and write-after-read dependencies.

* Determine layout and organization to use for each logical table --
  there are multiple possibilities (particularly for exact match), so
  this is a branching point.

* Figure out resources required for each logical table (number of
  rams/tcams/maprams, busses, xbar space)

* Gateway duplication -- where a single gateway has multiple tables
  control dependent on it, can duplicate the gateway, making each
  dependent table dependent on its own copy of the gateway (increases
  scheduling flexibility).  Probably only do this after table
  placement has failed?

* Table placement and splitting -- allocate tables to specific stages
  and specific logical order within stages.  Split tables across
  stages as needed.  Combine conditions with match tables as a single
  logical table where possible.  Many choices for table ordering, so
  this is a branching point.

* PHV allocation -- greedy allocator, or graph-coloring?

* Final table allocation -- allocate specific rams/busses/xbars for each table.

* Final codegen

Once all the various allocation decision have been made, once or more
final transformations may be needed to get the IR into a form where
assembly code can be easily generated for it:

* Split operations on fields that have have been split across PHV
  containers into multiple instructions

* Assembly code can be generated by a simple pass.
